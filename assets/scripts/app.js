/*! For license information please see app.js.LICENSE.txt */
!function() {
    var e, t = {
        714: function(e) {
            e.exports = function() {
                function e(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var r = t[n];
                        r.enumerable = r.enumerable || !1,
                        r.configurable = !0,
                        "value"in r && (r.writable = !0),
                        Object.defineProperty(e, r.key, r)
                    }
                }
                function t(t, n, r) {
                    return n && e(t.prototype, n),
                    r && e(t, r),
                    t
                }
                function n() {
                    return (n = Object.assign || function(e) {
                        for (var t = 1; t < arguments.length; t++) {
                            var n = arguments[t];
                            for (var r in n)
                                Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                        }
                        return e
                    }
                    ).apply(this, arguments)
                }
                function r(e, t) {
                    e.prototype = Object.create(t.prototype),
                    e.prototype.constructor = e,
                    e.__proto__ = t
                }
                function i(e) {
                    return (i = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
                        return e.__proto__ || Object.getPrototypeOf(e)
                    }
                    )(e)
                }
                function a(e, t) {
                    return (a = Object.setPrototypeOf || function(e, t) {
                        return e.__proto__ = t,
                        e
                    }
                    )(e, t)
                }
                function s(e, t, n) {
                    return (s = function() {
                        if ("undefined" == typeof Reflect || !Reflect.construct)
                            return !1;
                        if (Reflect.construct.sham)
                            return !1;
                        if ("function" == typeof Proxy)
                            return !0;
                        try {
                            return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}
                            ))),
                            !0
                        } catch (e) {
                            return !1
                        }
                    }() ? Reflect.construct : function(e, t, n) {
                        var r = [null];
                        r.push.apply(r, t);
                        var i = new (Function.bind.apply(e, r));
                        return n && a(i, n.prototype),
                        i
                    }
                    ).apply(null, arguments)
                }
                function o(e) {
                    var t = "function" == typeof Map ? new Map : void 0;
                    return (o = function(e) {
                        if (null === e || -1 === Function.toString.call(e).indexOf("[native code]"))
                            return e;
                        if ("function" != typeof e)
                            throw new TypeError("Super expression must either be null or a function");
                        if (void 0 !== t) {
                            if (t.has(e))
                                return t.get(e);
                            t.set(e, n)
                        }
                        function n() {
                            return s(e, arguments, i(this).constructor)
                        }
                        return n.prototype = Object.create(e.prototype, {
                            constructor: {
                                value: n,
                                enumerable: !1,
                                writable: !0,
                                configurable: !0
                            }
                        }),
                        a(n, e)
                    }
                    )(e)
                }
                function l(e, t) {
                    try {
                        var n = e()
                    } catch (e) {
                        return t(e)
                    }
                    return n && n.then ? n.then(void 0, t) : n
                }
                "undefined" != typeof Symbol && (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))),
                "undefined" != typeof Symbol && (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")));
                var c, u = "2.9.7", d = function() {};
                !function(e) {
                    e[e.off = 0] = "off",
                    e[e.error = 1] = "error",
                    e[e.warning = 2] = "warning",
                    e[e.info = 3] = "info",
                    e[e.debug = 4] = "debug"
                }(c || (c = {}));
                var h = c.off
                  , p = function() {
                    function e(e) {
                        this.t = e
                    }
                    e.getLevel = function() {
                        return h
                    }
                    ,
                    e.setLevel = function(e) {
                        return h = c[e]
                    }
                    ;
                    var t = e.prototype;
                    return t.error = function() {
                        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                            t[n] = arguments[n];
                        this.i(console.error, c.error, t)
                    }
                    ,
                    t.warn = function() {
                        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                            t[n] = arguments[n];
                        this.i(console.warn, c.warning, t)
                    }
                    ,
                    t.info = function() {
                        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                            t[n] = arguments[n];
                        this.i(console.info, c.info, t)
                    }
                    ,
                    t.debug = function() {
                        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                            t[n] = arguments[n];
                        this.i(console.log, c.debug, t)
                    }
                    ,
                    t.i = function(t, n, r) {
                        n <= e.getLevel() && t.apply(console, ["[" + this.t + "] "].concat(r))
                    }
                    ,
                    e
                }()
                  , f = C
                  , m = E
                  , g = b
                  , v = S
                  , _ = A
                  , y = "/"
                  , x = new RegExp(["(\\\\.)", "(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?"].join("|"),"g");
                function b(e, t) {
                    for (var n, r = [], i = 0, a = 0, s = "", o = t && t.delimiter || y, l = t && t.whitelist || void 0, c = !1; null !== (n = x.exec(e)); ) {
                        var u = n[0]
                          , d = n[1]
                          , h = n.index;
                        if (s += e.slice(a, h),
                        a = h + u.length,
                        d)
                            s += d[1],
                            c = !0;
                        else {
                            var p = ""
                              , f = n[2]
                              , m = n[3]
                              , g = n[4]
                              , v = n[5];
                            if (!c && s.length) {
                                var _ = s.length - 1
                                  , b = s[_];
                                (!l || l.indexOf(b) > -1) && (p = b,
                                s = s.slice(0, _))
                            }
                            s && (r.push(s),
                            s = "",
                            c = !1);
                            var E = m || g
                              , S = p || o;
                            r.push({
                                name: f || i++,
                                prefix: p,
                                delimiter: S,
                                optional: "?" === v || "*" === v,
                                repeat: "+" === v || "*" === v,
                                pattern: E ? M(E) : "[^" + w(S === o ? S : S + o) + "]+?"
                            })
                        }
                    }
                    return (s || a < e.length) && r.push(s + e.substr(a)),
                    r
                }
                function E(e, t) {
                    return function(n, r) {
                        var i = e.exec(n);
                        if (!i)
                            return !1;
                        for (var a = i[0], s = i.index, o = {}, l = r && r.decode || decodeURIComponent, c = 1; c < i.length; c++)
                            if (void 0 !== i[c]) {
                                var u = t[c - 1];
                                o[u.name] = u.repeat ? i[c].split(u.delimiter).map((function(e) {
                                    return l(e, u)
                                }
                                )) : l(i[c], u)
                            }
                        return {
                            path: a,
                            index: s,
                            params: o
                        }
                    }
                }
                function S(e, t) {
                    for (var n = new Array(e.length), r = 0; r < e.length; r++)
                        "object" == typeof e[r] && (n[r] = new RegExp("^(?:" + e[r].pattern + ")$",T(t)));
                    return function(t, r) {
                        for (var i = "", a = r && r.encode || encodeURIComponent, s = !r || !1 !== r.validate, o = 0; o < e.length; o++) {
                            var l = e[o];
                            if ("string" != typeof l) {
                                var c, u = t ? t[l.name] : void 0;
                                if (Array.isArray(u)) {
                                    if (!l.repeat)
                                        throw new TypeError('Expected "' + l.name + '" to not repeat, but got array');
                                    if (0 === u.length) {
                                        if (l.optional)
                                            continue;
                                        throw new TypeError('Expected "' + l.name + '" to not be empty')
                                    }
                                    for (var d = 0; d < u.length; d++) {
                                        if (c = a(u[d], l),
                                        s && !n[o].test(c))
                                            throw new TypeError('Expected all "' + l.name + '" to match "' + l.pattern + '"');
                                        i += (0 === d ? l.prefix : l.delimiter) + c
                                    }
                                } else if ("string" != typeof u && "number" != typeof u && "boolean" != typeof u) {
                                    if (!l.optional)
                                        throw new TypeError('Expected "' + l.name + '" to be ' + (l.repeat ? "an array" : "a string"))
                                } else {
                                    if (c = a(String(u), l),
                                    s && !n[o].test(c))
                                        throw new TypeError('Expected "' + l.name + '" to match "' + l.pattern + '", but got "' + c + '"');
                                    i += l.prefix + c
                                }
                            } else
                                i += l
                        }
                        return i
                    }
                }
                function w(e) {
                    return e.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1")
                }
                function M(e) {
                    return e.replace(/([=!:$/()])/g, "\\$1")
                }
                function T(e) {
                    return e && e.sensitive ? "" : "i"
                }
                function A(e, t, n) {
                    for (var r = (n = n || {}).strict, i = !1 !== n.start, a = !1 !== n.end, s = n.delimiter || y, o = [].concat(n.endsWith || []).map(w).concat("$").join("|"), l = i ? "^" : "", c = 0; c < e.length; c++) {
                        var u = e[c];
                        if ("string" == typeof u)
                            l += w(u);
                        else {
                            var d = u.repeat ? "(?:" + u.pattern + ")(?:" + w(u.delimiter) + "(?:" + u.pattern + "))*" : u.pattern;
                            t && t.push(u),
                            l += u.optional ? u.prefix ? "(?:" + w(u.prefix) + "(" + d + "))?" : "(" + d + ")?" : w(u.prefix) + "(" + d + ")"
                        }
                    }
                    if (a)
                        r || (l += "(?:" + w(s) + ")?"),
                        l += "$" === o ? "$" : "(?=" + o + ")";
                    else {
                        var h = e[e.length - 1]
                          , p = "string" == typeof h ? h[h.length - 1] === s : void 0 === h;
                        r || (l += "(?:" + w(s) + "(?=" + o + "))?"),
                        p || (l += "(?=" + w(s) + "|" + o + ")")
                    }
                    return new RegExp(l,T(n))
                }
                function C(e, t, n) {
                    return e instanceof RegExp ? function(e, t) {
                        if (!t)
                            return e;
                        var n = e.source.match(/\((?!\?)/g);
                        if (n)
                            for (var r = 0; r < n.length; r++)
                                t.push({
                                    name: r,
                                    prefix: null,
                                    delimiter: null,
                                    optional: !1,
                                    repeat: !1,
                                    pattern: null
                                });
                        return e
                    }(e, t) : Array.isArray(e) ? function(e, t, n) {
                        for (var r = [], i = 0; i < e.length; i++)
                            r.push(C(e[i], t, n).source);
                        return new RegExp("(?:" + r.join("|") + ")",T(n))
                    }(e, t, n) : function(e, t, n) {
                        return A(b(e, n), t, n)
                    }(e, t, n)
                }
                f.match = function(e, t) {
                    var n = [];
                    return E(C(e, n, t), n)
                }
                ,
                f.regexpToFunction = m,
                f.parse = g,
                f.compile = function(e, t) {
                    return S(b(e, t), t)
                }
                ,
                f.tokensToFunction = v,
                f.tokensToRegExp = _;
                var P = {
                    container: "container",
                    history: "history",
                    namespace: "namespace",
                    prefix: "data-barba",
                    prevent: "prevent",
                    wrapper: "wrapper"
                }
                  , R = new (function() {
                    function e() {
                        this.o = P,
                        this.u = new DOMParser
                    }
                    var t = e.prototype;
                    return t.toString = function(e) {
                        return e.outerHTML
                    }
                    ,
                    t.toDocument = function(e) {
                        return this.u.parseFromString(e, "text/html")
                    }
                    ,
                    t.toElement = function(e) {
                        var t = document.createElement("div");
                        return t.innerHTML = e,
                        t
                    }
                    ,
                    t.getHtml = function(e) {
                        return void 0 === e && (e = document),
                        this.toString(e.documentElement)
                    }
                    ,
                    t.getWrapper = function(e) {
                        return void 0 === e && (e = document),
                        e.querySelector("[" + this.o.prefix + '="' + this.o.wrapper + '"]')
                    }
                    ,
                    t.getContainer = function(e) {
                        return void 0 === e && (e = document),
                        e.querySelector("[" + this.o.prefix + '="' + this.o.container + '"]')
                    }
                    ,
                    t.removeContainer = function(e) {
                        document.body.contains(e) && e.parentNode.removeChild(e)
                    }
                    ,
                    t.addContainer = function(e, t) {
                        var n = this.getContainer();
                        n ? this.s(e, n) : t.appendChild(e)
                    }
                    ,
                    t.getNamespace = function(e) {
                        void 0 === e && (e = document);
                        var t = e.querySelector("[" + this.o.prefix + "-" + this.o.namespace + "]");
                        return t ? t.getAttribute(this.o.prefix + "-" + this.o.namespace) : null
                    }
                    ,
                    t.getHref = function(e) {
                        if (e.tagName && "a" === e.tagName.toLowerCase()) {
                            if ("string" == typeof e.href)
                                return e.href;
                            var t = e.getAttribute("href") || e.getAttribute("xlink:href");
                            if (t)
                                return this.resolveUrl(t.baseVal || t)
                        }
                        return null
                    }
                    ,
                    t.resolveUrl = function() {
                        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                            t[n] = arguments[n];
                        var r = t.length;
                        if (0 === r)
                            throw new Error("resolveUrl requires at least one argument; got none.");
                        var i = document.createElement("base");
                        if (i.href = arguments[0],
                        1 === r)
                            return i.href;
                        var a = document.getElementsByTagName("head")[0];
                        a.insertBefore(i, a.firstChild);
                        for (var s, o = document.createElement("a"), l = 1; l < r; l++)
                            o.href = arguments[l],
                            i.href = s = o.href;
                        return a.removeChild(i),
                        s
                    }
                    ,
                    t.s = function(e, t) {
                        t.parentNode.insertBefore(e, t.nextSibling)
                    }
                    ,
                    e
                }())
                  , L = new (function() {
                    function e() {
                        this.h = [],
                        this.v = -1
                    }
                    var r = e.prototype;
                    return r.init = function(e, t) {
                        this.l = "barba";
                        var n = {
                            ns: t,
                            scroll: {
                                x: window.scrollX,
                                y: window.scrollY
                            },
                            url: e
                        };
                        this.h.push(n),
                        this.v = 0;
                        var r = {
                            from: this.l,
                            index: 0,
                            states: [].concat(this.h)
                        };
                        window.history && window.history.replaceState(r, "", e)
                    }
                    ,
                    r.change = function(e, t, n) {
                        if (n && n.state) {
                            var r = n.state
                              , i = r.index;
                            t = this.m(this.v - i),
                            this.replace(r.states),
                            this.v = i
                        } else
                            this.add(e, t);
                        return t
                    }
                    ,
                    r.add = function(e, t) {
                        var n = this.size
                          , r = this.p(t)
                          , i = {
                            ns: "tmp",
                            scroll: {
                                x: window.scrollX,
                                y: window.scrollY
                            },
                            url: e
                        };
                        this.h.push(i),
                        this.v = n;
                        var a = {
                            from: this.l,
                            index: n,
                            states: [].concat(this.h)
                        };
                        switch (r) {
                        case "push":
                            window.history && window.history.pushState(a, "", e);
                            break;
                        case "replace":
                            window.history && window.history.replaceState(a, "", e)
                        }
                    }
                    ,
                    r.update = function(e, t) {
                        var r = t || this.v
                          , i = n({}, this.get(r), {}, e);
                        this.set(r, i)
                    }
                    ,
                    r.remove = function(e) {
                        e ? this.h.splice(e, 1) : this.h.pop(),
                        this.v--
                    }
                    ,
                    r.clear = function() {
                        this.h = [],
                        this.v = -1
                    }
                    ,
                    r.replace = function(e) {
                        this.h = e
                    }
                    ,
                    r.get = function(e) {
                        return this.h[e]
                    }
                    ,
                    r.set = function(e, t) {
                        return this.h[e] = t
                    }
                    ,
                    r.p = function(e) {
                        var t = "push"
                          , n = e
                          , r = P.prefix + "-" + P.history;
                        return n.hasAttribute && n.hasAttribute(r) && (t = n.getAttribute(r)),
                        t
                    }
                    ,
                    r.m = function(e) {
                        return Math.abs(e) > 1 ? e > 0 ? "forward" : "back" : 0 === e ? "popstate" : e > 0 ? "back" : "forward"
                    }
                    ,
                    t(e, [{
                        key: "current",
                        get: function() {
                            return this.h[this.v]
                        }
                    }, {
                        key: "state",
                        get: function() {
                            return this.h[this.h.length - 1]
                        }
                    }, {
                        key: "previous",
                        get: function() {
                            return this.v < 1 ? null : this.h[this.v - 1]
                        }
                    }, {
                        key: "size",
                        get: function() {
                            return this.h.length
                        }
                    }]),
                    e
                }())
                  , O = function(e, t) {
                    try {
                        var n = function() {
                            if (!t.next.html)
                                return Promise.resolve(e).then((function(e) {
                                    var n = t.next;
                                    if (e) {
                                        var r = R.toElement(e);
                                        n.namespace = R.getNamespace(r),
                                        n.container = R.getContainer(r),
                                        n.html = e,
                                        L.update({
                                            ns: n.namespace
                                        });
                                        var i = R.toDocument(e);
                                        document.title = i.title
                                    }
                                }
                                ))
                        }();
                        return Promise.resolve(n && n.then ? n.then((function() {}
                        )) : void 0)
                    } catch (e) {
                        return Promise.reject(e)
                    }
                }
                  , D = f
                  , I = {
                    __proto__: null,
                    update: O,
                    nextTick: function() {
                        return new Promise((function(e) {
                            window.requestAnimationFrame(e)
                        }
                        ))
                    },
                    pathToRegexp: D
                }
                  , N = function() {
                    return window.location.origin
                }
                  , U = function(e) {
                    return void 0 === e && (e = window.location.href),
                    k(e).port
                }
                  , k = function(e) {
                    var t, n = e.match(/:\d+/);
                    if (null === n)
                        /^http/.test(e) && (t = 80),
                        /^https/.test(e) && (t = 443);
                    else {
                        var r = n[0].substring(1);
                        t = parseInt(r, 10)
                    }
                    var i, a = e.replace(N(), ""), s = {}, o = a.indexOf("#");
                    o >= 0 && (i = a.slice(o + 1),
                    a = a.slice(0, o));
                    var l = a.indexOf("?");
                    return l >= 0 && (s = F(a.slice(l + 1)),
                    a = a.slice(0, l)),
                    {
                        hash: i,
                        path: a,
                        port: t,
                        query: s
                    }
                }
                  , F = function(e) {
                    return e.split("&").reduce((function(e, t) {
                        var n = t.split("=");
                        return e[n[0]] = n[1],
                        e
                    }
                    ), {})
                }
                  , z = function(e) {
                    return void 0 === e && (e = window.location.href),
                    e.replace(/(\/#.*|\/|#.*)$/, "")
                }
                  , B = {
                    __proto__: null,
                    getHref: function() {
                        return window.location.href
                    },
                    getOrigin: N,
                    getPort: U,
                    getPath: function(e) {
                        return void 0 === e && (e = window.location.href),
                        k(e).path
                    },
                    parse: k,
                    parseQuery: F,
                    clean: z
                };
                function H(e, t, n) {
                    return void 0 === t && (t = 2e3),
                    new Promise((function(r, i) {
                        var a = new XMLHttpRequest;
                        a.onreadystatechange = function() {
                            if (a.readyState === XMLHttpRequest.DONE)
                                if (200 === a.status)
                                    r(a.responseText);
                                else if (a.status) {
                                    var t = {
                                        status: a.status,
                                        statusText: a.statusText
                                    };
                                    n(e, t),
                                    i(t)
                                }
                        }
                        ,
                        a.ontimeout = function() {
                            var r = new Error("Timeout error [" + t + "]");
                            n(e, r),
                            i(r)
                        }
                        ,
                        a.onerror = function() {
                            var t = new Error("Fetch error");
                            n(e, t),
                            i(t)
                        }
                        ,
                        a.open("GET", e),
                        a.timeout = t,
                        a.setRequestHeader("Accept", "text/html,application/xhtml+xml,application/xml"),
                        a.setRequestHeader("x-barba", "yes"),
                        a.send()
                    }
                    ))
                }
                var G = function(e) {
                    return !!e && ("object" == typeof e || "function" == typeof e) && "function" == typeof e.then
                };
                function V(e, t) {
                    return void 0 === t && (t = {}),
                    function() {
                        for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++)
                            r[i] = arguments[i];
                        var a = !1
                          , s = new Promise((function(n, i) {
                            t.async = function() {
                                return a = !0,
                                function(e, t) {
                                    e ? i(e) : n(t)
                                }
                            }
                            ;
                            var s = e.apply(t, r);
                            a || (G(s) ? s.then(n, i) : n(s))
                        }
                        ));
                        return s
                    }
                }
                var W = new (function(e) {
                    function t() {
                        var t;
                        return (t = e.call(this) || this).logger = new p("@barba/core"),
                        t.all = ["ready", "page", "reset", "currentAdded", "currentRemoved", "nextAdded", "nextRemoved", "beforeOnce", "once", "afterOnce", "before", "beforeLeave", "leave", "afterLeave", "beforeEnter", "enter", "afterEnter", "after"],
                        t.registered = new Map,
                        t.init(),
                        t
                    }
                    r(t, e);
                    var n = t.prototype;
                    return n.init = function() {
                        var e = this;
                        this.registered.clear(),
                        this.all.forEach((function(t) {
                            e[t] || (e[t] = function(n, r) {
                                e.registered.has(t) || e.registered.set(t, new Set),
                                e.registered.get(t).add({
                                    ctx: r || {},
                                    fn: n
                                })
                            }
                            )
                        }
                        ))
                    }
                    ,
                    n.do = function(e) {
                        for (var t = this, n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
                            r[i - 1] = arguments[i];
                        if (this.registered.has(e)) {
                            var a = Promise.resolve();
                            return this.registered.get(e).forEach((function(e) {
                                a = a.then((function() {
                                    return V(e.fn, e.ctx).apply(void 0, r)
                                }
                                ))
                            }
                            )),
                            a.catch((function(n) {
                                t.logger.debug("Hook error [" + e + "]"),
                                t.logger.error(n)
                            }
                            ))
                        }
                        return Promise.resolve()
                    }
                    ,
                    n.clear = function() {
                        var e = this;
                        this.all.forEach((function(t) {
                            delete e[t]
                        }
                        )),
                        this.init()
                    }
                    ,
                    n.help = function() {
                        this.logger.info("Available hooks: " + this.all.join(","));
                        var e = [];
                        this.registered.forEach((function(t, n) {
                            return e.push(n)
                        }
                        )),
                        this.logger.info("Registered hooks: " + e.join(","))
                    }
                    ,
                    t
                }(d))
                  , j = function() {
                    function e(e) {
                        if (this.P = [],
                        "boolean" == typeof e)
                            this.g = e;
                        else {
                            var t = Array.isArray(e) ? e : [e];
                            this.P = t.map((function(e) {
                                return D(e)
                            }
                            ))
                        }
                    }
                    return e.prototype.checkHref = function(e) {
                        if ("boolean" == typeof this.g)
                            return this.g;
                        var t = k(e).path;
                        return this.P.some((function(e) {
                            return null !== e.exec(t)
                        }
                        ))
                    }
                    ,
                    e
                }()
                  , X = function(e) {
                    function t(t) {
                        var n;
                        return (n = e.call(this, t) || this).k = new Map,
                        n
                    }
                    r(t, e);
                    var i = t.prototype;
                    return i.set = function(e, t, n) {
                        return this.k.set(e, {
                            action: n,
                            request: t
                        }),
                        {
                            action: n,
                            request: t
                        }
                    }
                    ,
                    i.get = function(e) {
                        return this.k.get(e)
                    }
                    ,
                    i.getRequest = function(e) {
                        return this.k.get(e).request
                    }
                    ,
                    i.getAction = function(e) {
                        return this.k.get(e).action
                    }
                    ,
                    i.has = function(e) {
                        return !this.checkHref(e) && this.k.has(e)
                    }
                    ,
                    i.delete = function(e) {
                        return this.k.delete(e)
                    }
                    ,
                    i.update = function(e, t) {
                        var r = n({}, this.k.get(e), {}, t);
                        return this.k.set(e, r),
                        r
                    }
                    ,
                    t
                }(j)
                  , q = function() {
                    return !window.history.pushState
                }
                  , Y = function(e) {
                    return !e.el || !e.href
                }
                  , $ = function(e) {
                    var t = e.event;
                    return t.which > 1 || t.metaKey || t.ctrlKey || t.shiftKey || t.altKey
                }
                  , K = function(e) {
                    var t = e.el;
                    return t.hasAttribute("target") && "_blank" === t.target
                }
                  , Z = function(e) {
                    var t = e.el;
                    return void 0 !== t.protocol && window.location.protocol !== t.protocol || void 0 !== t.hostname && window.location.hostname !== t.hostname
                }
                  , J = function(e) {
                    var t = e.el;
                    return void 0 !== t.port && U() !== U(t.href)
                }
                  , Q = function(e) {
                    var t = e.el;
                    return t.getAttribute && "string" == typeof t.getAttribute("download")
                }
                  , ee = function(e) {
                    return e.el.hasAttribute(P.prefix + "-" + P.prevent)
                }
                  , te = function(e) {
                    return Boolean(e.el.closest("[" + P.prefix + "-" + P.prevent + '="all"]'))
                }
                  , ne = function(e) {
                    var t = e.href;
                    return z(t) === z() && U(t) === U()
                }
                  , re = function(e) {
                    function t(t) {
                        var n;
                        return (n = e.call(this, t) || this).suite = [],
                        n.tests = new Map,
                        n.init(),
                        n
                    }
                    r(t, e);
                    var n = t.prototype;
                    return n.init = function() {
                        this.add("pushState", q),
                        this.add("exists", Y),
                        this.add("newTab", $),
                        this.add("blank", K),
                        this.add("corsDomain", Z),
                        this.add("corsPort", J),
                        this.add("download", Q),
                        this.add("preventSelf", ee),
                        this.add("preventAll", te),
                        this.add("sameUrl", ne, !1)
                    }
                    ,
                    n.add = function(e, t, n) {
                        void 0 === n && (n = !0),
                        this.tests.set(e, t),
                        n && this.suite.push(e)
                    }
                    ,
                    n.run = function(e, t, n, r) {
                        return this.tests.get(e)({
                            el: t,
                            event: n,
                            href: r
                        })
                    }
                    ,
                    n.checkLink = function(e, t, n) {
                        var r = this;
                        return this.suite.some((function(i) {
                            return r.run(i, e, t, n)
                        }
                        ))
                    }
                    ,
                    t
                }(j)
                  , ie = function(e) {
                    function t(n, r) {
                        var i;
                        void 0 === r && (r = "Barba error");
                        for (var a = arguments.length, s = new Array(a > 2 ? a - 2 : 0), o = 2; o < a; o++)
                            s[o - 2] = arguments[o];
                        return (i = e.call.apply(e, [this].concat(s)) || this).error = n,
                        i.label = r,
                        Error.captureStackTrace && Error.captureStackTrace(function(e) {
                            if (void 0 === e)
                                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                            return e
                        }(i), t),
                        i.name = "BarbaError",
                        i
                    }
                    return r(t, e),
                    t
                }(o(Error))
                  , ae = function() {
                    function e(e) {
                        void 0 === e && (e = []),
                        this.logger = new p("@barba/core"),
                        this.all = [],
                        this.page = [],
                        this.once = [],
                        this.A = [{
                            name: "namespace",
                            type: "strings"
                        }, {
                            name: "custom",
                            type: "function"
                        }],
                        e && (this.all = this.all.concat(e)),
                        this.update()
                    }
                    var t = e.prototype;
                    return t.add = function(e, t) {
                        "rule" === e ? this.A.splice(t.position || 0, 0, t.value) : this.all.push(t),
                        this.update()
                    }
                    ,
                    t.resolve = function(e, t) {
                        var n = this;
                        void 0 === t && (t = {});
                        var r = t.once ? this.once : this.page;
                        r = r.filter(t.self ? function(e) {
                            return e.name && "self" === e.name
                        }
                        : function(e) {
                            return !e.name || "self" !== e.name
                        }
                        );
                        var i = new Map
                          , a = r.find((function(r) {
                            var a = !0
                              , s = {};
                            return !(!t.self || "self" !== r.name) || (n.A.reverse().forEach((function(t) {
                                a && (a = n.R(r, t, e, s),
                                r.from && r.to && (a = n.R(r, t, e, s, "from") && n.R(r, t, e, s, "to")),
                                r.from && !r.to && (a = n.R(r, t, e, s, "from")),
                                !r.from && r.to && (a = n.R(r, t, e, s, "to")))
                            }
                            )),
                            i.set(r, s),
                            a)
                        }
                        ))
                          , s = i.get(a)
                          , o = [];
                        if (o.push(t.once ? "once" : "page"),
                        t.self && o.push("self"),
                        s) {
                            var l, c = [a];
                            Object.keys(s).length > 0 && c.push(s),
                            (l = this.logger).info.apply(l, ["Transition found [" + o.join(",") + "]"].concat(c))
                        } else
                            this.logger.info("No transition found [" + o.join(",") + "]");
                        return a
                    }
                    ,
                    t.update = function() {
                        var e = this;
                        this.all = this.all.map((function(t) {
                            return e.T(t)
                        }
                        )).sort((function(e, t) {
                            return e.priority - t.priority
                        }
                        )).reverse().map((function(e) {
                            return delete e.priority,
                            e
                        }
                        )),
                        this.page = this.all.filter((function(e) {
                            return void 0 !== e.leave || void 0 !== e.enter
                        }
                        )),
                        this.once = this.all.filter((function(e) {
                            return void 0 !== e.once
                        }
                        ))
                    }
                    ,
                    t.R = function(e, t, n, r, i) {
                        var a = !0
                          , s = !1
                          , o = e
                          , l = t.name
                          , c = l
                          , u = l
                          , d = l
                          , h = i ? o[i] : o
                          , p = "to" === i ? n.next : n.current;
                        if (i ? h && h[l] : h[l]) {
                            switch (t.type) {
                            case "strings":
                            default:
                                var f = Array.isArray(h[c]) ? h[c] : [h[c]];
                                p[c] && -1 !== f.indexOf(p[c]) && (s = !0),
                                -1 === f.indexOf(p[c]) && (a = !1);
                                break;
                            case "object":
                                var m = Array.isArray(h[u]) ? h[u] : [h[u]];
                                p[u] ? (p[u].name && -1 !== m.indexOf(p[u].name) && (s = !0),
                                -1 === m.indexOf(p[u].name) && (a = !1)) : a = !1;
                                break;
                            case "function":
                                h[d](n) ? s = !0 : a = !1
                            }
                            s && (i ? (r[i] = r[i] || {},
                            r[i][l] = o[i][l]) : r[l] = o[l])
                        }
                        return a
                    }
                    ,
                    t.O = function(e, t, n) {
                        var r = 0;
                        return (e[t] || e.from && e.from[t] || e.to && e.to[t]) && (r += Math.pow(10, n),
                        e.from && e.from[t] && (r += 1),
                        e.to && e.to[t] && (r += 2)),
                        r
                    }
                    ,
                    t.T = function(e) {
                        var t = this;
                        e.priority = 0;
                        var n = 0;
                        return this.A.forEach((function(r, i) {
                            n += t.O(e, r.name, i + 1)
                        }
                        )),
                        e.priority = n,
                        e
                    }
                    ,
                    e
                }()
                  , se = function() {
                    function e(e) {
                        void 0 === e && (e = []),
                        this.logger = new p("@barba/core"),
                        this.S = !1,
                        this.store = new ae(e)
                    }
                    var n = e.prototype;
                    return n.get = function(e, t) {
                        return this.store.resolve(e, t)
                    }
                    ,
                    n.doOnce = function(e) {
                        var t = e.data
                          , n = e.transition;
                        try {
                            var r = function() {
                                i.S = !1
                            }
                              , i = this
                              , a = n || {};
                            i.S = !0;
                            var s = l((function() {
                                return Promise.resolve(i.j("beforeOnce", t, a)).then((function() {
                                    return Promise.resolve(i.once(t, a)).then((function() {
                                        return Promise.resolve(i.j("afterOnce", t, a)).then((function() {}
                                        ))
                                    }
                                    ))
                                }
                                ))
                            }
                            ), (function(e) {
                                i.S = !1,
                                i.logger.debug("Transition error [before/after/once]"),
                                i.logger.error(e)
                            }
                            ));
                            return Promise.resolve(s && s.then ? s.then(r) : r())
                        } catch (e) {
                            return Promise.reject(e)
                        }
                    }
                    ,
                    n.doPage = function(e) {
                        var t = e.data
                          , n = e.transition
                          , r = e.page
                          , i = e.wrapper;
                        try {
                            var a = function(e) {
                                if (s)
                                    return e;
                                o.S = !1
                            }
                              , s = !1
                              , o = this
                              , c = n || {}
                              , u = !0 === c.sync || !1;
                            o.S = !0;
                            var d = l((function() {
                                function e() {
                                    return Promise.resolve(o.j("before", t, c)).then((function() {
                                        var e = !1;
                                        function n(n) {
                                            return e ? n : Promise.resolve(o.remove(t)).then((function() {
                                                return Promise.resolve(o.j("after", t, c)).then((function() {}
                                                ))
                                            }
                                            ))
                                        }
                                        var a = function() {
                                            if (u)
                                                return l((function() {
                                                    return Promise.resolve(o.add(t, i)).then((function() {
                                                        return Promise.resolve(o.j("beforeLeave", t, c)).then((function() {
                                                            return Promise.resolve(o.j("beforeEnter", t, c)).then((function() {
                                                                return Promise.resolve(Promise.all([o.leave(t, c), o.enter(t, c)])).then((function() {
                                                                    return Promise.resolve(o.j("afterLeave", t, c)).then((function() {
                                                                        return Promise.resolve(o.j("afterEnter", t, c)).then((function() {}
                                                                        ))
                                                                    }
                                                                    ))
                                                                }
                                                                ))
                                                            }
                                                            ))
                                                        }
                                                        ))
                                                    }
                                                    ))
                                                }
                                                ), (function(e) {
                                                    if (o.M(e))
                                                        throw new ie(e,"Transition error [sync]")
                                                }
                                                ));
                                            var n = function(n) {
                                                return e ? n : l((function() {
                                                    var e = function() {
                                                        if (!1 !== a)
                                                            return Promise.resolve(o.add(t, i)).then((function() {
                                                                return Promise.resolve(o.j("beforeEnter", t, c)).then((function() {
                                                                    return Promise.resolve(o.enter(t, c, a)).then((function() {
                                                                        return Promise.resolve(o.j("afterEnter", t, c)).then((function() {}
                                                                        ))
                                                                    }
                                                                    ))
                                                                }
                                                                ))
                                                            }
                                                            ))
                                                    }();
                                                    if (e && e.then)
                                                        return e.then((function() {}
                                                        ))
                                                }
                                                ), (function(e) {
                                                    if (o.M(e))
                                                        throw new ie(e,"Transition error [before/after/enter]")
                                                }
                                                ))
                                            }
                                              , a = !1
                                              , s = l((function() {
                                                return Promise.resolve(o.j("beforeLeave", t, c)).then((function() {
                                                    return Promise.resolve(Promise.all([o.leave(t, c), O(r, t)]).then((function(e) {
                                                        return e[0]
                                                    }
                                                    ))).then((function(e) {
                                                        return a = e,
                                                        Promise.resolve(o.j("afterLeave", t, c)).then((function() {}
                                                        ))
                                                    }
                                                    ))
                                                }
                                                ))
                                            }
                                            ), (function(e) {
                                                if (o.M(e))
                                                    throw new ie(e,"Transition error [before/after/leave]")
                                            }
                                            ));
                                            return s && s.then ? s.then(n) : n(s)
                                        }();
                                        return a && a.then ? a.then(n) : n(a)
                                    }
                                    ))
                                }
                                var n = function() {
                                    if (u)
                                        return Promise.resolve(O(r, t)).then((function() {}
                                        ))
                                }();
                                return n && n.then ? n.then(e) : e()
                            }
                            ), (function(e) {
                                if (o.S = !1,
                                e.name && "BarbaError" === e.name)
                                    throw o.logger.debug(e.label),
                                    o.logger.error(e.error),
                                    e;
                                throw o.logger.debug("Transition error [page]"),
                                o.logger.error(e),
                                e
                            }
                            ));
                            return Promise.resolve(d && d.then ? d.then(a) : a(d))
                        } catch (e) {
                            return Promise.reject(e)
                        }
                    }
                    ,
                    n.once = function(e, t) {
                        try {
                            return Promise.resolve(W.do("once", e, t)).then((function() {
                                return t.once ? V(t.once, t)(e) : Promise.resolve()
                            }
                            ))
                        } catch (e) {
                            return Promise.reject(e)
                        }
                    }
                    ,
                    n.leave = function(e, t) {
                        try {
                            return Promise.resolve(W.do("leave", e, t)).then((function() {
                                return t.leave ? V(t.leave, t)(e) : Promise.resolve()
                            }
                            ))
                        } catch (e) {
                            return Promise.reject(e)
                        }
                    }
                    ,
                    n.enter = function(e, t, n) {
                        try {
                            return Promise.resolve(W.do("enter", e, t)).then((function() {
                                return t.enter ? V(t.enter, t)(e, n) : Promise.resolve()
                            }
                            ))
                        } catch (e) {
                            return Promise.reject(e)
                        }
                    }
                    ,
                    n.add = function(e, t) {
                        try {
                            return R.addContainer(e.next.container, t),
                            W.do("nextAdded", e),
                            Promise.resolve()
                        } catch (e) {
                            return Promise.reject(e)
                        }
                    }
                    ,
                    n.remove = function(e) {
                        try {
                            return R.removeContainer(e.current.container),
                            W.do("currentRemoved", e),
                            Promise.resolve()
                        } catch (e) {
                            return Promise.reject(e)
                        }
                    }
                    ,
                    n.M = function(e) {
                        return e.message ? !/Timeout error|Fetch error/.test(e.message) : !e.status
                    }
                    ,
                    n.j = function(e, t, n) {
                        try {
                            return Promise.resolve(W.do(e, t, n)).then((function() {
                                return n[e] ? V(n[e], n)(t) : Promise.resolve()
                            }
                            ))
                        } catch (e) {
                            return Promise.reject(e)
                        }
                    }
                    ,
                    t(e, [{
                        key: "isRunning",
                        get: function() {
                            return this.S
                        },
                        set: function(e) {
                            this.S = e
                        }
                    }, {
                        key: "hasOnce",
                        get: function() {
                            return this.store.once.length > 0
                        }
                    }, {
                        key: "hasSelf",
                        get: function() {
                            return this.store.all.some((function(e) {
                                return "self" === e.name
                            }
                            ))
                        }
                    }, {
                        key: "shouldWait",
                        get: function() {
                            return this.store.all.some((function(e) {
                                return e.to && !e.to.route || e.sync
                            }
                            ))
                        }
                    }]),
                    e
                }()
                  , oe = function() {
                    function e(e) {
                        var t = this;
                        this.names = ["beforeLeave", "afterLeave", "beforeEnter", "afterEnter"],
                        this.byNamespace = new Map,
                        0 !== e.length && (e.forEach((function(e) {
                            t.byNamespace.set(e.namespace, e)
                        }
                        )),
                        this.names.forEach((function(e) {
                            W[e](t.L(e))
                        }
                        )))
                    }
                    return e.prototype.L = function(e) {
                        var t = this;
                        return function(n) {
                            var r = e.match(/enter/i) ? n.next : n.current
                              , i = t.byNamespace.get(r.namespace);
                            return i && i[e] ? V(i[e], i)(n) : Promise.resolve()
                        }
                    }
                    ,
                    e
                }();
                Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector),
                Element.prototype.closest || (Element.prototype.closest = function(e) {
                    var t = this;
                    do {
                        if (t.matches(e))
                            return t;
                        t = t.parentElement || t.parentNode
                    } while (null !== t && 1 === t.nodeType);
                    return null
                }
                );
                var le = {
                    container: null,
                    html: "",
                    namespace: "",
                    url: {
                        hash: "",
                        href: "",
                        path: "",
                        port: null,
                        query: {}
                    }
                };
                return new (function() {
                    function e() {
                        this.version = u,
                        this.schemaPage = le,
                        this.Logger = p,
                        this.logger = new p("@barba/core"),
                        this.plugins = [],
                        this.hooks = W,
                        this.dom = R,
                        this.helpers = I,
                        this.history = L,
                        this.request = H,
                        this.url = B
                    }
                    var r = e.prototype;
                    return r.use = function(e, t) {
                        var n = this.plugins;
                        n.indexOf(e) > -1 ? this.logger.warn("Plugin [" + e.name + "] already installed.") : "function" == typeof e.install ? (e.install(this, t),
                        n.push(e)) : this.logger.warn("Plugin [" + e.name + '] has no "install" method.')
                    }
                    ,
                    r.init = function(e) {
                        var t = void 0 === e ? {} : e
                          , r = t.transitions
                          , i = void 0 === r ? [] : r
                          , a = t.views
                          , s = void 0 === a ? [] : a
                          , o = t.schema
                          , l = void 0 === o ? P : o
                          , c = t.requestError
                          , u = t.timeout
                          , d = void 0 === u ? 2e3 : u
                          , h = t.cacheIgnore
                          , f = void 0 !== h && h
                          , m = t.prefetchIgnore
                          , g = void 0 !== m && m
                          , v = t.preventRunning
                          , _ = void 0 !== v && v
                          , y = t.prevent
                          , x = void 0 === y ? null : y
                          , b = t.debug
                          , E = t.logLevel;
                        if (p.setLevel(!0 === (void 0 !== b && b) ? "debug" : void 0 === E ? "off" : E),
                        this.logger.info(this.version),
                        Object.keys(l).forEach((function(e) {
                            P[e] && (P[e] = l[e])
                        }
                        )),
                        this.$ = c,
                        this.timeout = d,
                        this.cacheIgnore = f,
                        this.prefetchIgnore = g,
                        this.preventRunning = _,
                        this._ = this.dom.getWrapper(),
                        !this._)
                            throw new Error("[@barba/core] No Barba wrapper found");
                        this._.setAttribute("aria-live", "polite"),
                        this.q();
                        var S = this.data.current;
                        if (!S.container)
                            throw new Error("[@barba/core] No Barba container found");
                        if (this.cache = new X(f),
                        this.prevent = new re(g),
                        this.transitions = new se(i),
                        this.views = new oe(s),
                        null !== x) {
                            if ("function" != typeof x)
                                throw new Error("[@barba/core] Prevent should be a function");
                            this.prevent.add("preventCustom", x)
                        }
                        this.history.init(S.url.href, S.namespace),
                        this.B = this.B.bind(this),
                        this.U = this.U.bind(this),
                        this.D = this.D.bind(this),
                        this.F(),
                        this.plugins.forEach((function(e) {
                            return e.init()
                        }
                        ));
                        var w = this.data;
                        w.trigger = "barba",
                        w.next = w.current,
                        w.current = n({}, this.schemaPage),
                        this.hooks.do("ready", w),
                        this.once(w),
                        this.q()
                    }
                    ,
                    r.destroy = function() {
                        this.q(),
                        this.H(),
                        this.history.clear(),
                        this.hooks.clear(),
                        this.plugins = []
                    }
                    ,
                    r.force = function(e) {
                        window.location.assign(e)
                    }
                    ,
                    r.go = function(e, t, n) {
                        var r;
                        if (void 0 === t && (t = "barba"),
                        this.transitions.isRunning)
                            this.force(e);
                        else if (!(r = "popstate" === t ? this.history.current && this.url.getPath(this.history.current.url) === this.url.getPath(e) : this.prevent.run("sameUrl", null, null, e)) || this.transitions.hasSelf)
                            return t = this.history.change(e, t, n),
                            n && (n.stopPropagation(),
                            n.preventDefault()),
                            this.page(e, t, r)
                    }
                    ,
                    r.once = function(e) {
                        try {
                            var t = this;
                            return Promise.resolve(t.hooks.do("beforeEnter", e)).then((function() {
                                function n() {
                                    return Promise.resolve(t.hooks.do("afterEnter", e)).then((function() {}
                                    ))
                                }
                                var r = function() {
                                    if (t.transitions.hasOnce) {
                                        var n = t.transitions.get(e, {
                                            once: !0
                                        });
                                        return Promise.resolve(t.transitions.doOnce({
                                            transition: n,
                                            data: e
                                        })).then((function() {}
                                        ))
                                    }
                                }();
                                return r && r.then ? r.then(n) : n()
                            }
                            ))
                        } catch (e) {
                            return Promise.reject(e)
                        }
                    }
                    ,
                    r.page = function(e, t, r) {
                        try {
                            var i = function() {
                                var e = a.data;
                                return Promise.resolve(a.hooks.do("page", e)).then((function() {
                                    var t = l((function() {
                                        var t = a.transitions.get(e, {
                                            once: !1,
                                            self: r
                                        });
                                        return Promise.resolve(a.transitions.doPage({
                                            data: e,
                                            page: s,
                                            transition: t,
                                            wrapper: a._
                                        })).then((function() {
                                            a.q()
                                        }
                                        ))
                                    }
                                    ), (function() {
                                        0 === p.getLevel() && a.force(e.current.url.href)
                                    }
                                    ));
                                    if (t && t.then)
                                        return t.then((function() {}
                                        ))
                                }
                                ))
                            }
                              , a = this;
                            a.data.next.url = n({
                                href: e
                            }, a.url.parse(e)),
                            a.data.trigger = t;
                            var s = a.cache.has(e) ? a.cache.update(e, {
                                action: "click"
                            }).request : a.cache.set(e, a.request(e, a.timeout, a.onRequestError.bind(a, t)), "click").request
                              , o = function() {
                                if (a.transitions.shouldWait)
                                    return Promise.resolve(O(s, a.data)).then((function() {}
                                    ))
                            }();
                            return Promise.resolve(o && o.then ? o.then(i) : i())
                        } catch (e) {
                            return Promise.reject(e)
                        }
                    }
                    ,
                    r.onRequestError = function(e) {
                        this.transitions.isRunning = !1;
                        for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
                            n[r - 1] = arguments[r];
                        var i = n[0]
                          , a = n[1]
                          , s = this.cache.getAction(i);
                        return this.cache.delete(i),
                        !(this.$ && !1 === this.$(e, s, i, a) || ("click" === s && this.force(i),
                        1))
                    }
                    ,
                    r.prefetch = function(e) {
                        var t = this;
                        this.cache.has(e) || this.cache.set(e, this.request(e, this.timeout, this.onRequestError.bind(this, "barba")).catch((function(e) {
                            t.logger.error(e)
                        }
                        )), "prefetch")
                    }
                    ,
                    r.F = function() {
                        !0 !== this.prefetchIgnore && (document.addEventListener("mouseover", this.B),
                        document.addEventListener("touchstart", this.B)),
                        document.addEventListener("click", this.U),
                        window.addEventListener("popstate", this.D)
                    }
                    ,
                    r.H = function() {
                        !0 !== this.prefetchIgnore && (document.removeEventListener("mouseover", this.B),
                        document.removeEventListener("touchstart", this.B)),
                        document.removeEventListener("click", this.U),
                        window.removeEventListener("popstate", this.D)
                    }
                    ,
                    r.B = function(e) {
                        var t = this
                          , n = this.I(e);
                        if (n) {
                            var r = this.dom.getHref(n);
                            this.prevent.checkHref(r) || this.cache.has(r) || this.cache.set(r, this.request(r, this.timeout, this.onRequestError.bind(this, n)).catch((function(e) {
                                t.logger.error(e)
                            }
                            )), "enter")
                        }
                    }
                    ,
                    r.U = function(e) {
                        var t = this.I(e);
                        if (t)
                            return this.transitions.isRunning && this.preventRunning ? (e.preventDefault(),
                            void e.stopPropagation()) : void this.go(this.dom.getHref(t), t, e)
                    }
                    ,
                    r.D = function(e) {
                        this.go(this.url.getHref(), "popstate", e)
                    }
                    ,
                    r.I = function(e) {
                        for (var t = e.target; t && !this.dom.getHref(t); )
                            t = t.parentNode;
                        if (t && !this.prevent.checkLink(t, e, this.dom.getHref(t)))
                            return t
                    }
                    ,
                    r.q = function() {
                        var e = this.url.getHref()
                          , t = {
                            container: this.dom.getContainer(),
                            html: this.dom.getHtml(),
                            namespace: this.dom.getNamespace(),
                            url: n({
                                href: e
                            }, this.url.parse(e))
                        };
                        this.C = {
                            current: t,
                            next: n({}, this.schemaPage),
                            trigger: void 0
                        },
                        this.hooks.do("reset", this.data)
                    }
                    ,
                    t(e, [{
                        key: "data",
                        get: function() {
                            return this.C
                        }
                    }, {
                        key: "wrapper",
                        get: function() {
                            return this._
                        }
                    }]),
                    e
                }())
            }()
        },
        897: function(e, t, n) {
            "use strict";
            var r = {};
            function i(e) {
                return i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                }
                : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }
                ,
                i(e)
            }
            function a(e, t) {
                if (!(e instanceof t))
                    throw new TypeError("Cannot call a class as a function")
            }
            function s(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1,
                    r.configurable = !0,
                    "value"in r && (r.writable = !0),
                    Object.defineProperty(e, r.key, r)
                }
            }
            function o(e, t, n) {
                return t && s(e.prototype, t),
                n && s(e, n),
                e
            }
            function l(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n,
                e
            }
            function c(e, t) {
                return function(e) {
                    if (Array.isArray(e))
                        return e
                }(e) || function(e, t) {
                    if ("undefined" == typeof Symbol || !(Symbol.iterator in Object(e)))
                        return;
                    var n = []
                      , r = !0
                      , i = !1
                      , a = void 0;
                    try {
                        for (var s, o = e[Symbol.iterator](); !(r = (s = o.next()).done) && (n.push(s.value),
                        !t || n.length !== t); r = !0)
                            ;
                    } catch (e) {
                        i = !0,
                        a = e
                    } finally {
                        try {
                            r || null == o.return || o.return()
                        } finally {
                            if (i)
                                throw a
                        }
                    }
                    return n
                }(e, t) || d(e, t) || function() {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()
            }
            function u(e) {
                return function(e) {
                    if (Array.isArray(e))
                        return h(e)
                }(e) || function(e) {
                    if ("undefined" != typeof Symbol && Symbol.iterator in Object(e))
                        return Array.from(e)
                }(e) || d(e) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()
            }
            function d(e, t) {
                if (e) {
                    if ("string" == typeof e)
                        return h(e, t);
                    var n = Object.prototype.toString.call(e).slice(8, -1);
                    return "Object" === n && e.constructor && (n = e.constructor.name),
                    "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? h(e, t) : void 0
                }
            }
            function h(e, t) {
                (null == t || t > e.length) && (t = e.length);
                for (var n = 0, r = new Array(t); n < t; n++)
                    r[n] = e[n];
                return r
            }
            n.r(r),
            n.d(r, {
                CloseVideo: function() {
                    return P
                },
                Cursor: function() {
                    return Li
                },
                Load: function() {
                    return Vi
                },
                Magnetic: function() {
                    return Zi
                },
                Navigation: function() {
                    return oa
                },
                ParticleTextRotator: function() {
                    return am
                },
                Particles: function() {
                    return Vf
                },
                ParticlesAggregator: function() {
                    return Zf
                },
                PlayVideo: function() {
                    return pm
                },
                Scroll: function() {
                    return ny
                },
                Slideshow: function() {
                    return Ax
                }
            });
            var p = function() {
                function e(t) {
                    a(this, e),
                    this.mAttr = "data-" + t.dataName,
                    this.mCaptureEvents = ["mouseenter", "mouseleave"],
                    this.el = t.el
                }
                return o(e, [{
                    key: "mInit",
                    value: function(e) {
                        var t = this;
                        this.modules = e,
                        this.mCheckEventTarget = this.mCheckEventTarget.bind(this),
                        this.events && Object.keys(this.events).forEach((function(e) {
                            return t.mAddEvent(e)
                        }
                        ))
                    }
                }, {
                    key: "mUpdate",
                    value: function(e) {
                        this.modules = e
                    }
                }, {
                    key: "mDestroy",
                    value: function() {
                        var e = this;
                        this.events && Object.keys(this.events).forEach((function(t) {
                            return e.mRemoveEvent(t)
                        }
                        ))
                    }
                }, {
                    key: "mAddEvent",
                    value: function(e) {
                        var t = !!this.mCaptureEvents.includes(e);
                        this.el.addEventListener(e, this.mCheckEventTarget, t)
                    }
                }, {
                    key: "mRemoveEvent",
                    value: function(e) {
                        var t = !!this.mCaptureEvents.includes(e);
                        this.el.removeEventListener(e, this.mCheckEventTarget, t)
                    }
                }, {
                    key: "mCheckEventTarget",
                    value: function(e) {
                        var t = this.events[e.type];
                        if ("string" == typeof t)
                            this[t](e);
                        else {
                            var n = "[" + this.mAttr + "]"
                              , r = e.target;
                            if (this.mCaptureEvents.includes(e.type))
                                r.matches(n) && this.mCallEventMethod(e, t, r);
                            else
                                for (; r && r !== document && (!r.matches(n) || "undefined" == this.mCallEventMethod(e, t, r)); )
                                    r = r.parentNode
                        }
                    }
                }, {
                    key: "mCallEventMethod",
                    value: function(e, t, n) {
                        var r = n.getAttribute(this.mAttr);
                        if (t.hasOwnProperty(r)) {
                            var i = t[r];
                            e.hasOwnProperty("currentTarget") || Object.defineProperty(e, "currentTarget", {
                                value: n
                            }),
                            e.hasOwnProperty("curTarget") || Object.defineProperty(e, "curTarget", {
                                value: n
                            }),
                            this[i](e)
                        }
                    }
                }, {
                    key: "$",
                    value: function(e, t) {
                        var n = [e.indexOf("."), e.indexOf("#"), e.indexOf("[")].filter((function(e) {
                            return -1 != e
                        }
                        ))
                          , r = !1
                          , a = e
                          , s = ""
                          , o = this.el;
                        return n.length && (r = Math.min.apply(Math, u(n)),
                        a = e.slice(0, r),
                        s = e.slice(r)),
                        "object" == i(t) && (o = t),
                        o.querySelectorAll("[" + this.mAttr + "=" + a + "]" + s)
                    }
                }, {
                    key: "parent",
                    value: function(e, t) {
                        for (var n = "[" + this.mAttr + "=" + e + "]", r = t.parentNode; r && r !== document; ) {
                            if (r.matches(n))
                                return r;
                            r = r.parentNode
                        }
                    }
                }, {
                    key: "getData",
                    value: function(e, t) {
                        return (t || this.el).getAttribute(this.mAttr + "-" + e)
                    }
                }, {
                    key: "setData",
                    value: function(e, t, n) {
                        return (n || this.el).setAttribute(this.mAttr + "-" + e, t)
                    }
                }, {
                    key: "call",
                    value: function(e, t, n, r) {
                        var i = this;
                        t && !n && (n = t,
                        t = !1),
                        this.modules[n] && (r ? this.modules[n][r] && this.modules[n][r][e](t) : Object.keys(this.modules[n]).forEach((function(r) {
                            i.modules[n][r][e](t)
                        }
                        )))
                    }
                }, {
                    key: "on",
                    value: function(e, t, n, r) {
                        var i = this;
                        this.modules[t] && (r ? this.modules[t][r].el.addEventListener(e, (function(e) {
                            return n(e)
                        }
                        )) : Object.keys(this.modules[t]).forEach((function(r) {
                            i.modules[t][r].el.addEventListener(e, (function(e) {
                                return n(e)
                            }
                            ))
                        }
                        )))
                    }
                }, {
                    key: "init",
                    value: function() {}
                }, {
                    key: "destroy",
                    value: function() {}
                }]),
                e
            }()
              , f = function() {
                function e(t) {
                    a(this, e),
                    this.app,
                    this.modules = t.modules,
                    this.currentModules = {},
                    this.activeModules = {},
                    this.newModules = {},
                    this.moduleId = 0
                }
                return o(e, [{
                    key: "init",
                    value: function(e, t) {
                        var n = this
                          , r = (t || document).querySelectorAll("*");
                        e && !this.app && (this.app = e),
                        this.activeModules.app = {
                            app: this.app
                        },
                        r.forEach((function(e) {
                            Array.from(e.attributes).forEach((function(r) {
                                if (r.name.startsWith("data-module")) {
                                    var i = !1
                                      , a = r.name.split("-").splice(2)
                                      , s = n.toCamel(a);
                                    if (n.modules[s] ? i = !0 : n.modules[n.toUpper(s)] && (s = n.toUpper(s),
                                    i = !0),
                                    i) {
                                        var o = {
                                            el: e,
                                            name: s,
                                            dataName: a.join("-")
                                        }
                                          , l = new n.modules[s](o)
                                          , c = r.value;
                                        c || (n.moduleId++,
                                        c = "m" + n.moduleId,
                                        e.setAttribute(r.name, c)),
                                        n.addActiveModule(s, c, l);
                                        var u = s + "-" + c;
                                        t ? n.newModules[u] = l : n.currentModules[u] = l
                                    }
                                }
                            }
                            ))
                        }
                        )),
                        Object.entries(this.currentModules).forEach((function(e) {
                            var r = c(e, 2)
                              , i = r[0]
                              , a = r[1];
                            if (t) {
                                var s = i.split("-")
                                  , o = s.shift()
                                  , l = s.pop();
                                n.addActiveModule(o, l, a)
                            } else
                                n.initModule(a)
                        }
                        ))
                    }
                }, {
                    key: "initModule",
                    value: function(e) {
                        e.mInit(this.activeModules),
                        e.init()
                    }
                }, {
                    key: "addActiveModule",
                    value: function(e, t, n) {
                        this.activeModules[e] ? Object.assign(this.activeModules[e], l({}, t, n)) : this.activeModules[e] = l({}, t, n)
                    }
                }, {
                    key: "update",
                    value: function(e) {
                        var t = this;
                        this.init(this.app, e),
                        Object.entries(this.currentModules).forEach((function(e) {
                            var n = c(e, 2);
                            n[0];
                            n[1].mUpdate(t.activeModules)
                        }
                        )),
                        Object.entries(this.newModules).forEach((function(e) {
                            var n = c(e, 2)
                              , r = (n[0],
                            n[1]);
                            t.initModule(r)
                        }
                        )),
                        Object.assign(this.currentModules, this.newModules)
                    }
                }, {
                    key: "destroy",
                    value: function(e) {
                        e ? this.destroyScope(e) : this.destroyModules()
                    }
                }, {
                    key: "destroyScope",
                    value: function(e) {
                        var t = this;
                        e.querySelectorAll("*").forEach((function(e) {
                            Array.from(e.attributes).forEach((function(e) {
                                if (e.name.startsWith("data-module")) {
                                    var n = e.value
                                      , r = e.name.split("-").splice(2)
                                      , i = t.toCamel(r) + "-" + n
                                      , a = !1;
                                    t.currentModules[i] ? a = !0 : t.currentModules[t.toUpper(i)] && (i = t.toUpper(i),
                                    a = !0),
                                    a && (t.destroyModule(t.currentModules[i]),
                                    delete t.currentModules[i])
                                }
                            }
                            ))
                        }
                        )),
                        this.activeModules = {},
                        this.newModules = {}
                    }
                }, {
                    key: "destroyModules",
                    value: function() {
                        var e = this;
                        Object.entries(this.currentModules).forEach((function(t) {
                            var n = c(t, 2)
                              , r = (n[0],
                            n[1]);
                            e.destroyModule(r)
                        }
                        )),
                        this.currentModules = []
                    }
                }, {
                    key: "destroyModule",
                    value: function(e) {
                        e.mDestroy(),
                        e.destroy()
                    }
                }, {
                    key: "toCamel",
                    value: function(e) {
                        var t = this;
                        return e.reduce((function(e, n) {
                            return e + t.toUpper(n)
                        }
                        ))
                    }
                }, {
                    key: "toUpper",
                    value: function(e) {
                        return e.charAt(0).toUpperCase() + e.slice(1)
                    }
                }]),
                e
            }()
              , m = f
              , g = document.documentElement
              , v = (document.body,
            "production")
              , _ = window.matchMedia("(any-pointer:coarse)").matches
              , y = Object.freeze({
                NAME: v,
                IS_PROD: !0,
                IS_DEV: !1,
                IS_MOBILE: _,
                IS_DESKTOP: !_,
                SUPPORTS_VH: "CSS"in window && "supports"in window.CSS && window.CSS.supports("height: 100svh") && window.CSS.supports("height: 100dvh") && window.CSS.supports("height: 100lvh"),
                IS_REDUCED_MOTION: !0 === window.matchMedia("(prefers-reduced-motion: reduce)") || !0 === window.matchMedia("(prefers-reduced-motion: reduce)").matches
            })
              , x = Object.freeze({
                INITIALIZING: "is-initializing",
                LOADING: "is-loading",
                LOADED: "is-loaded",
                READY: "is-ready",
                FONTS_LOADED: "fonts-loaded",
                LAZY_CONTAINER: "c-lazy",
                LAZY_LOADED: "-lazy-loaded",
                NAVIGATION_OPEN: "has-navigation-open",
                VIDEO_PLAYING: "has-video-playing",
                REDUCED_MOTION: "has-reduced-motion"
            })
              , b = Object.freeze({
                RESIZE_END: "loco.resizeEnd"
            });
            Object.freeze({
                EAGER: [{
                    family: "Source Sans",
                    style: "normal",
                    weight: 400
                }, {
                    family: "Source Sans",
                    style: "normal",
                    weight: 700
                }]
            });
            function E(e) {
                return E = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                }
                : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }
                ,
                E(e)
            }
            function S(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1,
                    r.configurable = !0,
                    "value"in r && (r.writable = !0),
                    Object.defineProperty(e, w(r.key), r)
                }
            }
            function w(e) {
                var t = function(e, t) {
                    if ("object" != E(e) || !e)
                        return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var r = n.call(e, t || "default");
                        if ("object" != E(r))
                            return r;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return ("string" === t ? String : Number)(e)
                }(e, "string");
                return "symbol" == E(t) ? t : String(t)
            }
            function M(e, t, n) {
                return t = A(t),
                function(e, t) {
                    if (t && ("object" === E(t) || "function" == typeof t))
                        return t;
                    if (void 0 !== t)
                        throw new TypeError("Derived constructors may only return object or undefined");
                    return function(e) {
                        if (void 0 === e)
                            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return e
                    }(e)
                }(e, T() ? Reflect.construct(t, n || [], A(e).constructor) : t.apply(e, n))
            }
            function T() {
                try {
                    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
                    )))
                } catch (e) {}
                return (T = function() {
                    return !!e
                }
                )()
            }
            function A(e) {
                return A = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                }
                ,
                A(e)
            }
            function C(e, t) {
                return C = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
                    return e.__proto__ = t,
                    e
                }
                ,
                C(e, t)
            }
            var P = function(e) {
                function t(e) {
                    var n;
                    return function(e, t) {
                        if (!(e instanceof t))
                            throw new TypeError("Cannot call a class as a function")
                    }(this, t),
                    (n = M(this, t, [e])).embedTarget = null,
                    n
                }
                var n, r, i;
                return function(e, t) {
                    if ("function" != typeof t && null !== t)
                        throw new TypeError("Super expression must either be null or a function");
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            writable: !0,
                            configurable: !0
                        }
                    }),
                    Object.defineProperty(e, "prototype", {
                        writable: !1
                    }),
                    t && C(e, t)
                }(t, e),
                n = t,
                (r = [{
                    key: "init",
                    value: function() {
                        var e = this;
                        this.embedTarget = g.querySelector("[data-module-video-embed]"),
                        this.el.addEventListener("click", (function(t) {
                            e.closeVideo(t)
                        }
                        )),
                        y.IS_DEV && console.log("Close Video: Initiated")
                    }
                }, {
                    key: "closeVideo",
                    value: function(e) {
                        var t = this;
                        e && e.preventDefault(),
                        g.classList.contains(x.VIDEO_PLAYING) && (window.setTimeout((function() {
                            t.embedTarget.innerHTML = ""
                        }
                        ), 600),
                        g.classList.remove(x.VIDEO_PLAYING),
                        this.call("pauseScroll", !1, "Scroll", "main"))
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        y.IS_DEV && console.log("Close Video: Destroyed")
                    }
                }]) && S(n.prototype, r),
                i && S(n, i),
                Object.defineProperty(n, "prototype", {
                    writable: !1
                }),
                t
            }(p);
            function R(e) {
                if (void 0 === e)
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return e
            }
            function L(e, t) {
                e.prototype = Object.create(t.prototype),
                e.prototype.constructor = e,
                e.__proto__ = t
            }
            var O, D, I, N, U, k, F, z, B, H, G, V, W, j, X, q = {
                autoSleep: 120,
                force3D: "auto",
                nullTargetWarn: 1,
                units: {
                    lineHeight: ""
                }
            }, Y = {
                duration: .5,
                overwrite: !1,
                delay: 0
            }, $ = 1e8, K = 1e-8, Z = 2 * Math.PI, J = Z / 4, Q = 0, ee = Math.sqrt, te = Math.cos, ne = Math.sin, re = function(e) {
                return "string" == typeof e
            }, ie = function(e) {
                return "function" == typeof e
            }, ae = function(e) {
                return "number" == typeof e
            }, se = function(e) {
                return void 0 === e
            }, oe = function(e) {
                return "object" == typeof e
            }, le = function(e) {
                return !1 !== e
            }, ce = function() {
                return "undefined" != typeof window
            }, ue = function(e) {
                return ie(e) || re(e)
            }, de = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function() {}
            , he = Array.isArray, pe = /(?:-?\.?\d|\.)+/gi, fe = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, me = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, ge = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, ve = /[+-]=-?[.\d]+/, _e = /[^,'"\[\]\s]+/gi, ye = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, xe = {}, be = {}, Ee = function(e) {
                return (be = Ze(e, xe)) && Qn
            }, Se = function(e, t) {
                return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()")
            }, we = function(e, t) {
                return !t && console.warn(e)
            }, Me = function(e, t) {
                return e && (xe[e] = t) && be && (be[e] = t) || xe
            }, Te = function() {
                return 0
            }, Ae = {
                suppressEvents: !0,
                isStart: !0,
                kill: !1
            }, Ce = {
                suppressEvents: !0,
                kill: !1
            }, Pe = {
                suppressEvents: !0
            }, Re = {}, Le = [], Oe = {}, De = {}, Ie = {}, Ne = 30, Ue = [], ke = "", Fe = function(e) {
                var t, n, r = e[0];
                if (oe(r) || ie(r) || (e = [e]),
                !(t = (r._gsap || {}).harness)) {
                    for (n = Ue.length; n-- && !Ue[n].targetTest(r); )
                        ;
                    t = Ue[n]
                }
                for (n = e.length; n--; )
                    e[n] && (e[n]._gsap || (e[n]._gsap = new pn(e[n],t))) || e.splice(n, 1);
                return e
            }, ze = function(e) {
                return e._gsap || Fe(Pt(e))[0]._gsap
            }, Be = function(e, t, n) {
                return (n = e[t]) && ie(n) ? e[t]() : se(n) && e.getAttribute && e.getAttribute(t) || n
            }, He = function(e, t) {
                return (e = e.split(",")).forEach(t) || e
            }, Ge = function(e) {
                return Math.round(1e5 * e) / 1e5 || 0
            }, Ve = function(e) {
                return Math.round(1e7 * e) / 1e7 || 0
            }, We = function(e, t) {
                var n = t.charAt(0)
                  , r = parseFloat(t.substr(2));
                return e = parseFloat(e),
                "+" === n ? e + r : "-" === n ? e - r : "*" === n ? e * r : e / r
            }, je = function(e, t) {
                for (var n = t.length, r = 0; e.indexOf(t[r]) < 0 && ++r < n; )
                    ;
                return r < n
            }, Xe = function() {
                var e, t, n = Le.length, r = Le.slice(0);
                for (Oe = {},
                Le.length = 0,
                e = 0; e < n; e++)
                    (t = r[e]) && t._lazy && (t.render(t._lazy[0], t._lazy[1], !0)._lazy = 0)
            }, qe = function(e, t, n, r) {
                Le.length && !D && Xe(),
                e.render(t, n, r || D && t < 0 && (e._initted || e._startAt)),
                Le.length && !D && Xe()
            }, Ye = function(e) {
                var t = parseFloat(e);
                return (t || 0 === t) && (e + "").match(_e).length < 2 ? t : re(e) ? e.trim() : e
            }, $e = function(e) {
                return e
            }, Ke = function(e, t) {
                for (var n in t)
                    n in e || (e[n] = t[n]);
                return e
            }, Ze = function(e, t) {
                for (var n in t)
                    e[n] = t[n];
                return e
            }, Je = function e(t, n) {
                for (var r in n)
                    "__proto__" !== r && "constructor" !== r && "prototype" !== r && (t[r] = oe(n[r]) ? e(t[r] || (t[r] = {}), n[r]) : n[r]);
                return t
            }, Qe = function(e, t) {
                var n, r = {};
                for (n in e)
                    n in t || (r[n] = e[n]);
                return r
            }, et = function(e) {
                var t, n = e.parent || N, r = e.keyframes ? (t = he(e.keyframes),
                function(e, n) {
                    for (var r in n)
                        r in e || "duration" === r && t || "ease" === r || (e[r] = n[r])
                }
                ) : Ke;
                if (le(e.inherit))
                    for (; n; )
                        r(e, n.vars.defaults),
                        n = n.parent || n._dp;
                return e
            }, tt = function(e, t, n, r, i) {
                void 0 === n && (n = "_first"),
                void 0 === r && (r = "_last");
                var a, s = e[r];
                if (i)
                    for (a = t[i]; s && s[i] > a; )
                        s = s._prev;
                return s ? (t._next = s._next,
                s._next = t) : (t._next = e[n],
                e[n] = t),
                t._next ? t._next._prev = t : e[r] = t,
                t._prev = s,
                t.parent = t._dp = e,
                t
            }, nt = function(e, t, n, r) {
                void 0 === n && (n = "_first"),
                void 0 === r && (r = "_last");
                var i = t._prev
                  , a = t._next;
                i ? i._next = a : e[n] === t && (e[n] = a),
                a ? a._prev = i : e[r] === t && (e[r] = i),
                t._next = t._prev = t.parent = null
            }, rt = function(e, t) {
                e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e),
                e._act = 0
            }, it = function(e, t) {
                if (e && (!t || t._end > e._dur || t._start < 0))
                    for (var n = e; n; )
                        n._dirty = 1,
                        n = n.parent;
                return e
            }, at = function(e, t, n, r) {
                return e._startAt && (D ? e._startAt.revert(Ce) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, r))
            }, st = function e(t) {
                return !t || t._ts && e(t.parent)
            }, ot = function(e) {
                return e._repeat ? lt(e._tTime, e = e.duration() + e._rDelay) * e : 0
            }, lt = function(e, t) {
                var n = Math.floor(e /= t);
                return e && n === e ? n - 1 : n
            }, ct = function(e, t) {
                return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
            }, ut = function(e) {
                return e._end = Ve(e._start + (e._tDur / Math.abs(e._ts || e._rts || K) || 0))
            }, dt = function(e, t) {
                var n = e._dp;
                return n && n.smoothChildTiming && e._ts && (e._start = Ve(n._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)),
                ut(e),
                n._dirty || it(n, e)),
                e
            }, ht = function(e, t) {
                var n;
                if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (n = ct(e.rawTime(), t),
                (!t._dur || wt(0, t.totalDuration(), n) - t._tTime > K) && t.render(n, !0)),
                it(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
                    if (e._dur < e.duration())
                        for (n = e; n._dp; )
                            n.rawTime() >= 0 && n.totalTime(n._tTime),
                            n = n._dp;
                    e._zTime = -1e-8
                }
            }, pt = function(e, t, n, r) {
                return t.parent && rt(t),
                t._start = Ve((ae(n) ? n : n || e !== N ? bt(e, n, t) : e._time) + t._delay),
                t._end = Ve(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)),
                tt(e, t, "_first", "_last", e._sort ? "_start" : 0),
                vt(t) || (e._recent = t),
                r || ht(e, t),
                e._ts < 0 && dt(e, e._tTime),
                e
            }, ft = function(e, t) {
                return (xe.ScrollTrigger || Se("scrollTrigger", t)) && xe.ScrollTrigger.create(t, e)
            }, mt = function(e, t, n, r, i) {
                return bn(e, t, i),
                e._initted ? !n && e._pt && !D && (e._dur && !1 !== e.vars.lazy || !e._dur && e.vars.lazy) && B !== Qt.frame ? (Le.push(e),
                e._lazy = [i, r],
                1) : void 0 : 1
            }, gt = function e(t) {
                var n = t.parent;
                return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || e(n))
            }, vt = function(e) {
                var t = e.data;
                return "isFromStart" === t || "isStart" === t
            }, _t = function(e, t, n, r) {
                var i = e._repeat
                  , a = Ve(t) || 0
                  , s = e._tTime / e._tDur;
                return s && !r && (e._time *= a / e._dur),
                e._dur = a,
                e._tDur = i ? i < 0 ? 1e10 : Ve(a * (i + 1) + e._rDelay * i) : a,
                s > 0 && !r && dt(e, e._tTime = e._tDur * s),
                e.parent && ut(e),
                n || it(e.parent, e),
                e
            }, yt = function(e) {
                return e instanceof mn ? it(e) : _t(e, e._dur)
            }, xt = {
                _start: 0,
                endTime: Te,
                totalDuration: Te
            }, bt = function e(t, n, r) {
                var i, a, s, o = t.labels, l = t._recent || xt, c = t.duration() >= $ ? l.endTime(!1) : t._dur;
                return re(n) && (isNaN(n) || n in o) ? (a = n.charAt(0),
                s = "%" === n.substr(-1),
                i = n.indexOf("="),
                "<" === a || ">" === a ? (i >= 0 && (n = n.replace(/=/, "")),
                ("<" === a ? l._start : l.endTime(l._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) * (s ? (i < 0 ? l : r).totalDuration() / 100 : 1)) : i < 0 ? (n in o || (o[n] = c),
                o[n]) : (a = parseFloat(n.charAt(i - 1) + n.substr(i + 1)),
                s && r && (a = a / 100 * (he(r) ? r[0] : r).totalDuration()),
                i > 1 ? e(t, n.substr(0, i - 1), r) + a : c + a)) : null == n ? c : +n
            }, Et = function(e, t, n) {
                var r, i, a = ae(t[1]), s = (a ? 2 : 1) + (e < 2 ? 0 : 1), o = t[s];
                if (a && (o.duration = t[1]),
                o.parent = n,
                e) {
                    for (r = o,
                    i = n; i && !("immediateRender"in r); )
                        r = i.vars.defaults || {},
                        i = le(i.vars.inherit) && i.parent;
                    o.immediateRender = le(r.immediateRender),
                    e < 2 ? o.runBackwards = 1 : o.startAt = t[s - 1]
                }
                return new Tn(t[0],o,t[s + 1])
            }, St = function(e, t) {
                return e || 0 === e ? t(e) : t
            }, wt = function(e, t, n) {
                return n < e ? e : n > t ? t : n
            }, Mt = function(e, t) {
                return re(e) && (t = ye.exec(e)) ? t[1] : ""
            }, Tt = [].slice, At = function(e, t) {
                return e && oe(e) && "length"in e && (!t && !e.length || e.length - 1 in e && oe(e[0])) && !e.nodeType && e !== U
            }, Ct = function(e, t, n) {
                return void 0 === n && (n = []),
                e.forEach((function(e) {
                    var r;
                    return re(e) && !t || At(e, 1) ? (r = n).push.apply(r, Pt(e)) : n.push(e)
                }
                )) || n
            }, Pt = function(e, t, n) {
                return I && !t && I.selector ? I.selector(e) : !re(e) || n || !k && en() ? he(e) ? Ct(e, n) : At(e) ? Tt.call(e, 0) : e ? [e] : [] : Tt.call((t || F).querySelectorAll(e), 0)
            }, Rt = function(e) {
                return e = Pt(e)[0] || we("Invalid scope") || {},
                function(t) {
                    var n = e.current || e.nativeElement || e;
                    return Pt(t, n.querySelectorAll ? n : n === e ? we("Invalid scope") || F.createElement("div") : e)
                }
            }, Lt = function(e) {
                return e.sort((function() {
                    return .5 - Math.random()
                }
                ))
            }, Ot = function(e) {
                if (ie(e))
                    return e;
                var t = oe(e) ? e : {
                    each: e
                }
                  , n = ln(t.ease)
                  , r = t.from || 0
                  , i = parseFloat(t.base) || 0
                  , a = {}
                  , s = r > 0 && r < 1
                  , o = isNaN(r) || s
                  , l = t.axis
                  , c = r
                  , u = r;
                return re(r) ? c = u = {
                    center: .5,
                    edges: .5,
                    end: 1
                }[r] || 0 : !s && o && (c = r[0],
                u = r[1]),
                function(e, s, d) {
                    var h, p, f, m, g, v, _, y, x, b = (d || t).length, E = a[b];
                    if (!E) {
                        if (!(x = "auto" === t.grid ? 0 : (t.grid || [1, $])[1])) {
                            for (_ = -$; _ < (_ = d[x++].getBoundingClientRect().left) && x < b; )
                                ;
                            x < b && x--
                        }
                        for (E = a[b] = [],
                        h = o ? Math.min(x, b) * c - .5 : r % x,
                        p = x === $ ? 0 : o ? b * u / x - .5 : r / x | 0,
                        _ = 0,
                        y = $,
                        v = 0; v < b; v++)
                            f = v % x - h,
                            m = p - (v / x | 0),
                            E[v] = g = l ? Math.abs("y" === l ? m : f) : ee(f * f + m * m),
                            g > _ && (_ = g),
                            g < y && (y = g);
                        "random" === r && Lt(E),
                        E.max = _ - y,
                        E.min = y,
                        E.v = b = (parseFloat(t.amount) || parseFloat(t.each) * (x > b ? b - 1 : l ? "y" === l ? b / x : x : Math.max(x, b / x)) || 0) * ("edges" === r ? -1 : 1),
                        E.b = b < 0 ? i - b : i,
                        E.u = Mt(t.amount || t.each) || 0,
                        n = n && b < 0 ? sn(n) : n
                    }
                    return b = (E[e] - E.min) / E.max || 0,
                    Ve(E.b + (n ? n(b) : b) * E.v) + E.u
                }
            }, Dt = function(e) {
                var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
                return function(n) {
                    var r = Ve(Math.round(parseFloat(n) / e) * e * t);
                    return (r - r % 1) / t + (ae(n) ? 0 : Mt(n))
                }
            }, It = function(e, t) {
                var n, r, i = he(e);
                return !i && oe(e) && (n = i = e.radius || $,
                e.values ? (e = Pt(e.values),
                (r = !ae(e[0])) && (n *= n)) : e = Dt(e.increment)),
                St(t, i ? ie(e) ? function(t) {
                    return r = e(t),
                    Math.abs(r - t) <= n ? r : t
                }
                : function(t) {
                    for (var i, a, s = parseFloat(r ? t.x : t), o = parseFloat(r ? t.y : 0), l = $, c = 0, u = e.length; u--; )
                        (i = r ? (i = e[u].x - s) * i + (a = e[u].y - o) * a : Math.abs(e[u] - s)) < l && (l = i,
                        c = u);
                    return c = !n || l <= n ? e[c] : t,
                    r || c === t || ae(t) ? c : c + Mt(t)
                }
                : Dt(e))
            }, Nt = function(e, t, n, r) {
                return St(he(e) ? !t : !0 === n ? !!(n = 0) : !r, (function() {
                    return he(e) ? e[~~(Math.random() * e.length)] : (n = n || 1e-5) && (r = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((e - n / 2 + Math.random() * (t - e + .99 * n)) / n) * n * r) / r
                }
                ))
            }, Ut = function(e, t, n) {
                return St(n, (function(n) {
                    return e[~~t(n)]
                }
                ))
            }, kt = function(e) {
                for (var t, n, r, i, a = 0, s = ""; ~(t = e.indexOf("random(", a)); )
                    r = e.indexOf(")", t),
                    i = "[" === e.charAt(t + 7),
                    n = e.substr(t + 7, r - t - 7).match(i ? _e : pe),
                    s += e.substr(a, t - a) + Nt(i ? n : +n[0], i ? 0 : +n[1], +n[2] || 1e-5),
                    a = r + 1;
                return s + e.substr(a, e.length - a)
            }, Ft = function(e, t, n, r, i) {
                var a = t - e
                  , s = r - n;
                return St(i, (function(t) {
                    return n + ((t - e) / a * s || 0)
                }
                ))
            }, zt = function(e, t, n) {
                var r, i, a, s = e.labels, o = $;
                for (r in s)
                    (i = s[r] - t) < 0 == !!n && i && o > (i = Math.abs(i)) && (a = r,
                    o = i);
                return a
            }, Bt = function(e, t, n) {
                var r, i, a, s = e.vars, o = s[t], l = I, c = e._ctx;
                if (o)
                    return r = s[t + "Params"],
                    i = s.callbackScope || e,
                    n && Le.length && Xe(),
                    c && (I = c),
                    a = r ? o.apply(i, r) : o.call(i),
                    I = l,
                    a
            }, Ht = function(e) {
                return rt(e),
                e.scrollTrigger && e.scrollTrigger.kill(!!D),
                e.progress() < 1 && Bt(e, "onInterrupt"),
                e
            }, Gt = [], Vt = function(e) {
                if (e)
                    if (e = !e.name && e.default || e,
                    ce() || e.headless) {
                        var t = e.name
                          , n = ie(e)
                          , r = t && !n && e.init ? function() {
                            this._props = []
                        }
                        : e
                          , i = {
                            init: Te,
                            render: Nn,
                            add: yn,
                            kill: kn,
                            modifier: Un,
                            rawVars: 0
                        }
                          , a = {
                            targetTest: 0,
                            get: 0,
                            getSetter: Ln,
                            aliases: {},
                            register: 0
                        };
                        if (en(),
                        e !== r) {
                            if (De[t])
                                return;
                            Ke(r, Ke(Qe(e, i), a)),
                            Ze(r.prototype, Ze(i, Qe(e, a))),
                            De[r.prop = t] = r,
                            e.targetTest && (Ue.push(r),
                            Re[t] = 1),
                            t = ("css" === t ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin"
                        }
                        Me(t, r),
                        e.register && e.register(Qn, r, Bn)
                    } else
                        Gt.push(e)
            }, Wt = 255, jt = {
                aqua: [0, Wt, Wt],
                lime: [0, Wt, 0],
                silver: [192, 192, 192],
                black: [0, 0, 0],
                maroon: [128, 0, 0],
                teal: [0, 128, 128],
                blue: [0, 0, Wt],
                navy: [0, 0, 128],
                white: [Wt, Wt, Wt],
                olive: [128, 128, 0],
                yellow: [Wt, Wt, 0],
                orange: [Wt, 165, 0],
                gray: [128, 128, 128],
                purple: [128, 0, 128],
                green: [0, 128, 0],
                red: [Wt, 0, 0],
                pink: [Wt, 192, 203],
                cyan: [0, Wt, Wt],
                transparent: [Wt, Wt, Wt, 0]
            }, Xt = function(e, t, n) {
                return (6 * (e += e < 0 ? 1 : e > 1 ? -1 : 0) < 1 ? t + (n - t) * e * 6 : e < .5 ? n : 3 * e < 2 ? t + (n - t) * (2 / 3 - e) * 6 : t) * Wt + .5 | 0
            }, qt = function(e, t, n) {
                var r, i, a, s, o, l, c, u, d, h, p = e ? ae(e) ? [e >> 16, e >> 8 & Wt, e & Wt] : 0 : jt.black;
                if (!p) {
                    if ("," === e.substr(-1) && (e = e.substr(0, e.length - 1)),
                    jt[e])
                        p = jt[e];
                    else if ("#" === e.charAt(0)) {
                        if (e.length < 6 && (r = e.charAt(1),
                        i = e.charAt(2),
                        a = e.charAt(3),
                        e = "#" + r + r + i + i + a + a + (5 === e.length ? e.charAt(4) + e.charAt(4) : "")),
                        9 === e.length)
                            return [(p = parseInt(e.substr(1, 6), 16)) >> 16, p >> 8 & Wt, p & Wt, parseInt(e.substr(7), 16) / 255];
                        p = [(e = parseInt(e.substr(1), 16)) >> 16, e >> 8 & Wt, e & Wt]
                    } else if ("hsl" === e.substr(0, 3))
                        if (p = h = e.match(pe),
                        t) {
                            if (~e.indexOf("="))
                                return p = e.match(fe),
                                n && p.length < 4 && (p[3] = 1),
                                p
                        } else
                            s = +p[0] % 360 / 360,
                            o = +p[1] / 100,
                            r = 2 * (l = +p[2] / 100) - (i = l <= .5 ? l * (o + 1) : l + o - l * o),
                            p.length > 3 && (p[3] *= 1),
                            p[0] = Xt(s + 1 / 3, r, i),
                            p[1] = Xt(s, r, i),
                            p[2] = Xt(s - 1 / 3, r, i);
                    else
                        p = e.match(pe) || jt.transparent;
                    p = p.map(Number)
                }
                return t && !h && (r = p[0] / Wt,
                i = p[1] / Wt,
                a = p[2] / Wt,
                l = ((c = Math.max(r, i, a)) + (u = Math.min(r, i, a))) / 2,
                c === u ? s = o = 0 : (d = c - u,
                o = l > .5 ? d / (2 - c - u) : d / (c + u),
                s = c === r ? (i - a) / d + (i < a ? 6 : 0) : c === i ? (a - r) / d + 2 : (r - i) / d + 4,
                s *= 60),
                p[0] = ~~(s + .5),
                p[1] = ~~(100 * o + .5),
                p[2] = ~~(100 * l + .5)),
                n && p.length < 4 && (p[3] = 1),
                p
            }, Yt = function(e) {
                var t = []
                  , n = []
                  , r = -1;
                return e.split(Kt).forEach((function(e) {
                    var i = e.match(me) || [];
                    t.push.apply(t, i),
                    n.push(r += i.length + 1)
                }
                )),
                t.c = n,
                t
            }, $t = function(e, t, n) {
                var r, i, a, s, o = "", l = (e + o).match(Kt), c = t ? "hsla(" : "rgba(", u = 0;
                if (!l)
                    return e;
                if (l = l.map((function(e) {
                    return (e = qt(e, t, 1)) && c + (t ? e[0] + "," + e[1] + "%," + e[2] + "%," + e[3] : e.join(",")) + ")"
                }
                )),
                n && (a = Yt(e),
                (r = n.c).join(o) !== a.c.join(o)))
                    for (s = (i = e.replace(Kt, "1").split(me)).length - 1; u < s; u++)
                        o += i[u] + (~r.indexOf(u) ? l.shift() || c + "0,0,0,0)" : (a.length ? a : l.length ? l : n).shift());
                if (!i)
                    for (s = (i = e.split(Kt)).length - 1; u < s; u++)
                        o += i[u] + l[u];
                return o + i[s]
            }, Kt = function() {
                var e, t = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
                for (e in jt)
                    t += "|" + e + "\\b";
                return new RegExp(t + ")","gi")
            }(), Zt = /hsl[a]?\(/, Jt = function(e) {
                var t, n = e.join(" ");
                if (Kt.lastIndex = 0,
                Kt.test(n))
                    return t = Zt.test(n),
                    e[1] = $t(e[1], t),
                    e[0] = $t(e[0], t, Yt(e[1])),
                    !0
            }, Qt = function() {
                var e, t, n, r, i, a, s = Date.now, o = 500, l = 33, c = s(), u = c, d = 1e3 / 240, h = d, p = [], f = function n(f) {
                    var m, g, v, _, y = s() - u, x = !0 === f;
                    if ((y > o || y < 0) && (c += y - l),
                    ((m = (v = (u += y) - c) - h) > 0 || x) && (_ = ++r.frame,
                    i = v - 1e3 * r.time,
                    r.time = v /= 1e3,
                    h += m + (m >= d ? 4 : d - m),
                    g = 1),
                    x || (e = t(n)),
                    g)
                        for (a = 0; a < p.length; a++)
                            p[a](v, i, _, f)
                };
                return r = {
                    time: 0,
                    frame: 0,
                    tick: function() {
                        f(!0)
                    },
                    deltaRatio: function(e) {
                        return i / (1e3 / (e || 60))
                    },
                    wake: function() {
                        z && (!k && ce() && (U = k = window,
                        F = U.document || {},
                        xe.gsap = Qn,
                        (U.gsapVersions || (U.gsapVersions = [])).push(Qn.version),
                        Ee(be || U.GreenSockGlobals || !U.gsap && U || {}),
                        Gt.forEach(Vt)),
                        n = "undefined" != typeof requestAnimationFrame && requestAnimationFrame,
                        e && r.sleep(),
                        t = n || function(e) {
                            return setTimeout(e, h - 1e3 * r.time + 1 | 0)
                        }
                        ,
                        G = 1,
                        f(2))
                    },
                    sleep: function() {
                        (n ? cancelAnimationFrame : clearTimeout)(e),
                        G = 0,
                        t = Te
                    },
                    lagSmoothing: function(e, t) {
                        o = e || 1 / 0,
                        l = Math.min(t || 33, o)
                    },
                    fps: function(e) {
                        d = 1e3 / (e || 240),
                        h = 1e3 * r.time + d
                    },
                    add: function(e, t, n) {
                        var i = t ? function(t, n, a, s) {
                            e(t, n, a, s),
                            r.remove(i)
                        }
                        : e;
                        return r.remove(e),
                        p[n ? "unshift" : "push"](i),
                        en(),
                        i
                    },
                    remove: function(e, t) {
                        ~(t = p.indexOf(e)) && p.splice(t, 1) && a >= t && a--
                    },
                    _listeners: p
                },
                r
            }(), en = function() {
                return !G && Qt.wake()
            }, tn = {}, nn = /^[\d.\-M][\d.\-,\s]/, rn = /["']/g, an = function(e) {
                for (var t, n, r, i = {}, a = e.substr(1, e.length - 3).split(":"), s = a[0], o = 1, l = a.length; o < l; o++)
                    n = a[o],
                    t = o !== l - 1 ? n.lastIndexOf(",") : n.length,
                    r = n.substr(0, t),
                    i[s] = isNaN(r) ? r.replace(rn, "").trim() : +r,
                    s = n.substr(t + 1).trim();
                return i
            }, sn = function(e) {
                return function(t) {
                    return 1 - e(1 - t)
                }
            }, on = function e(t, n) {
                for (var r, i = t._first; i; )
                    i instanceof mn ? e(i, n) : !i.vars.yoyoEase || i._yoyo && i._repeat || i._yoyo === n || (i.timeline ? e(i.timeline, n) : (r = i._ease,
                    i._ease = i._yEase,
                    i._yEase = r,
                    i._yoyo = n)),
                    i = i._next
            }, ln = function(e, t) {
                return e && (ie(e) ? e : tn[e] || function(e) {
                    var t, n, r, i, a = (e + "").split("("), s = tn[a[0]];
                    return s && a.length > 1 && s.config ? s.config.apply(null, ~e.indexOf("{") ? [an(a[1])] : (t = e,
                    n = t.indexOf("(") + 1,
                    r = t.indexOf(")"),
                    i = t.indexOf("(", n),
                    t.substring(n, ~i && i < r ? t.indexOf(")", r + 1) : r)).split(",").map(Ye)) : tn._CE && nn.test(e) ? tn._CE("", e) : s
                }(e)) || t
            }, cn = function(e, t, n, r) {
                void 0 === n && (n = function(e) {
                    return 1 - t(1 - e)
                }
                ),
                void 0 === r && (r = function(e) {
                    return e < .5 ? t(2 * e) / 2 : 1 - t(2 * (1 - e)) / 2
                }
                );
                var i, a = {
                    easeIn: t,
                    easeOut: n,
                    easeInOut: r
                };
                return He(e, (function(e) {
                    for (var t in tn[e] = xe[e] = a,
                    tn[i = e.toLowerCase()] = n,
                    a)
                        tn[i + ("easeIn" === t ? ".in" : "easeOut" === t ? ".out" : ".inOut")] = tn[e + "." + t] = a[t]
                }
                )),
                a
            }, un = function(e) {
                return function(t) {
                    return t < .5 ? (1 - e(1 - 2 * t)) / 2 : .5 + e(2 * (t - .5)) / 2
                }
            }, dn = function e(t, n, r) {
                var i = n >= 1 ? n : 1
                  , a = (r || (t ? .3 : .45)) / (n < 1 ? n : 1)
                  , s = a / Z * (Math.asin(1 / i) || 0)
                  , o = function(e) {
                    return 1 === e ? 1 : i * Math.pow(2, -10 * e) * ne((e - s) * a) + 1
                }
                  , l = "out" === t ? o : "in" === t ? function(e) {
                    return 1 - o(1 - e)
                }
                : un(o);
                return a = Z / a,
                l.config = function(n, r) {
                    return e(t, n, r)
                }
                ,
                l
            }, hn = function e(t, n) {
                void 0 === n && (n = 1.70158);
                var r = function(e) {
                    return e ? --e * e * ((n + 1) * e + n) + 1 : 0
                }
                  , i = "out" === t ? r : "in" === t ? function(e) {
                    return 1 - r(1 - e)
                }
                : un(r);
                return i.config = function(n) {
                    return e(t, n)
                }
                ,
                i
            };
            He("Linear,Quad,Cubic,Quart,Quint,Strong", (function(e, t) {
                var n = t < 5 ? t + 1 : t;
                cn(e + ",Power" + (n - 1), t ? function(e) {
                    return Math.pow(e, n)
                }
                : function(e) {
                    return e
                }
                , (function(e) {
                    return 1 - Math.pow(1 - e, n)
                }
                ), (function(e) {
                    return e < .5 ? Math.pow(2 * e, n) / 2 : 1 - Math.pow(2 * (1 - e), n) / 2
                }
                ))
            }
            )),
            tn.Linear.easeNone = tn.none = tn.Linear.easeIn,
            cn("Elastic", dn("in"), dn("out"), dn()),
            V = 7.5625,
            j = 1 / (W = 2.75),
            cn("Bounce", (function(e) {
                return 1 - X(1 - e)
            }
            ), X = function(e) {
                return e < j ? V * e * e : e < .7272727272727273 ? V * Math.pow(e - 1.5 / W, 2) + .75 : e < .9090909090909092 ? V * (e -= 2.25 / W) * e + .9375 : V * Math.pow(e - 2.625 / W, 2) + .984375
            }
            ),
            cn("Expo", (function(e) {
                return e ? Math.pow(2, 10 * (e - 1)) : 0
            }
            )),
            cn("Circ", (function(e) {
                return -(ee(1 - e * e) - 1)
            }
            )),
            cn("Sine", (function(e) {
                return 1 === e ? 1 : 1 - te(e * J)
            }
            )),
            cn("Back", hn("in"), hn("out"), hn()),
            tn.SteppedEase = tn.steps = xe.SteppedEase = {
                config: function(e, t) {
                    void 0 === e && (e = 1);
                    var n = 1 / e
                      , r = e + (t ? 0 : 1)
                      , i = t ? 1 : 0;
                    return function(e) {
                        return ((r * wt(0, .99999999, e) | 0) + i) * n
                    }
                }
            },
            Y.ease = tn["quad.out"],
            He("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function(e) {
                return ke += e + "," + e + "Params,"
            }
            ));
            var pn = function(e, t) {
                this.id = Q++,
                e._gsap = this,
                this.target = e,
                this.harness = t,
                this.get = t ? t.get : Be,
                this.set = t ? t.getSetter : Ln
            }
              , fn = function() {
                function e(e) {
                    this.vars = e,
                    this._delay = +e.delay || 0,
                    (this._repeat = e.repeat === 1 / 0 ? -2 : e.repeat || 0) && (this._rDelay = e.repeatDelay || 0,
                    this._yoyo = !!e.yoyo || !!e.yoyoEase),
                    this._ts = 1,
                    _t(this, +e.duration, 1, 1),
                    this.data = e.data,
                    I && (this._ctx = I,
                    I.data.push(this)),
                    G || Qt.wake()
                }
                var t = e.prototype;
                return t.delay = function(e) {
                    return e || 0 === e ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + e - this._delay),
                    this._delay = e,
                    this) : this._delay
                }
                ,
                t.duration = function(e) {
                    return arguments.length ? this.totalDuration(this._repeat > 0 ? e + (e + this._rDelay) * this._repeat : e) : this.totalDuration() && this._dur
                }
                ,
                t.totalDuration = function(e) {
                    return arguments.length ? (this._dirty = 0,
                    _t(this, this._repeat < 0 ? e : (e - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
                }
                ,
                t.totalTime = function(e, t) {
                    if (en(),
                    !arguments.length)
                        return this._tTime;
                    var n = this._dp;
                    if (n && n.smoothChildTiming && this._ts) {
                        for (dt(this, e),
                        !n._dp || n.parent || ht(n, this); n && n.parent; )
                            n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0),
                            n = n.parent;
                        !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && e < this._tDur || this._ts < 0 && e > 0 || !this._tDur && !e) && pt(this._dp, this, this._start - this._delay)
                    }
                    return (this._tTime !== e || !this._dur && !t || this._initted && Math.abs(this._zTime) === K || !e && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = e),
                    qe(this, e, t)),
                    this
                }
                ,
                t.time = function(e, t) {
                    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), e + ot(this)) % (this._dur + this._rDelay) || (e ? this._dur : 0), t) : this._time
                }
                ,
                t.totalProgress = function(e, t) {
                    return arguments.length ? this.totalTime(this.totalDuration() * e, t) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0
                }
                ,
                t.progress = function(e, t) {
                    return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? e : 1 - e) + ot(this), t) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0
                }
                ,
                t.iteration = function(e, t) {
                    var n = this.duration() + this._rDelay;
                    return arguments.length ? this.totalTime(this._time + (e - 1) * n, t) : this._repeat ? lt(this._tTime, n) + 1 : 1
                }
                ,
                t.timeScale = function(e, t) {
                    if (!arguments.length)
                        return -1e-8 === this._rts ? 0 : this._rts;
                    if (this._rts === e)
                        return this;
                    var n = this.parent && this._ts ? ct(this.parent._time, this) : this._tTime;
                    return this._rts = +e || 0,
                    this._ts = this._ps || -1e-8 === e ? 0 : this._rts,
                    this.totalTime(wt(-Math.abs(this._delay), this._tDur, n), !1 !== t),
                    ut(this),
                    function(e) {
                        for (var t = e.parent; t && t.parent; )
                            t._dirty = 1,
                            t.totalDuration(),
                            t = t.parent;
                        return e
                    }(this)
                }
                ,
                t.paused = function(e) {
                    return arguments.length ? (this._ps !== e && (this._ps = e,
                    e ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()),
                    this._ts = this._act = 0) : (en(),
                    this._ts = this._rts,
                    this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== K && (this._tTime -= K)))),
                    this) : this._ps
                }
                ,
                t.startTime = function(e) {
                    if (arguments.length) {
                        this._start = e;
                        var t = this.parent || this._dp;
                        return t && (t._sort || !this.parent) && pt(t, this, e - this._delay),
                        this
                    }
                    return this._start
                }
                ,
                t.endTime = function(e) {
                    return this._start + (le(e) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
                }
                ,
                t.rawTime = function(e) {
                    var t = this.parent || this._dp;
                    return t ? e && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? ct(t.rawTime(e), this) : this._tTime : this._tTime
                }
                ,
                t.revert = function(e) {
                    void 0 === e && (e = Pe);
                    var t = D;
                    return D = e,
                    (this._initted || this._startAt) && (this.timeline && this.timeline.revert(e),
                    this.totalTime(-.01, e.suppressEvents)),
                    "nested" !== this.data && !1 !== e.kill && this.kill(),
                    D = t,
                    this
                }
                ,
                t.globalTime = function(e) {
                    for (var t = this, n = arguments.length ? e : t.rawTime(); t; )
                        n = t._start + n / (Math.abs(t._ts) || 1),
                        t = t._dp;
                    return !this.parent && this._sat ? this._sat.globalTime(e) : n
                }
                ,
                t.repeat = function(e) {
                    return arguments.length ? (this._repeat = e === 1 / 0 ? -2 : e,
                    yt(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
                }
                ,
                t.repeatDelay = function(e) {
                    if (arguments.length) {
                        var t = this._time;
                        return this._rDelay = e,
                        yt(this),
                        t ? this.time(t) : this
                    }
                    return this._rDelay
                }
                ,
                t.yoyo = function(e) {
                    return arguments.length ? (this._yoyo = e,
                    this) : this._yoyo
                }
                ,
                t.seek = function(e, t) {
                    return this.totalTime(bt(this, e), le(t))
                }
                ,
                t.restart = function(e, t) {
                    return this.play().totalTime(e ? -this._delay : 0, le(t))
                }
                ,
                t.play = function(e, t) {
                    return null != e && this.seek(e, t),
                    this.reversed(!1).paused(!1)
                }
                ,
                t.reverse = function(e, t) {
                    return null != e && this.seek(e || this.totalDuration(), t),
                    this.reversed(!0).paused(!1)
                }
                ,
                t.pause = function(e, t) {
                    return null != e && this.seek(e, t),
                    this.paused(!0)
                }
                ,
                t.resume = function() {
                    return this.paused(!1)
                }
                ,
                t.reversed = function(e) {
                    return arguments.length ? (!!e !== this.reversed() && this.timeScale(-this._rts || (e ? -1e-8 : 0)),
                    this) : this._rts < 0
                }
                ,
                t.invalidate = function() {
                    return this._initted = this._act = 0,
                    this._zTime = -1e-8,
                    this
                }
                ,
                t.isActive = function() {
                    var e, t = this.parent || this._dp, n = this._start;
                    return !(t && !(this._ts && this._initted && t.isActive() && (e = t.rawTime(!0)) >= n && e < this.endTime(!0) - K))
                }
                ,
                t.eventCallback = function(e, t, n) {
                    var r = this.vars;
                    return arguments.length > 1 ? (t ? (r[e] = t,
                    n && (r[e + "Params"] = n),
                    "onUpdate" === e && (this._onUpdate = t)) : delete r[e],
                    this) : r[e]
                }
                ,
                t.then = function(e) {
                    var t = this;
                    return new Promise((function(n) {
                        var r = ie(e) ? e : $e
                          , i = function() {
                            var e = t.then;
                            t.then = null,
                            ie(r) && (r = r(t)) && (r.then || r === t) && (t.then = e),
                            n(r),
                            t.then = e
                        };
                        t._initted && 1 === t.totalProgress() && t._ts >= 0 || !t._tTime && t._ts < 0 ? i() : t._prom = i
                    }
                    ))
                }
                ,
                t.kill = function() {
                    Ht(this)
                }
                ,
                e
            }();
            Ke(fn.prototype, {
                _time: 0,
                _start: 0,
                _end: 0,
                _tTime: 0,
                _tDur: 0,
                _dirty: 0,
                _repeat: 0,
                _yoyo: !1,
                parent: null,
                _initted: !1,
                _rDelay: 0,
                _ts: 1,
                _dp: 0,
                ratio: 0,
                _zTime: -1e-8,
                _prom: 0,
                _ps: !1,
                _rts: 1
            });
            var mn = function(e) {
                function t(t, n) {
                    var r;
                    return void 0 === t && (t = {}),
                    (r = e.call(this, t) || this).labels = {},
                    r.smoothChildTiming = !!t.smoothChildTiming,
                    r.autoRemoveChildren = !!t.autoRemoveChildren,
                    r._sort = le(t.sortChildren),
                    N && pt(t.parent || N, R(r), n),
                    t.reversed && r.reverse(),
                    t.paused && r.paused(!0),
                    t.scrollTrigger && ft(R(r), t.scrollTrigger),
                    r
                }
                L(t, e);
                var n = t.prototype;
                return n.to = function(e, t, n) {
                    return Et(0, arguments, this),
                    this
                }
                ,
                n.from = function(e, t, n) {
                    return Et(1, arguments, this),
                    this
                }
                ,
                n.fromTo = function(e, t, n, r) {
                    return Et(2, arguments, this),
                    this
                }
                ,
                n.set = function(e, t, n) {
                    return t.duration = 0,
                    t.parent = this,
                    et(t).repeatDelay || (t.repeat = 0),
                    t.immediateRender = !!t.immediateRender,
                    new Tn(e,t,bt(this, n),1),
                    this
                }
                ,
                n.call = function(e, t, n) {
                    return pt(this, Tn.delayedCall(0, e, t), n)
                }
                ,
                n.staggerTo = function(e, t, n, r, i, a, s) {
                    return n.duration = t,
                    n.stagger = n.stagger || r,
                    n.onComplete = a,
                    n.onCompleteParams = s,
                    n.parent = this,
                    new Tn(e,n,bt(this, i)),
                    this
                }
                ,
                n.staggerFrom = function(e, t, n, r, i, a, s) {
                    return n.runBackwards = 1,
                    et(n).immediateRender = le(n.immediateRender),
                    this.staggerTo(e, t, n, r, i, a, s)
                }
                ,
                n.staggerFromTo = function(e, t, n, r, i, a, s, o) {
                    return r.startAt = n,
                    et(r).immediateRender = le(r.immediateRender),
                    this.staggerTo(e, t, r, i, a, s, o)
                }
                ,
                n.render = function(e, t, n) {
                    var r, i, a, s, o, l, c, u, d, h, p, f, m = this._time, g = this._dirty ? this.totalDuration() : this._tDur, v = this._dur, _ = e <= 0 ? 0 : Ve(e), y = this._zTime < 0 != e < 0 && (this._initted || !v);
                    if (this !== N && _ > g && e >= 0 && (_ = g),
                    _ !== this._tTime || n || y) {
                        if (m !== this._time && v && (_ += this._time - m,
                        e += this._time - m),
                        r = _,
                        d = this._start,
                        l = !(u = this._ts),
                        y && (v || (m = this._zTime),
                        (e || !t) && (this._zTime = e)),
                        this._repeat) {
                            if (p = this._yoyo,
                            o = v + this._rDelay,
                            this._repeat < -1 && e < 0)
                                return this.totalTime(100 * o + e, t, n);
                            if (r = Ve(_ % o),
                            _ === g ? (s = this._repeat,
                            r = v) : ((s = ~~(_ / o)) && s === _ / o && (r = v,
                            s--),
                            r > v && (r = v)),
                            h = lt(this._tTime, o),
                            !m && this._tTime && h !== s && this._tTime - h * o - this._dur <= 0 && (h = s),
                            p && 1 & s && (r = v - r,
                            f = 1),
                            s !== h && !this._lock) {
                                var x = p && 1 & h
                                  , b = x === (p && 1 & s);
                                if (s < h && (x = !x),
                                m = x ? 0 : _ % v ? v : _,
                                this._lock = 1,
                                this.render(m || (f ? 0 : Ve(s * o)), t, !v)._lock = 0,
                                this._tTime = _,
                                !t && this.parent && Bt(this, "onRepeat"),
                                this.vars.repeatRefresh && !f && (this.invalidate()._lock = 1),
                                m && m !== this._time || l !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
                                    return this;
                                if (v = this._dur,
                                g = this._tDur,
                                b && (this._lock = 2,
                                m = x ? v : -1e-4,
                                this.render(m, !0),
                                this.vars.repeatRefresh && !f && this.invalidate()),
                                this._lock = 0,
                                !this._ts && !l)
                                    return this;
                                on(this, f)
                            }
                        }
                        if (this._hasPause && !this._forcing && this._lock < 2 && (c = function(e, t, n) {
                            var r;
                            if (n > t)
                                for (r = e._first; r && r._start <= n; ) {
                                    if ("isPause" === r.data && r._start > t)
                                        return r;
                                    r = r._next
                                }
                            else
                                for (r = e._last; r && r._start >= n; ) {
                                    if ("isPause" === r.data && r._start < t)
                                        return r;
                                    r = r._prev
                                }
                        }(this, Ve(m), Ve(r)),
                        c && (_ -= r - (r = c._start))),
                        this._tTime = _,
                        this._time = r,
                        this._act = !u,
                        this._initted || (this._onUpdate = this.vars.onUpdate,
                        this._initted = 1,
                        this._zTime = e,
                        m = 0),
                        !m && r && !t && !s && (Bt(this, "onStart"),
                        this._tTime !== _))
                            return this;
                        if (r >= m && e >= 0)
                            for (i = this._first; i; ) {
                                if (a = i._next,
                                (i._act || r >= i._start) && i._ts && c !== i) {
                                    if (i.parent !== this)
                                        return this.render(e, t, n);
                                    if (i.render(i._ts > 0 ? (r - i._start) * i._ts : (i._dirty ? i.totalDuration() : i._tDur) + (r - i._start) * i._ts, t, n),
                                    r !== this._time || !this._ts && !l) {
                                        c = 0,
                                        a && (_ += this._zTime = -1e-8);
                                        break
                                    }
                                }
                                i = a
                            }
                        else {
                            i = this._last;
                            for (var E = e < 0 ? e : r; i; ) {
                                if (a = i._prev,
                                (i._act || E <= i._end) && i._ts && c !== i) {
                                    if (i.parent !== this)
                                        return this.render(e, t, n);
                                    if (i.render(i._ts > 0 ? (E - i._start) * i._ts : (i._dirty ? i.totalDuration() : i._tDur) + (E - i._start) * i._ts, t, n || D && (i._initted || i._startAt)),
                                    r !== this._time || !this._ts && !l) {
                                        c = 0,
                                        a && (_ += this._zTime = E ? -1e-8 : K);
                                        break
                                    }
                                }
                                i = a
                            }
                        }
                        if (c && !t && (this.pause(),
                        c.render(r >= m ? 0 : -1e-8)._zTime = r >= m ? 1 : -1,
                        this._ts))
                            return this._start = d,
                            ut(this),
                            this.render(e, t, n);
                        this._onUpdate && !t && Bt(this, "onUpdate", !0),
                        (_ === g && this._tTime >= this.totalDuration() || !_ && m) && (d !== this._start && Math.abs(u) === Math.abs(this._ts) || this._lock || ((e || !v) && (_ === g && this._ts > 0 || !_ && this._ts < 0) && rt(this, 1),
                        t || e < 0 && !m || !_ && !m && g || (Bt(this, _ === g && e >= 0 ? "onComplete" : "onReverseComplete", !0),
                        this._prom && !(_ < g && this.timeScale() > 0) && this._prom())))
                    }
                    return this
                }
                ,
                n.add = function(e, t) {
                    var n = this;
                    if (ae(t) || (t = bt(this, t, e)),
                    !(e instanceof fn)) {
                        if (he(e))
                            return e.forEach((function(e) {
                                return n.add(e, t)
                            }
                            )),
                            this;
                        if (re(e))
                            return this.addLabel(e, t);
                        if (!ie(e))
                            return this;
                        e = Tn.delayedCall(0, e)
                    }
                    return this !== e ? pt(this, e, t) : this
                }
                ,
                n.getChildren = function(e, t, n, r) {
                    void 0 === e && (e = !0),
                    void 0 === t && (t = !0),
                    void 0 === n && (n = !0),
                    void 0 === r && (r = -$);
                    for (var i = [], a = this._first; a; )
                        a._start >= r && (a instanceof Tn ? t && i.push(a) : (n && i.push(a),
                        e && i.push.apply(i, a.getChildren(!0, t, n)))),
                        a = a._next;
                    return i
                }
                ,
                n.getById = function(e) {
                    for (var t = this.getChildren(1, 1, 1), n = t.length; n--; )
                        if (t[n].vars.id === e)
                            return t[n]
                }
                ,
                n.remove = function(e) {
                    return re(e) ? this.removeLabel(e) : ie(e) ? this.killTweensOf(e) : (nt(this, e),
                    e === this._recent && (this._recent = this._last),
                    it(this))
                }
                ,
                n.totalTime = function(t, n) {
                    return arguments.length ? (this._forcing = 1,
                    !this._dp && this._ts && (this._start = Ve(Qt.time - (this._ts > 0 ? t / this._ts : (this.totalDuration() - t) / -this._ts))),
                    e.prototype.totalTime.call(this, t, n),
                    this._forcing = 0,
                    this) : this._tTime
                }
                ,
                n.addLabel = function(e, t) {
                    return this.labels[e] = bt(this, t),
                    this
                }
                ,
                n.removeLabel = function(e) {
                    return delete this.labels[e],
                    this
                }
                ,
                n.addPause = function(e, t, n) {
                    var r = Tn.delayedCall(0, t || Te, n);
                    return r.data = "isPause",
                    this._hasPause = 1,
                    pt(this, r, bt(this, e))
                }
                ,
                n.removePause = function(e) {
                    var t = this._first;
                    for (e = bt(this, e); t; )
                        t._start === e && "isPause" === t.data && rt(t),
                        t = t._next
                }
                ,
                n.killTweensOf = function(e, t, n) {
                    for (var r = this.getTweensOf(e, n), i = r.length; i--; )
                        gn !== r[i] && r[i].kill(e, t);
                    return this
                }
                ,
                n.getTweensOf = function(e, t) {
                    for (var n, r = [], i = Pt(e), a = this._first, s = ae(t); a; )
                        a instanceof Tn ? je(a._targets, i) && (s ? (!gn || a._initted && a._ts) && a.globalTime(0) <= t && a.globalTime(a.totalDuration()) > t : !t || a.isActive()) && r.push(a) : (n = a.getTweensOf(i, t)).length && r.push.apply(r, n),
                        a = a._next;
                    return r
                }
                ,
                n.tweenTo = function(e, t) {
                    t = t || {};
                    var n, r = this, i = bt(r, e), a = t, s = a.startAt, o = a.onStart, l = a.onStartParams, c = a.immediateRender, u = Tn.to(r, Ke({
                        ease: t.ease || "none",
                        lazy: !1,
                        immediateRender: !1,
                        time: i,
                        overwrite: "auto",
                        duration: t.duration || Math.abs((i - (s && "time"in s ? s.time : r._time)) / r.timeScale()) || K,
                        onStart: function() {
                            if (r.pause(),
                            !n) {
                                var e = t.duration || Math.abs((i - (s && "time"in s ? s.time : r._time)) / r.timeScale());
                                u._dur !== e && _t(u, e, 0, 1).render(u._time, !0, !0),
                                n = 1
                            }
                            o && o.apply(u, l || [])
                        }
                    }, t));
                    return c ? u.render(0) : u
                }
                ,
                n.tweenFromTo = function(e, t, n) {
                    return this.tweenTo(t, Ke({
                        startAt: {
                            time: bt(this, e)
                        }
                    }, n))
                }
                ,
                n.recent = function() {
                    return this._recent
                }
                ,
                n.nextLabel = function(e) {
                    return void 0 === e && (e = this._time),
                    zt(this, bt(this, e))
                }
                ,
                n.previousLabel = function(e) {
                    return void 0 === e && (e = this._time),
                    zt(this, bt(this, e), 1)
                }
                ,
                n.currentLabel = function(e) {
                    return arguments.length ? this.seek(e, !0) : this.previousLabel(this._time + K)
                }
                ,
                n.shiftChildren = function(e, t, n) {
                    void 0 === n && (n = 0);
                    for (var r, i = this._first, a = this.labels; i; )
                        i._start >= n && (i._start += e,
                        i._end += e),
                        i = i._next;
                    if (t)
                        for (r in a)
                            a[r] >= n && (a[r] += e);
                    return it(this)
                }
                ,
                n.invalidate = function(t) {
                    var n = this._first;
                    for (this._lock = 0; n; )
                        n.invalidate(t),
                        n = n._next;
                    return e.prototype.invalidate.call(this, t)
                }
                ,
                n.clear = function(e) {
                    void 0 === e && (e = !0);
                    for (var t, n = this._first; n; )
                        t = n._next,
                        this.remove(n),
                        n = t;
                    return this._dp && (this._time = this._tTime = this._pTime = 0),
                    e && (this.labels = {}),
                    it(this)
                }
                ,
                n.totalDuration = function(e) {
                    var t, n, r, i = 0, a = this, s = a._last, o = $;
                    if (arguments.length)
                        return a.timeScale((a._repeat < 0 ? a.duration() : a.totalDuration()) / (a.reversed() ? -e : e));
                    if (a._dirty) {
                        for (r = a.parent; s; )
                            t = s._prev,
                            s._dirty && s.totalDuration(),
                            (n = s._start) > o && a._sort && s._ts && !a._lock ? (a._lock = 1,
                            pt(a, s, n - s._delay, 1)._lock = 0) : o = n,
                            n < 0 && s._ts && (i -= n,
                            (!r && !a._dp || r && r.smoothChildTiming) && (a._start += n / a._ts,
                            a._time -= n,
                            a._tTime -= n),
                            a.shiftChildren(-n, !1, -Infinity),
                            o = 0),
                            s._end > i && s._ts && (i = s._end),
                            s = t;
                        _t(a, a === N && a._time > i ? a._time : i, 1, 1),
                        a._dirty = 0
                    }
                    return a._tDur
                }
                ,
                t.updateRoot = function(e) {
                    if (N._ts && (qe(N, ct(e, N)),
                    B = Qt.frame),
                    Qt.frame >= Ne) {
                        Ne += q.autoSleep || 120;
                        var t = N._first;
                        if ((!t || !t._ts) && q.autoSleep && Qt._listeners.length < 2) {
                            for (; t && !t._ts; )
                                t = t._next;
                            t || Qt.sleep()
                        }
                    }
                }
                ,
                t
            }(fn);
            Ke(mn.prototype, {
                _lock: 0,
                _hasPause: 0,
                _forcing: 0
            });
            var gn, vn, _n = function(e, t, n, r, i, a, s) {
                var o, l, c, u, d, h, p, f, m = new Bn(this._pt,e,t,0,1,In,null,i), g = 0, v = 0;
                for (m.b = n,
                m.e = r,
                n += "",
                (p = ~(r += "").indexOf("random(")) && (r = kt(r)),
                a && (a(f = [n, r], e, t),
                n = f[0],
                r = f[1]),
                l = n.match(ge) || []; o = ge.exec(r); )
                    u = o[0],
                    d = r.substring(g, o.index),
                    c ? c = (c + 1) % 5 : "rgba(" === d.substr(-5) && (c = 1),
                    u !== l[v++] && (h = parseFloat(l[v - 1]) || 0,
                    m._pt = {
                        _next: m._pt,
                        p: d || 1 === v ? d : ",",
                        s: h,
                        c: "=" === u.charAt(1) ? We(h, u) - h : parseFloat(u) - h,
                        m: c && c < 4 ? Math.round : 0
                    },
                    g = ge.lastIndex);
                return m.c = g < r.length ? r.substring(g, r.length) : "",
                m.fp = s,
                (ve.test(r) || p) && (m.e = 0),
                this._pt = m,
                m
            }, yn = function(e, t, n, r, i, a, s, o, l, c) {
                ie(r) && (r = r(i || 0, e, a));
                var u, d = e[t], h = "get" !== n ? n : ie(d) ? l ? e[t.indexOf("set") || !ie(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](l) : e[t]() : d, p = ie(d) ? l ? Pn : Cn : An;
                if (re(r) && (~r.indexOf("random(") && (r = kt(r)),
                "=" === r.charAt(1) && ((u = We(h, r) + (Mt(h) || 0)) || 0 === u) && (r = u)),
                !c || h !== r || vn)
                    return isNaN(h * r) || "" === r ? (!d && !(t in e) && Se(t, r),
                    _n.call(this, e, t, h, r, p, o || q.stringFilter, l)) : (u = new Bn(this._pt,e,t,+h || 0,r - (h || 0),"boolean" == typeof d ? Dn : On,0,p),
                    l && (u.fp = l),
                    s && u.modifier(s, this, e),
                    this._pt = u)
            }, xn = function(e, t, n, r, i, a) {
                var s, o, l, c;
                if (De[e] && !1 !== (s = new De[e]).init(i, s.rawVars ? t[e] : function(e, t, n, r, i) {
                    if (ie(e) && (e = Sn(e, i, t, n, r)),
                    !oe(e) || e.style && e.nodeType || he(e) || de(e))
                        return re(e) ? Sn(e, i, t, n, r) : e;
                    var a, s = {};
                    for (a in e)
                        s[a] = Sn(e[a], i, t, n, r);
                    return s
                }(t[e], r, i, a, n), n, r, a) && (n._pt = o = new Bn(n._pt,i,e,0,1,s.render,s,0,s.priority),
                n !== H))
                    for (l = n._ptLookup[n._targets.indexOf(i)],
                    c = s._props.length; c--; )
                        l[s._props[c]] = o;
                return s
            }, bn = function e(t, n, r) {
                var i, a, s, o, l, c, u, d, h, p, f, m, g, v = t.vars, _ = v.ease, y = v.startAt, x = v.immediateRender, b = v.lazy, E = v.onUpdate, S = v.runBackwards, w = v.yoyoEase, M = v.keyframes, T = v.autoRevert, A = t._dur, C = t._startAt, P = t._targets, R = t.parent, L = R && "nested" === R.data ? R.vars.targets : P, I = "auto" === t._overwrite && !O, U = t.timeline;
                if (U && (!M || !_) && (_ = "none"),
                t._ease = ln(_, Y.ease),
                t._yEase = w ? sn(ln(!0 === w ? _ : w, Y.ease)) : 0,
                w && t._yoyo && !t._repeat && (w = t._yEase,
                t._yEase = t._ease,
                t._ease = w),
                t._from = !U && !!v.runBackwards,
                !U || M && !v.stagger) {
                    if (m = (d = P[0] ? ze(P[0]).harness : 0) && v[d.prop],
                    i = Qe(v, Re),
                    C && (C._zTime < 0 && C.progress(1),
                    n < 0 && S && x && !T ? C.render(-1, !0) : C.revert(S && A ? Ce : Ae),
                    C._lazy = 0),
                    y) {
                        if (rt(t._startAt = Tn.set(P, Ke({
                            data: "isStart",
                            overwrite: !1,
                            parent: R,
                            immediateRender: !0,
                            lazy: !C && le(b),
                            startAt: null,
                            delay: 0,
                            onUpdate: E && function() {
                                return Bt(t, "onUpdate")
                            }
                            ,
                            stagger: 0
                        }, y))),
                        t._startAt._dp = 0,
                        t._startAt._sat = t,
                        n < 0 && (D || !x && !T) && t._startAt.revert(Ce),
                        x && A && n <= 0 && r <= 0)
                            return void (n && (t._zTime = n))
                    } else if (S && A && !C)
                        if (n && (x = !1),
                        s = Ke({
                            overwrite: !1,
                            data: "isFromStart",
                            lazy: x && !C && le(b),
                            immediateRender: x,
                            stagger: 0,
                            parent: R
                        }, i),
                        m && (s[d.prop] = m),
                        rt(t._startAt = Tn.set(P, s)),
                        t._startAt._dp = 0,
                        t._startAt._sat = t,
                        n < 0 && (D ? t._startAt.revert(Ce) : t._startAt.render(-1, !0)),
                        t._zTime = n,
                        x) {
                            if (!n)
                                return
                        } else
                            e(t._startAt, K, K);
                    for (t._pt = t._ptCache = 0,
                    b = A && le(b) || b && !A,
                    a = 0; a < P.length; a++) {
                        if (u = (l = P[a])._gsap || Fe(P)[a]._gsap,
                        t._ptLookup[a] = p = {},
                        Oe[u.id] && Le.length && Xe(),
                        f = L === P ? a : L.indexOf(l),
                        d && !1 !== (h = new d).init(l, m || i, t, f, L) && (t._pt = o = new Bn(t._pt,l,h.name,0,1,h.render,h,0,h.priority),
                        h._props.forEach((function(e) {
                            p[e] = o
                        }
                        )),
                        h.priority && (c = 1)),
                        !d || m)
                            for (s in i)
                                De[s] && (h = xn(s, i, t, f, l, L)) ? h.priority && (c = 1) : p[s] = o = yn.call(t, l, s, "get", i[s], f, L, 0, v.stringFilter);
                        t._op && t._op[a] && t.kill(l, t._op[a]),
                        I && t._pt && (gn = t,
                        N.killTweensOf(l, p, t.globalTime(n)),
                        g = !t.parent,
                        gn = 0),
                        t._pt && b && (Oe[u.id] = 1)
                    }
                    c && zn(t),
                    t._onInit && t._onInit(t)
                }
                t._onUpdate = E,
                t._initted = (!t._op || t._pt) && !g,
                M && n <= 0 && U.render($, !0, !0)
            }, En = function(e, t, n, r) {
                var i, a, s = t.ease || r || "power1.inOut";
                if (he(t))
                    a = n[e] || (n[e] = []),
                    t.forEach((function(e, n) {
                        return a.push({
                            t: n / (t.length - 1) * 100,
                            v: e,
                            e: s
                        })
                    }
                    ));
                else
                    for (i in t)
                        a = n[i] || (n[i] = []),
                        "ease" === i || a.push({
                            t: parseFloat(e),
                            v: t[i],
                            e: s
                        })
            }, Sn = function(e, t, n, r, i) {
                return ie(e) ? e.call(t, n, r, i) : re(e) && ~e.indexOf("random(") ? kt(e) : e
            }, wn = ke + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", Mn = {};
            He(wn + ",id,stagger,delay,duration,paused,scrollTrigger", (function(e) {
                return Mn[e] = 1
            }
            ));
            var Tn = function(e) {
                function t(t, n, r, i) {
                    var a;
                    "number" == typeof n && (r.duration = n,
                    n = r,
                    r = null);
                    var s, o, l, c, u, d, h, p, f = (a = e.call(this, i ? n : et(n)) || this).vars, m = f.duration, g = f.delay, v = f.immediateRender, _ = f.stagger, y = f.overwrite, x = f.keyframes, b = f.defaults, E = f.scrollTrigger, S = f.yoyoEase, w = n.parent || N, M = (he(t) || de(t) ? ae(t[0]) : "length"in n) ? [t] : Pt(t);
                    if (a._targets = M.length ? Fe(M) : we("GSAP target " + t + " not found. https://gsap.com", !q.nullTargetWarn) || [],
                    a._ptLookup = [],
                    a._overwrite = y,
                    x || _ || ue(m) || ue(g)) {
                        if (n = a.vars,
                        (s = a.timeline = new mn({
                            data: "nested",
                            defaults: b || {},
                            targets: w && "nested" === w.data ? w.vars.targets : M
                        })).kill(),
                        s.parent = s._dp = R(a),
                        s._start = 0,
                        _ || ue(m) || ue(g)) {
                            if (c = M.length,
                            h = _ && Ot(_),
                            oe(_))
                                for (u in _)
                                    ~wn.indexOf(u) && (p || (p = {}),
                                    p[u] = _[u]);
                            for (o = 0; o < c; o++)
                                (l = Qe(n, Mn)).stagger = 0,
                                S && (l.yoyoEase = S),
                                p && Ze(l, p),
                                d = M[o],
                                l.duration = +Sn(m, R(a), o, d, M),
                                l.delay = (+Sn(g, R(a), o, d, M) || 0) - a._delay,
                                !_ && 1 === c && l.delay && (a._delay = g = l.delay,
                                a._start += g,
                                l.delay = 0),
                                s.to(d, l, h ? h(o, d, M) : 0),
                                s._ease = tn.none;
                            s.duration() ? m = g = 0 : a.timeline = 0
                        } else if (x) {
                            et(Ke(s.vars.defaults, {
                                ease: "none"
                            })),
                            s._ease = ln(x.ease || n.ease || "none");
                            var T, A, C, P = 0;
                            if (he(x))
                                x.forEach((function(e) {
                                    return s.to(M, e, ">")
                                }
                                )),
                                s.duration();
                            else {
                                for (u in l = {},
                                x)
                                    "ease" === u || "easeEach" === u || En(u, x[u], l, x.easeEach);
                                for (u in l)
                                    for (T = l[u].sort((function(e, t) {
                                        return e.t - t.t
                                    }
                                    )),
                                    P = 0,
                                    o = 0; o < T.length; o++)
                                        (C = {
                                            ease: (A = T[o]).e,
                                            duration: (A.t - (o ? T[o - 1].t : 0)) / 100 * m
                                        })[u] = A.v,
                                        s.to(M, C, P),
                                        P += C.duration;
                                s.duration() < m && s.to({}, {
                                    duration: m - s.duration()
                                })
                            }
                        }
                        m || a.duration(m = s.duration())
                    } else
                        a.timeline = 0;
                    return !0 !== y || O || (gn = R(a),
                    N.killTweensOf(M),
                    gn = 0),
                    pt(w, R(a), r),
                    n.reversed && a.reverse(),
                    n.paused && a.paused(!0),
                    (v || !m && !x && a._start === Ve(w._time) && le(v) && st(R(a)) && "nested" !== w.data) && (a._tTime = -1e-8,
                    a.render(Math.max(0, -g) || 0)),
                    E && ft(R(a), E),
                    a
                }
                L(t, e);
                var n = t.prototype;
                return n.render = function(e, t, n) {
                    var r, i, a, s, o, l, c, u, d, h = this._time, p = this._tDur, f = this._dur, m = e < 0, g = e > p - K && !m ? p : e < K ? 0 : e;
                    if (f) {
                        if (g !== this._tTime || !e || n || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== m) {
                            if (r = g,
                            u = this.timeline,
                            this._repeat) {
                                if (s = f + this._rDelay,
                                this._repeat < -1 && m)
                                    return this.totalTime(100 * s + e, t, n);
                                if (r = Ve(g % s),
                                g === p ? (a = this._repeat,
                                r = f) : ((a = ~~(g / s)) && a === Ve(g / s) && (r = f,
                                a--),
                                r > f && (r = f)),
                                (l = this._yoyo && 1 & a) && (d = this._yEase,
                                r = f - r),
                                o = lt(this._tTime, s),
                                r === h && !n && this._initted && a === o)
                                    return this._tTime = g,
                                    this;
                                a !== o && (u && this._yEase && on(u, l),
                                this.vars.repeatRefresh && !l && !this._lock && this._time !== s && this._initted && (this._lock = n = 1,
                                this.render(Ve(s * a), !0).invalidate()._lock = 0))
                            }
                            if (!this._initted) {
                                if (mt(this, m ? e : r, n, t, g))
                                    return this._tTime = 0,
                                    this;
                                if (!(h === this._time || n && this.vars.repeatRefresh && a !== o))
                                    return this;
                                if (f !== this._dur)
                                    return this.render(e, t, n)
                            }
                            if (this._tTime = g,
                            this._time = r,
                            !this._act && this._ts && (this._act = 1,
                            this._lazy = 0),
                            this.ratio = c = (d || this._ease)(r / f),
                            this._from && (this.ratio = c = 1 - c),
                            r && !h && !t && !a && (Bt(this, "onStart"),
                            this._tTime !== g))
                                return this;
                            for (i = this._pt; i; )
                                i.r(c, i.d),
                                i = i._next;
                            u && u.render(e < 0 ? e : u._dur * u._ease(r / this._dur), t, n) || this._startAt && (this._zTime = e),
                            this._onUpdate && !t && (m && at(this, e, 0, n),
                            Bt(this, "onUpdate")),
                            this._repeat && a !== o && this.vars.onRepeat && !t && this.parent && Bt(this, "onRepeat"),
                            g !== this._tDur && g || this._tTime !== g || (m && !this._onUpdate && at(this, e, 0, !0),
                            (e || !f) && (g === this._tDur && this._ts > 0 || !g && this._ts < 0) && rt(this, 1),
                            t || m && !h || !(g || h || l) || (Bt(this, g === p ? "onComplete" : "onReverseComplete", !0),
                            this._prom && !(g < p && this.timeScale() > 0) && this._prom()))
                        }
                    } else
                        !function(e, t, n, r) {
                            var i, a, s, o = e.ratio, l = t < 0 || !t && (!e._start && gt(e) && (e._initted || !vt(e)) || (e._ts < 0 || e._dp._ts < 0) && !vt(e)) ? 0 : 1, c = e._rDelay, u = 0;
                            if (c && e._repeat && (u = wt(0, e._tDur, t),
                            a = lt(u, c),
                            e._yoyo && 1 & a && (l = 1 - l),
                            a !== lt(e._tTime, c) && (o = 1 - l,
                            e.vars.repeatRefresh && e._initted && e.invalidate())),
                            l !== o || D || r || e._zTime === K || !t && e._zTime) {
                                if (!e._initted && mt(e, t, r, n, u))
                                    return;
                                for (s = e._zTime,
                                e._zTime = t || (n ? K : 0),
                                n || (n = t && !s),
                                e.ratio = l,
                                e._from && (l = 1 - l),
                                e._time = 0,
                                e._tTime = u,
                                i = e._pt; i; )
                                    i.r(l, i.d),
                                    i = i._next;
                                t < 0 && at(e, t, 0, !0),
                                e._onUpdate && !n && Bt(e, "onUpdate"),
                                u && e._repeat && !n && e.parent && Bt(e, "onRepeat"),
                                (t >= e._tDur || t < 0) && e.ratio === l && (l && rt(e, 1),
                                n || D || (Bt(e, l ? "onComplete" : "onReverseComplete", !0),
                                e._prom && e._prom()))
                            } else
                                e._zTime || (e._zTime = t)
                        }(this, e, t, n);
                    return this
                }
                ,
                n.targets = function() {
                    return this._targets
                }
                ,
                n.invalidate = function(t) {
                    return (!t || !this.vars.runBackwards) && (this._startAt = 0),
                    this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0,
                    this._ptLookup = [],
                    this.timeline && this.timeline.invalidate(t),
                    e.prototype.invalidate.call(this, t)
                }
                ,
                n.resetTo = function(e, t, n, r, i) {
                    G || Qt.wake(),
                    this._ts || this.play();
                    var a = Math.min(this._dur, (this._dp._time - this._start) * this._ts);
                    return this._initted || bn(this, a),
                    function(e, t, n, r, i, a, s, o) {
                        var l, c, u, d, h = (e._pt && e._ptCache || (e._ptCache = {}))[t];
                        if (!h)
                            for (h = e._ptCache[t] = [],
                            u = e._ptLookup,
                            d = e._targets.length; d--; ) {
                                if ((l = u[d][t]) && l.d && l.d._pt)
                                    for (l = l.d._pt; l && l.p !== t && l.fp !== t; )
                                        l = l._next;
                                if (!l)
                                    return vn = 1,
                                    e.vars[t] = "+=0",
                                    bn(e, s),
                                    vn = 0,
                                    o ? we(t + " not eligible for reset") : 1;
                                h.push(l)
                            }
                        for (d = h.length; d--; )
                            (l = (c = h[d])._pt || c).s = !r && 0 !== r || i ? l.s + (r || 0) + a * l.c : r,
                            l.c = n - l.s,
                            c.e && (c.e = Ge(n) + Mt(c.e)),
                            c.b && (c.b = l.s + Mt(c.b))
                    }(this, e, t, n, r, this._ease(a / this._dur), a, i) ? this.resetTo(e, t, n, r, 1) : (dt(this, 0),
                    this.parent || tt(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0),
                    this.render(0))
                }
                ,
                n.kill = function(e, t) {
                    if (void 0 === t && (t = "all"),
                    !(e || t && "all" !== t))
                        return this._lazy = this._pt = 0,
                        this.parent ? Ht(this) : this;
                    if (this.timeline) {
                        var n = this.timeline.totalDuration();
                        return this.timeline.killTweensOf(e, t, gn && !0 !== gn.vars.overwrite)._first || Ht(this),
                        this.parent && n !== this.timeline.totalDuration() && _t(this, this._dur * this.timeline._tDur / n, 0, 1),
                        this
                    }
                    var r, i, a, s, o, l, c, u = this._targets, d = e ? Pt(e) : u, h = this._ptLookup, p = this._pt;
                    if ((!t || "all" === t) && function(e, t) {
                        for (var n = e.length, r = n === t.length; r && n-- && e[n] === t[n]; )
                            ;
                        return n < 0
                    }(u, d))
                        return "all" === t && (this._pt = 0),
                        Ht(this);
                    for (r = this._op = this._op || [],
                    "all" !== t && (re(t) && (o = {},
                    He(t, (function(e) {
                        return o[e] = 1
                    }
                    )),
                    t = o),
                    t = function(e, t) {
                        var n, r, i, a, s = e[0] ? ze(e[0]).harness : 0, o = s && s.aliases;
                        if (!o)
                            return t;
                        for (r in n = Ze({}, t),
                        o)
                            if (r in n)
                                for (i = (a = o[r].split(",")).length; i--; )
                                    n[a[i]] = n[r];
                        return n
                    }(u, t)),
                    c = u.length; c--; )
                        if (~d.indexOf(u[c]))
                            for (o in i = h[c],
                            "all" === t ? (r[c] = t,
                            s = i,
                            a = {}) : (a = r[c] = r[c] || {},
                            s = t),
                            s)
                                (l = i && i[o]) && ("kill"in l.d && !0 !== l.d.kill(o) || nt(this, l, "_pt"),
                                delete i[o]),
                                "all" !== a && (a[o] = 1);
                    return this._initted && !this._pt && p && Ht(this),
                    this
                }
                ,
                t.to = function(e, n) {
                    return new t(e,n,arguments[2])
                }
                ,
                t.from = function(e, t) {
                    return Et(1, arguments)
                }
                ,
                t.delayedCall = function(e, n, r, i) {
                    return new t(n,0,{
                        immediateRender: !1,
                        lazy: !1,
                        overwrite: !1,
                        delay: e,
                        onComplete: n,
                        onReverseComplete: n,
                        onCompleteParams: r,
                        onReverseCompleteParams: r,
                        callbackScope: i
                    })
                }
                ,
                t.fromTo = function(e, t, n) {
                    return Et(2, arguments)
                }
                ,
                t.set = function(e, n) {
                    return n.duration = 0,
                    n.repeatDelay || (n.repeat = 0),
                    new t(e,n)
                }
                ,
                t.killTweensOf = function(e, t, n) {
                    return N.killTweensOf(e, t, n)
                }
                ,
                t
            }(fn);
            Ke(Tn.prototype, {
                _targets: [],
                _lazy: 0,
                _startAt: 0,
                _op: 0,
                _onInit: 0
            }),
            He("staggerTo,staggerFrom,staggerFromTo", (function(e) {
                Tn[e] = function() {
                    var t = new mn
                      , n = Tt.call(arguments, 0);
                    return n.splice("staggerFromTo" === e ? 5 : 4, 0, 0),
                    t[e].apply(t, n)
                }
            }
            ));
            var An = function(e, t, n) {
                return e[t] = n
            }
              , Cn = function(e, t, n) {
                return e[t](n)
            }
              , Pn = function(e, t, n, r) {
                return e[t](r.fp, n)
            }
              , Rn = function(e, t, n) {
                return e.setAttribute(t, n)
            }
              , Ln = function(e, t) {
                return ie(e[t]) ? Cn : se(e[t]) && e.setAttribute ? Rn : An
            }
              , On = function(e, t) {
                return t.set(t.t, t.p, Math.round(1e6 * (t.s + t.c * e)) / 1e6, t)
            }
              , Dn = function(e, t) {
                return t.set(t.t, t.p, !!(t.s + t.c * e), t)
            }
              , In = function(e, t) {
                var n = t._pt
                  , r = "";
                if (!e && t.b)
                    r = t.b;
                else if (1 === e && t.e)
                    r = t.e;
                else {
                    for (; n; )
                        r = n.p + (n.m ? n.m(n.s + n.c * e) : Math.round(1e4 * (n.s + n.c * e)) / 1e4) + r,
                        n = n._next;
                    r += t.c
                }
                t.set(t.t, t.p, r, t)
            }
              , Nn = function(e, t) {
                for (var n = t._pt; n; )
                    n.r(e, n.d),
                    n = n._next
            }
              , Un = function(e, t, n, r) {
                for (var i, a = this._pt; a; )
                    i = a._next,
                    a.p === r && a.modifier(e, t, n),
                    a = i
            }
              , kn = function(e) {
                for (var t, n, r = this._pt; r; )
                    n = r._next,
                    r.p === e && !r.op || r.op === e ? nt(this, r, "_pt") : r.dep || (t = 1),
                    r = n;
                return !t
            }
              , Fn = function(e, t, n, r) {
                r.mSet(e, t, r.m.call(r.tween, n, r.mt), r)
            }
              , zn = function(e) {
                for (var t, n, r, i, a = e._pt; a; ) {
                    for (t = a._next,
                    n = r; n && n.pr > a.pr; )
                        n = n._next;
                    (a._prev = n ? n._prev : i) ? a._prev._next = a : r = a,
                    (a._next = n) ? n._prev = a : i = a,
                    a = t
                }
                e._pt = r
            }
              , Bn = function() {
                function e(e, t, n, r, i, a, s, o, l) {
                    this.t = t,
                    this.s = r,
                    this.c = i,
                    this.p = n,
                    this.r = a || On,
                    this.d = s || this,
                    this.set = o || An,
                    this.pr = l || 0,
                    this._next = e,
                    e && (e._prev = this)
                }
                return e.prototype.modifier = function(e, t, n) {
                    this.mSet = this.mSet || this.set,
                    this.set = Fn,
                    this.m = e,
                    this.mt = n,
                    this.tween = t
                }
                ,
                e
            }();
            He(ke + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function(e) {
                return Re[e] = 1
            }
            )),
            xe.TweenMax = xe.TweenLite = Tn,
            xe.TimelineLite = xe.TimelineMax = mn,
            N = new mn({
                sortChildren: !1,
                defaults: Y,
                autoRemoveChildren: !0,
                id: "root",
                smoothChildTiming: !0
            }),
            q.stringFilter = Jt;
            var Hn = []
              , Gn = {}
              , Vn = []
              , Wn = 0
              , jn = 0
              , Xn = function(e) {
                return (Gn[e] || Vn).map((function(e) {
                    return e()
                }
                ))
            }
              , qn = function() {
                var e = Date.now()
                  , t = [];
                e - Wn > 2 && (Xn("matchMediaInit"),
                Hn.forEach((function(e) {
                    var n, r, i, a, s = e.queries, o = e.conditions;
                    for (r in s)
                        (n = U.matchMedia(s[r]).matches) && (i = 1),
                        n !== o[r] && (o[r] = n,
                        a = 1);
                    a && (e.revert(),
                    i && t.push(e))
                }
                )),
                Xn("matchMediaRevert"),
                t.forEach((function(e) {
                    return e.onMatch(e, (function(t) {
                        return e.add(null, t)
                    }
                    ))
                }
                )),
                Wn = e,
                Xn("matchMedia"))
            }
              , Yn = function() {
                function e(e, t) {
                    this.selector = t && Rt(t),
                    this.data = [],
                    this._r = [],
                    this.isReverted = !1,
                    this.id = jn++,
                    e && this.add(e)
                }
                var t = e.prototype;
                return t.add = function(e, t, n) {
                    ie(e) && (n = t,
                    t = e,
                    e = ie);
                    var r = this
                      , i = function() {
                        var e, i = I, a = r.selector;
                        return i && i !== r && i.data.push(r),
                        n && (r.selector = Rt(n)),
                        I = r,
                        e = t.apply(r, arguments),
                        ie(e) && r._r.push(e),
                        I = i,
                        r.selector = a,
                        r.isReverted = !1,
                        e
                    };
                    return r.last = i,
                    e === ie ? i(r, (function(e) {
                        return r.add(null, e)
                    }
                    )) : e ? r[e] = i : i
                }
                ,
                t.ignore = function(e) {
                    var t = I;
                    I = null,
                    e(this),
                    I = t
                }
                ,
                t.getTweens = function() {
                    var t = [];
                    return this.data.forEach((function(n) {
                        return n instanceof e ? t.push.apply(t, n.getTweens()) : n instanceof Tn && !(n.parent && "nested" === n.parent.data) && t.push(n)
                    }
                    )),
                    t
                }
                ,
                t.clear = function() {
                    this._r.length = this.data.length = 0
                }
                ,
                t.kill = function(e, t) {
                    var n = this;
                    if (e ? function() {
                        for (var t, r = n.getTweens(), i = n.data.length; i--; )
                            "isFlip" === (t = n.data[i]).data && (t.revert(),
                            t.getChildren(!0, !0, !1).forEach((function(e) {
                                return r.splice(r.indexOf(e), 1)
                            }
                            )));
                        for (r.map((function(e) {
                            return {
                                g: e._dur || e._delay || e._sat && !e._sat.vars.immediateRender ? e.globalTime(0) : -1 / 0,
                                t: e
                            }
                        }
                        )).sort((function(e, t) {
                            return t.g - e.g || -1 / 0
                        }
                        )).forEach((function(t) {
                            return t.t.revert(e)
                        }
                        )),
                        i = n.data.length; i--; )
                            (t = n.data[i])instanceof mn ? "nested" !== t.data && (t.scrollTrigger && t.scrollTrigger.revert(),
                            t.kill()) : !(t instanceof Tn) && t.revert && t.revert(e);
                        n._r.forEach((function(t) {
                            return t(e, n)
                        }
                        )),
                        n.isReverted = !0
                    }() : this.data.forEach((function(e) {
                        return e.kill && e.kill()
                    }
                    )),
                    this.clear(),
                    t)
                        for (var r = Hn.length; r--; )
                            Hn[r].id === this.id && Hn.splice(r, 1)
                }
                ,
                t.revert = function(e) {
                    this.kill(e || {})
                }
                ,
                e
            }()
              , $n = function() {
                function e(e) {
                    this.contexts = [],
                    this.scope = e,
                    I && I.data.push(this)
                }
                var t = e.prototype;
                return t.add = function(e, t, n) {
                    oe(e) || (e = {
                        matches: e
                    });
                    var r, i, a, s = new Yn(0,n || this.scope), o = s.conditions = {};
                    for (i in I && !s.selector && (s.selector = I.selector),
                    this.contexts.push(s),
                    t = s.add("onMatch", t),
                    s.queries = e,
                    e)
                        "all" === i ? a = 1 : (r = U.matchMedia(e[i])) && (Hn.indexOf(s) < 0 && Hn.push(s),
                        (o[i] = r.matches) && (a = 1),
                        r.addListener ? r.addListener(qn) : r.addEventListener("change", qn));
                    return a && t(s, (function(e) {
                        return s.add(null, e)
                    }
                    )),
                    this
                }
                ,
                t.revert = function(e) {
                    this.kill(e || {})
                }
                ,
                t.kill = function(e) {
                    this.contexts.forEach((function(t) {
                        return t.kill(e, !0)
                    }
                    ))
                }
                ,
                e
            }()
              , Kn = {
                registerPlugin: function() {
                    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                        t[n] = arguments[n];
                    t.forEach((function(e) {
                        return Vt(e)
                    }
                    ))
                },
                timeline: function(e) {
                    return new mn(e)
                },
                getTweensOf: function(e, t) {
                    return N.getTweensOf(e, t)
                },
                getProperty: function(e, t, n, r) {
                    re(e) && (e = Pt(e)[0]);
                    var i = ze(e || {}).get
                      , a = n ? $e : Ye;
                    return "native" === n && (n = ""),
                    e ? t ? a((De[t] && De[t].get || i)(e, t, n, r)) : function(t, n, r) {
                        return a((De[t] && De[t].get || i)(e, t, n, r))
                    }
                    : e
                },
                quickSetter: function(e, t, n) {
                    if ((e = Pt(e)).length > 1) {
                        var r = e.map((function(e) {
                            return Qn.quickSetter(e, t, n)
                        }
                        ))
                          , i = r.length;
                        return function(e) {
                            for (var t = i; t--; )
                                r[t](e)
                        }
                    }
                    e = e[0] || {};
                    var a = De[t]
                      , s = ze(e)
                      , o = s.harness && (s.harness.aliases || {})[t] || t
                      , l = a ? function(t) {
                        var r = new a;
                        H._pt = 0,
                        r.init(e, n ? t + n : t, H, 0, [e]),
                        r.render(1, r),
                        H._pt && Nn(1, H)
                    }
                    : s.set(e, o);
                    return a ? l : function(t) {
                        return l(e, o, n ? t + n : t, s, 1)
                    }
                },
                quickTo: function(e, t, n) {
                    var r, i = Qn.to(e, Ze(((r = {})[t] = "+=0.1",
                    r.paused = !0,
                    r), n || {})), a = function(e, n, r) {
                        return i.resetTo(t, e, n, r)
                    };
                    return a.tween = i,
                    a
                },
                isTweening: function(e) {
                    return N.getTweensOf(e, !0).length > 0
                },
                defaults: function(e) {
                    return e && e.ease && (e.ease = ln(e.ease, Y.ease)),
                    Je(Y, e || {})
                },
                config: function(e) {
                    return Je(q, e || {})
                },
                registerEffect: function(e) {
                    var t = e.name
                      , n = e.effect
                      , r = e.plugins
                      , i = e.defaults
                      , a = e.extendTimeline;
                    (r || "").split(",").forEach((function(e) {
                        return e && !De[e] && !xe[e] && we(t + " effect requires " + e + " plugin.")
                    }
                    )),
                    Ie[t] = function(e, t, r) {
                        return n(Pt(e), Ke(t || {}, i), r)
                    }
                    ,
                    a && (mn.prototype[t] = function(e, n, r) {
                        return this.add(Ie[t](e, oe(n) ? n : (r = n) && {}, this), r)
                    }
                    )
                },
                registerEase: function(e, t) {
                    tn[e] = ln(t)
                },
                parseEase: function(e, t) {
                    return arguments.length ? ln(e, t) : tn
                },
                getById: function(e) {
                    return N.getById(e)
                },
                exportRoot: function(e, t) {
                    void 0 === e && (e = {});
                    var n, r, i = new mn(e);
                    for (i.smoothChildTiming = le(e.smoothChildTiming),
                    N.remove(i),
                    i._dp = 0,
                    i._time = i._tTime = N._time,
                    n = N._first; n; )
                        r = n._next,
                        !t && !n._dur && n instanceof Tn && n.vars.onComplete === n._targets[0] || pt(i, n, n._start - n._delay),
                        n = r;
                    return pt(N, i, 0),
                    i
                },
                context: function(e, t) {
                    return e ? new Yn(e,t) : I
                },
                matchMedia: function(e) {
                    return new $n(e)
                },
                matchMediaRefresh: function() {
                    return Hn.forEach((function(e) {
                        var t, n, r = e.conditions;
                        for (n in r)
                            r[n] && (r[n] = !1,
                            t = 1);
                        t && e.revert()
                    }
                    )) || qn()
                },
                addEventListener: function(e, t) {
                    var n = Gn[e] || (Gn[e] = []);
                    ~n.indexOf(t) || n.push(t)
                },
                removeEventListener: function(e, t) {
                    var n = Gn[e]
                      , r = n && n.indexOf(t);
                    r >= 0 && n.splice(r, 1)
                },
                utils: {
                    wrap: function e(t, n, r) {
                        var i = n - t;
                        return he(t) ? Ut(t, e(0, t.length), n) : St(r, (function(e) {
                            return (i + (e - t) % i) % i + t
                        }
                        ))
                    },
                    wrapYoyo: function e(t, n, r) {
                        var i = n - t
                          , a = 2 * i;
                        return he(t) ? Ut(t, e(0, t.length - 1), n) : St(r, (function(e) {
                            return t + ((e = (a + (e - t) % a) % a || 0) > i ? a - e : e)
                        }
                        ))
                    },
                    distribute: Ot,
                    random: Nt,
                    snap: It,
                    normalize: function(e, t, n) {
                        return Ft(e, t, 0, 1, n)
                    },
                    getUnit: Mt,
                    clamp: function(e, t, n) {
                        return St(n, (function(n) {
                            return wt(e, t, n)
                        }
                        ))
                    },
                    splitColor: qt,
                    toArray: Pt,
                    selector: Rt,
                    mapRange: Ft,
                    pipe: function() {
                        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                            t[n] = arguments[n];
                        return function(e) {
                            return t.reduce((function(e, t) {
                                return t(e)
                            }
                            ), e)
                        }
                    },
                    unitize: function(e, t) {
                        return function(n) {
                            return e(parseFloat(n)) + (t || Mt(n))
                        }
                    },
                    interpolate: function e(t, n, r, i) {
                        var a = isNaN(t + n) ? 0 : function(e) {
                            return (1 - e) * t + e * n
                        }
                        ;
                        if (!a) {
                            var s, o, l, c, u, d = re(t), h = {};
                            if (!0 === r && (i = 1) && (r = null),
                            d)
                                t = {
                                    p: t
                                },
                                n = {
                                    p: n
                                };
                            else if (he(t) && !he(n)) {
                                for (l = [],
                                c = t.length,
                                u = c - 2,
                                o = 1; o < c; o++)
                                    l.push(e(t[o - 1], t[o]));
                                c--,
                                a = function(e) {
                                    e *= c;
                                    var t = Math.min(u, ~~e);
                                    return l[t](e - t)
                                }
                                ,
                                r = n
                            } else
                                i || (t = Ze(he(t) ? [] : {}, t));
                            if (!l) {
                                for (s in n)
                                    yn.call(h, t, s, "get", n[s]);
                                a = function(e) {
                                    return Nn(e, h) || (d ? t.p : t)
                                }
                            }
                        }
                        return St(r, a)
                    },
                    shuffle: Lt
                },
                install: Ee,
                effects: Ie,
                ticker: Qt,
                updateRoot: mn.updateRoot,
                plugins: De,
                globalTimeline: N,
                core: {
                    PropTween: Bn,
                    globals: Me,
                    Tween: Tn,
                    Timeline: mn,
                    Animation: fn,
                    getCache: ze,
                    _removeLinkedListItem: nt,
                    reverting: function() {
                        return D
                    },
                    context: function(e) {
                        return e && I && (I.data.push(e),
                        e._ctx = I),
                        I
                    },
                    suppressOverwrites: function(e) {
                        return O = e
                    }
                }
            };
            He("to,from,fromTo,delayedCall,set,killTweensOf", (function(e) {
                return Kn[e] = Tn[e]
            }
            )),
            Qt.add(mn.updateRoot),
            H = Kn.to({}, {
                duration: 0
            });
            var Zn = function(e, t) {
                for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t; )
                    n = n._next;
                return n
            }
              , Jn = function(e, t) {
                return {
                    name: e,
                    rawVars: 1,
                    init: function(e, n, r) {
                        r._onInit = function(e) {
                            var r, i;
                            if (re(n) && (r = {},
                            He(n, (function(e) {
                                return r[e] = 1
                            }
                            )),
                            n = r),
                            t) {
                                for (i in r = {},
                                n)
                                    r[i] = t(n[i]);
                                n = r
                            }
                            !function(e, t) {
                                var n, r, i, a = e._targets;
                                for (n in t)
                                    for (r = a.length; r--; )
                                        (i = e._ptLookup[r][n]) && (i = i.d) && (i._pt && (i = Zn(i, n)),
                                        i && i.modifier && i.modifier(t[n], e, a[r], n))
                            }(e, n)
                        }
                    }
                }
            }
              , Qn = Kn.registerPlugin({
                name: "attr",
                init: function(e, t, n, r, i) {
                    var a, s, o;
                    for (a in this.tween = n,
                    t)
                        o = e.getAttribute(a) || "",
                        (s = this.add(e, "setAttribute", (o || 0) + "", t[a], r, i, 0, 0, a)).op = a,
                        s.b = o,
                        this._props.push(a)
                },
                render: function(e, t) {
                    for (var n = t._pt; n; )
                        D ? n.set(n.t, n.p, n.b, n) : n.r(e, n.d),
                        n = n._next
                }
            }, {
                name: "endArray",
                init: function(e, t) {
                    for (var n = t.length; n--; )
                        this.add(e, n, e[n] || 0, t[n], 0, 0, 0, 0, 0, 1)
                }
            }, Jn("roundProps", Dt), Jn("modifiers"), Jn("snap", It)) || Kn;
            Tn.version = mn.version = Qn.version = "3.12.5",
            z = 1,
            ce() && en();
            tn.Power0,
            tn.Power1;
            var er, tr, nr, rr, ir, ar, sr, or, lr = tn.Power2, cr = (tn.Power3,
            tn.Power4), ur = (tn.Linear,
            tn.Quad,
            tn.Cubic,
            tn.Quart,
            tn.Quint,
            tn.Strong,
            tn.Elastic,
            tn.Back,
            tn.SteppedEase,
            tn.Bounce,
            tn.Sine,
            tn.Expo,
            tn.Circ,
            {}), dr = 180 / Math.PI, hr = Math.PI / 180, pr = Math.atan2, fr = /([A-Z])/g, mr = /(left|right|width|margin|padding|x)/i, gr = /[\s,\(]\S/, vr = {
                autoAlpha: "opacity,visibility",
                scale: "scaleX,scaleY",
                alpha: "opacity"
            }, _r = function(e, t) {
                return t.set(t.t, t.p, Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u, t)
            }, yr = function(e, t) {
                return t.set(t.t, t.p, 1 === e ? t.e : Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u, t)
            }, xr = function(e, t) {
                return t.set(t.t, t.p, e ? Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u : t.b, t)
            }, br = function(e, t) {
                var n = t.s + t.c * e;
                t.set(t.t, t.p, ~~(n + (n < 0 ? -.5 : .5)) + t.u, t)
            }, Er = function(e, t) {
                return t.set(t.t, t.p, e ? t.e : t.b, t)
            }, Sr = function(e, t) {
                return t.set(t.t, t.p, 1 !== e ? t.b : t.e, t)
            }, wr = function(e, t, n) {
                return e.style[t] = n
            }, Mr = function(e, t, n) {
                return e.style.setProperty(t, n)
            }, Tr = function(e, t, n) {
                return e._gsap[t] = n
            }, Ar = function(e, t, n) {
                return e._gsap.scaleX = e._gsap.scaleY = n
            }, Cr = function(e, t, n, r, i) {
                var a = e._gsap;
                a.scaleX = a.scaleY = n,
                a.renderTransform(i, a)
            }, Pr = function(e, t, n, r, i) {
                var a = e._gsap;
                a[t] = n,
                a.renderTransform(i, a)
            }, Rr = "transform", Lr = Rr + "Origin", Or = function e(t, n) {
                var r = this
                  , i = this.target
                  , a = i.style
                  , s = i._gsap;
                if (t in ur && a) {
                    if (this.tfm = this.tfm || {},
                    "transform" === t)
                        return vr.transform.split(",").forEach((function(t) {
                            return e.call(r, t, n)
                        }
                        ));
                    if (~(t = vr[t] || t).indexOf(",") ? t.split(",").forEach((function(e) {
                        return r.tfm[e] = Kr(i, e)
                    }
                    )) : this.tfm[t] = s.x ? s[t] : Kr(i, t),
                    t === Lr && (this.tfm.zOrigin = s.zOrigin),
                    this.props.indexOf(Rr) >= 0)
                        return;
                    s.svg && (this.svgo = i.getAttribute("data-svg-origin"),
                    this.props.push(Lr, n, "")),
                    t = Rr
                }
                (a || n) && this.props.push(t, n, a[t])
            }, Dr = function(e) {
                e.translate && (e.removeProperty("translate"),
                e.removeProperty("scale"),
                e.removeProperty("rotate"))
            }, Ir = function() {
                var e, t, n = this.props, r = this.target, i = r.style, a = r._gsap;
                for (e = 0; e < n.length; e += 3)
                    n[e + 1] ? r[n[e]] = n[e + 2] : n[e + 2] ? i[n[e]] = n[e + 2] : i.removeProperty("--" === n[e].substr(0, 2) ? n[e] : n[e].replace(fr, "-$1").toLowerCase());
                if (this.tfm) {
                    for (t in this.tfm)
                        a[t] = this.tfm[t];
                    a.svg && (a.renderTransform(),
                    r.setAttribute("data-svg-origin", this.svgo || "")),
                    (e = sr()) && e.isStart || i[Rr] || (Dr(i),
                    a.zOrigin && i[Lr] && (i[Lr] += " " + a.zOrigin + "px",
                    a.zOrigin = 0,
                    a.renderTransform()),
                    a.uncache = 1)
                }
            }, Nr = function(e, t) {
                var n = {
                    target: e,
                    props: [],
                    revert: Ir,
                    save: Or
                };
                return e._gsap || Qn.core.getCache(e),
                t && t.split(",").forEach((function(e) {
                    return n.save(e)
                }
                )),
                n
            }, Ur = function(e, t) {
                var n = tr.createElementNS ? tr.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : tr.createElement(e);
                return n && n.style ? n : tr.createElement(e)
            }, kr = function e(t, n, r) {
                var i = getComputedStyle(t);
                return i[n] || i.getPropertyValue(n.replace(fr, "-$1").toLowerCase()) || i.getPropertyValue(n) || !r && e(t, zr(n) || n, 1) || ""
            }, Fr = "O,Moz,ms,Ms,Webkit".split(","), zr = function(e, t, n) {
                var r = (t || ir).style
                  , i = 5;
                if (e in r && !n)
                    return e;
                for (e = e.charAt(0).toUpperCase() + e.substr(1); i-- && !(Fr[i] + e in r); )
                    ;
                return i < 0 ? null : (3 === i ? "ms" : i >= 0 ? Fr[i] : "") + e
            }, Br = function() {
                "undefined" != typeof window && window.document && (er = window,
                tr = er.document,
                nr = tr.documentElement,
                ir = Ur("div") || {
                    style: {}
                },
                Ur("div"),
                Rr = zr(Rr),
                Lr = Rr + "Origin",
                ir.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0",
                or = !!zr("perspective"),
                sr = Qn.core.reverting,
                rr = 1)
            }, Hr = function e(t) {
                var n, r = Ur("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), i = this.parentNode, a = this.nextSibling, s = this.style.cssText;
                if (nr.appendChild(r),
                r.appendChild(this),
                this.style.display = "block",
                t)
                    try {
                        n = this.getBBox(),
                        this._gsapBBox = this.getBBox,
                        this.getBBox = e
                    } catch (e) {}
                else
                    this._gsapBBox && (n = this._gsapBBox());
                return i && (a ? i.insertBefore(this, a) : i.appendChild(this)),
                nr.removeChild(r),
                this.style.cssText = s,
                n
            }, Gr = function(e, t) {
                for (var n = t.length; n--; )
                    if (e.hasAttribute(t[n]))
                        return e.getAttribute(t[n])
            }, Vr = function(e) {
                var t;
                try {
                    t = e.getBBox()
                } catch (n) {
                    t = Hr.call(e, !0)
                }
                return t && (t.width || t.height) || e.getBBox === Hr || (t = Hr.call(e, !0)),
                !t || t.width || t.x || t.y ? t : {
                    x: +Gr(e, ["x", "cx", "x1"]) || 0,
                    y: +Gr(e, ["y", "cy", "y1"]) || 0,
                    width: 0,
                    height: 0
                }
            }, Wr = function(e) {
                return !(!e.getCTM || e.parentNode && !e.ownerSVGElement || !Vr(e))
            }, jr = function(e, t) {
                if (t) {
                    var n, r = e.style;
                    t in ur && t !== Lr && (t = Rr),
                    r.removeProperty ? ("ms" !== (n = t.substr(0, 2)) && "webkit" !== t.substr(0, 6) || (t = "-" + t),
                    r.removeProperty("--" === n ? t : t.replace(fr, "-$1").toLowerCase())) : r.removeAttribute(t)
                }
            }, Xr = function(e, t, n, r, i, a) {
                var s = new Bn(e._pt,t,n,0,1,a ? Sr : Er);
                return e._pt = s,
                s.b = r,
                s.e = i,
                e._props.push(n),
                s
            }, qr = {
                deg: 1,
                rad: 1,
                turn: 1
            }, Yr = {
                grid: 1,
                flex: 1
            }, $r = function e(t, n, r, i) {
                var a, s, o, l, c = parseFloat(r) || 0, u = (r + "").trim().substr((c + "").length) || "px", d = ir.style, h = mr.test(n), p = "svg" === t.tagName.toLowerCase(), f = (p ? "client" : "offset") + (h ? "Width" : "Height"), m = 100, g = "px" === i, v = "%" === i;
                if (i === u || !c || qr[i] || qr[u])
                    return c;
                if ("px" !== u && !g && (c = e(t, n, r, "px")),
                l = t.getCTM && Wr(t),
                (v || "%" === u) && (ur[n] || ~n.indexOf("adius")))
                    return a = l ? t.getBBox()[h ? "width" : "height"] : t[f],
                    Ge(v ? c / a * m : c / 100 * a);
                if (d[h ? "width" : "height"] = m + (g ? u : i),
                s = ~n.indexOf("adius") || "em" === i && t.appendChild && !p ? t : t.parentNode,
                l && (s = (t.ownerSVGElement || {}).parentNode),
                s && s !== tr && s.appendChild || (s = tr.body),
                (o = s._gsap) && v && o.width && h && o.time === Qt.time && !o.uncache)
                    return Ge(c / o.width * m);
                if (!v || "height" !== n && "width" !== n)
                    (v || "%" === u) && !Yr[kr(s, "display")] && (d.position = kr(t, "position")),
                    s === t && (d.position = "static"),
                    s.appendChild(ir),
                    a = ir[f],
                    s.removeChild(ir),
                    d.position = "absolute";
                else {
                    var _ = t.style[n];
                    t.style[n] = m + i,
                    a = t[f],
                    _ ? t.style[n] = _ : jr(t, n)
                }
                return h && v && ((o = ze(s)).time = Qt.time,
                o.width = s[f]),
                Ge(g ? a * c / m : a && c ? m / a * c : 0)
            }, Kr = function(e, t, n, r) {
                var i;
                return rr || Br(),
                t in vr && "transform" !== t && ~(t = vr[t]).indexOf(",") && (t = t.split(",")[0]),
                ur[t] && "transform" !== t ? (i = oi(e, r),
                i = "transformOrigin" !== t ? i[t] : i.svg ? i.origin : li(kr(e, Lr)) + " " + i.zOrigin + "px") : (!(i = e.style[t]) || "auto" === i || r || ~(i + "").indexOf("calc(")) && (i = ei[t] && ei[t](e, t, n) || kr(e, t) || Be(e, t) || ("opacity" === t ? 1 : 0)),
                n && !~(i + "").trim().indexOf(" ") ? $r(e, t, i, n) + n : i
            }, Zr = function(e, t, n, r) {
                if (!n || "none" === n) {
                    var i = zr(t, e, 1)
                      , a = i && kr(e, i, 1);
                    a && a !== n ? (t = i,
                    n = a) : "borderColor" === t && (n = kr(e, "borderTopColor"))
                }
                var s, o, l, c, u, d, h, p, f, m, g, v = new Bn(this._pt,e.style,t,0,1,In), _ = 0, y = 0;
                if (v.b = n,
                v.e = r,
                n += "",
                "auto" === (r += "") && (d = e.style[t],
                e.style[t] = r,
                r = kr(e, t) || r,
                d ? e.style[t] = d : jr(e, t)),
                Jt(s = [n, r]),
                r = s[1],
                l = (n = s[0]).match(me) || [],
                (r.match(me) || []).length) {
                    for (; o = me.exec(r); )
                        h = o[0],
                        f = r.substring(_, o.index),
                        u ? u = (u + 1) % 5 : "rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5) || (u = 1),
                        h !== (d = l[y++] || "") && (c = parseFloat(d) || 0,
                        g = d.substr((c + "").length),
                        "=" === h.charAt(1) && (h = We(c, h) + g),
                        p = parseFloat(h),
                        m = h.substr((p + "").length),
                        _ = me.lastIndex - m.length,
                        m || (m = m || q.units[t] || g,
                        _ === r.length && (r += m,
                        v.e += m)),
                        g !== m && (c = $r(e, t, d, m) || 0),
                        v._pt = {
                            _next: v._pt,
                            p: f || 1 === y ? f : ",",
                            s: c,
                            c: p - c,
                            m: u && u < 4 || "zIndex" === t ? Math.round : 0
                        });
                    v.c = _ < r.length ? r.substring(_, r.length) : ""
                } else
                    v.r = "display" === t && "none" === r ? Sr : Er;
                return ve.test(r) && (v.e = 0),
                this._pt = v,
                v
            }, Jr = {
                top: "0%",
                bottom: "100%",
                left: "0%",
                right: "100%",
                center: "50%"
            }, Qr = function(e, t) {
                if (t.tween && t.tween._time === t.tween._dur) {
                    var n, r, i, a = t.t, s = a.style, o = t.u, l = a._gsap;
                    if ("all" === o || !0 === o)
                        s.cssText = "",
                        r = 1;
                    else
                        for (i = (o = o.split(",")).length; --i > -1; )
                            n = o[i],
                            ur[n] && (r = 1,
                            n = "transformOrigin" === n ? Lr : Rr),
                            jr(a, n);
                    r && (jr(a, Rr),
                    l && (l.svg && a.removeAttribute("transform"),
                    oi(a, 1),
                    l.uncache = 1,
                    Dr(s)))
                }
            }, ei = {
                clearProps: function(e, t, n, r, i) {
                    if ("isFromStart" !== i.data) {
                        var a = e._pt = new Bn(e._pt,t,n,0,0,Qr);
                        return a.u = r,
                        a.pr = -10,
                        a.tween = i,
                        e._props.push(n),
                        1
                    }
                }
            }, ti = [1, 0, 0, 1, 0, 0], ni = {}, ri = function(e) {
                return "matrix(1, 0, 0, 1, 0, 0)" === e || "none" === e || !e
            }, ii = function(e) {
                var t = kr(e, Rr);
                return ri(t) ? ti : t.substr(7).match(fe).map(Ge)
            }, ai = function(e, t) {
                var n, r, i, a, s = e._gsap || ze(e), o = e.style, l = ii(e);
                return s.svg && e.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(i = e.transform.baseVal.consolidate().matrix).a, i.b, i.c, i.d, i.e, i.f]).join(",") ? ti : l : (l !== ti || e.offsetParent || e === nr || s.svg || (i = o.display,
                o.display = "block",
                (n = e.parentNode) && e.offsetParent || (a = 1,
                r = e.nextElementSibling,
                nr.appendChild(e)),
                l = ii(e),
                i ? o.display = i : jr(e, "display"),
                a && (r ? n.insertBefore(e, r) : n ? n.appendChild(e) : nr.removeChild(e))),
                t && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
            }, si = function(e, t, n, r, i, a) {
                var s, o, l, c = e._gsap, u = i || ai(e, !0), d = c.xOrigin || 0, h = c.yOrigin || 0, p = c.xOffset || 0, f = c.yOffset || 0, m = u[0], g = u[1], v = u[2], _ = u[3], y = u[4], x = u[5], b = t.split(" "), E = parseFloat(b[0]) || 0, S = parseFloat(b[1]) || 0;
                n ? u !== ti && (o = m * _ - g * v) && (l = E * (-g / o) + S * (m / o) - (m * x - g * y) / o,
                E = E * (_ / o) + S * (-v / o) + (v * x - _ * y) / o,
                S = l) : (E = (s = Vr(e)).x + (~b[0].indexOf("%") ? E / 100 * s.width : E),
                S = s.y + (~(b[1] || b[0]).indexOf("%") ? S / 100 * s.height : S)),
                r || !1 !== r && c.smooth ? (y = E - d,
                x = S - h,
                c.xOffset = p + (y * m + x * v) - y,
                c.yOffset = f + (y * g + x * _) - x) : c.xOffset = c.yOffset = 0,
                c.xOrigin = E,
                c.yOrigin = S,
                c.smooth = !!r,
                c.origin = t,
                c.originIsAbsolute = !!n,
                e.style[Lr] = "0px 0px",
                a && (Xr(a, c, "xOrigin", d, E),
                Xr(a, c, "yOrigin", h, S),
                Xr(a, c, "xOffset", p, c.xOffset),
                Xr(a, c, "yOffset", f, c.yOffset)),
                e.setAttribute("data-svg-origin", E + " " + S)
            }, oi = function(e, t) {
                var n = e._gsap || new pn(e);
                if ("x"in n && !t && !n.uncache)
                    return n;
                var r, i, a, s, o, l, c, u, d, h, p, f, m, g, v, _, y, x, b, E, S, w, M, T, A, C, P, R, L, O, D, I, N = e.style, U = n.scaleX < 0, k = "px", F = "deg", z = getComputedStyle(e), B = kr(e, Lr) || "0";
                return r = i = a = l = c = u = d = h = p = 0,
                s = o = 1,
                n.svg = !(!e.getCTM || !Wr(e)),
                z.translate && ("none" === z.translate && "none" === z.scale && "none" === z.rotate || (N[Rr] = ("none" !== z.translate ? "translate3d(" + (z.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + ("none" !== z.rotate ? "rotate(" + z.rotate + ") " : "") + ("none" !== z.scale ? "scale(" + z.scale.split(" ").join(",") + ") " : "") + ("none" !== z[Rr] ? z[Rr] : "")),
                N.scale = N.rotate = N.translate = "none"),
                g = ai(e, n.svg),
                n.svg && (n.uncache ? (A = e.getBBox(),
                B = n.xOrigin - A.x + "px " + (n.yOrigin - A.y) + "px",
                T = "") : T = !t && e.getAttribute("data-svg-origin"),
                si(e, T || B, !!T || n.originIsAbsolute, !1 !== n.smooth, g)),
                f = n.xOrigin || 0,
                m = n.yOrigin || 0,
                g !== ti && (x = g[0],
                b = g[1],
                E = g[2],
                S = g[3],
                r = w = g[4],
                i = M = g[5],
                6 === g.length ? (s = Math.sqrt(x * x + b * b),
                o = Math.sqrt(S * S + E * E),
                l = x || b ? pr(b, x) * dr : 0,
                (d = E || S ? pr(E, S) * dr + l : 0) && (o *= Math.abs(Math.cos(d * hr))),
                n.svg && (r -= f - (f * x + m * E),
                i -= m - (f * b + m * S))) : (I = g[6],
                O = g[7],
                P = g[8],
                R = g[9],
                L = g[10],
                D = g[11],
                r = g[12],
                i = g[13],
                a = g[14],
                c = (v = pr(I, L)) * dr,
                v && (T = w * (_ = Math.cos(-v)) + P * (y = Math.sin(-v)),
                A = M * _ + R * y,
                C = I * _ + L * y,
                P = w * -y + P * _,
                R = M * -y + R * _,
                L = I * -y + L * _,
                D = O * -y + D * _,
                w = T,
                M = A,
                I = C),
                u = (v = pr(-E, L)) * dr,
                v && (_ = Math.cos(-v),
                D = S * (y = Math.sin(-v)) + D * _,
                x = T = x * _ - P * y,
                b = A = b * _ - R * y,
                E = C = E * _ - L * y),
                l = (v = pr(b, x)) * dr,
                v && (T = x * (_ = Math.cos(v)) + b * (y = Math.sin(v)),
                A = w * _ + M * y,
                b = b * _ - x * y,
                M = M * _ - w * y,
                x = T,
                w = A),
                c && Math.abs(c) + Math.abs(l) > 359.9 && (c = l = 0,
                u = 180 - u),
                s = Ge(Math.sqrt(x * x + b * b + E * E)),
                o = Ge(Math.sqrt(M * M + I * I)),
                v = pr(w, M),
                d = Math.abs(v) > 2e-4 ? v * dr : 0,
                p = D ? 1 / (D < 0 ? -D : D) : 0),
                n.svg && (T = e.getAttribute("transform"),
                n.forceCSS = e.setAttribute("transform", "") || !ri(kr(e, Rr)),
                T && e.setAttribute("transform", T))),
                Math.abs(d) > 90 && Math.abs(d) < 270 && (U ? (s *= -1,
                d += l <= 0 ? 180 : -180,
                l += l <= 0 ? 180 : -180) : (o *= -1,
                d += d <= 0 ? 180 : -180)),
                t = t || n.uncache,
                n.x = r - ((n.xPercent = r && (!t && n.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-r) ? -50 : 0))) ? e.offsetWidth * n.xPercent / 100 : 0) + k,
                n.y = i - ((n.yPercent = i && (!t && n.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-i) ? -50 : 0))) ? e.offsetHeight * n.yPercent / 100 : 0) + k,
                n.z = a + k,
                n.scaleX = Ge(s),
                n.scaleY = Ge(o),
                n.rotation = Ge(l) + F,
                n.rotationX = Ge(c) + F,
                n.rotationY = Ge(u) + F,
                n.skewX = d + F,
                n.skewY = h + F,
                n.transformPerspective = p + k,
                (n.zOrigin = parseFloat(B.split(" ")[2]) || !t && n.zOrigin || 0) && (N[Lr] = li(B)),
                n.xOffset = n.yOffset = 0,
                n.force3D = q.force3D,
                n.renderTransform = n.svg ? mi : or ? fi : ui,
                n.uncache = 0,
                n
            }, li = function(e) {
                return (e = e.split(" "))[0] + " " + e[1]
            }, ci = function(e, t, n) {
                var r = Mt(t);
                return Ge(parseFloat(t) + parseFloat($r(e, "x", n + "px", r))) + r
            }, ui = function(e, t) {
                t.z = "0px",
                t.rotationY = t.rotationX = "0deg",
                t.force3D = 0,
                fi(e, t)
            }, di = "0deg", hi = "0px", pi = ") ", fi = function(e, t) {
                var n = t || this
                  , r = n.xPercent
                  , i = n.yPercent
                  , a = n.x
                  , s = n.y
                  , o = n.z
                  , l = n.rotation
                  , c = n.rotationY
                  , u = n.rotationX
                  , d = n.skewX
                  , h = n.skewY
                  , p = n.scaleX
                  , f = n.scaleY
                  , m = n.transformPerspective
                  , g = n.force3D
                  , v = n.target
                  , _ = n.zOrigin
                  , y = ""
                  , x = "auto" === g && e && 1 !== e || !0 === g;
                if (_ && (u !== di || c !== di)) {
                    var b, E = parseFloat(c) * hr, S = Math.sin(E), w = Math.cos(E);
                    E = parseFloat(u) * hr,
                    b = Math.cos(E),
                    a = ci(v, a, S * b * -_),
                    s = ci(v, s, -Math.sin(E) * -_),
                    o = ci(v, o, w * b * -_ + _)
                }
                m !== hi && (y += "perspective(" + m + pi),
                (r || i) && (y += "translate(" + r + "%, " + i + "%) "),
                (x || a !== hi || s !== hi || o !== hi) && (y += o !== hi || x ? "translate3d(" + a + ", " + s + ", " + o + ") " : "translate(" + a + ", " + s + pi),
                l !== di && (y += "rotate(" + l + pi),
                c !== di && (y += "rotateY(" + c + pi),
                u !== di && (y += "rotateX(" + u + pi),
                d === di && h === di || (y += "skew(" + d + ", " + h + pi),
                1 === p && 1 === f || (y += "scale(" + p + ", " + f + pi),
                v.style[Rr] = y || "translate(0, 0)"
            }, mi = function(e, t) {
                var n, r, i, a, s, o = t || this, l = o.xPercent, c = o.yPercent, u = o.x, d = o.y, h = o.rotation, p = o.skewX, f = o.skewY, m = o.scaleX, g = o.scaleY, v = o.target, _ = o.xOrigin, y = o.yOrigin, x = o.xOffset, b = o.yOffset, E = o.forceCSS, S = parseFloat(u), w = parseFloat(d);
                h = parseFloat(h),
                p = parseFloat(p),
                (f = parseFloat(f)) && (p += f = parseFloat(f),
                h += f),
                h || p ? (h *= hr,
                p *= hr,
                n = Math.cos(h) * m,
                r = Math.sin(h) * m,
                i = Math.sin(h - p) * -g,
                a = Math.cos(h - p) * g,
                p && (f *= hr,
                s = Math.tan(p - f),
                i *= s = Math.sqrt(1 + s * s),
                a *= s,
                f && (s = Math.tan(f),
                n *= s = Math.sqrt(1 + s * s),
                r *= s)),
                n = Ge(n),
                r = Ge(r),
                i = Ge(i),
                a = Ge(a)) : (n = m,
                a = g,
                r = i = 0),
                (S && !~(u + "").indexOf("px") || w && !~(d + "").indexOf("px")) && (S = $r(v, "x", u, "px"),
                w = $r(v, "y", d, "px")),
                (_ || y || x || b) && (S = Ge(S + _ - (_ * n + y * i) + x),
                w = Ge(w + y - (_ * r + y * a) + b)),
                (l || c) && (s = v.getBBox(),
                S = Ge(S + l / 100 * s.width),
                w = Ge(w + c / 100 * s.height)),
                s = "matrix(" + n + "," + r + "," + i + "," + a + "," + S + "," + w + ")",
                v.setAttribute("transform", s),
                E && (v.style[Rr] = s)
            }, gi = function(e, t, n, r, i) {
                var a, s, o = 360, l = re(i), c = parseFloat(i) * (l && ~i.indexOf("rad") ? dr : 1) - r, u = r + c + "deg";
                return l && ("short" === (a = i.split("_")[1]) && (c %= o) !== c % 180 && (c += c < 0 ? o : -360),
                "cw" === a && c < 0 ? c = (c + 36e9) % o - ~~(c / o) * o : "ccw" === a && c > 0 && (c = (c - 36e9) % o - ~~(c / o) * o)),
                e._pt = s = new Bn(e._pt,t,n,r,c,yr),
                s.e = u,
                s.u = "deg",
                e._props.push(n),
                s
            }, vi = function(e, t) {
                for (var n in t)
                    e[n] = t[n];
                return e
            }, _i = function(e, t, n) {
                var r, i, a, s, o, l, c, u = vi({}, n._gsap), d = n.style;
                for (i in u.svg ? (a = n.getAttribute("transform"),
                n.setAttribute("transform", ""),
                d[Rr] = t,
                r = oi(n, 1),
                jr(n, Rr),
                n.setAttribute("transform", a)) : (a = getComputedStyle(n)[Rr],
                d[Rr] = t,
                r = oi(n, 1),
                d[Rr] = a),
                ur)
                    (a = u[i]) !== (s = r[i]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(i) < 0 && (o = Mt(a) !== (c = Mt(s)) ? $r(n, i, a, c) : parseFloat(a),
                    l = parseFloat(s),
                    e._pt = new Bn(e._pt,r,i,o,l - o,_r),
                    e._pt.u = c || 0,
                    e._props.push(i));
                vi(r, u)
            };
            He("padding,margin,Width,Radius", (function(e, t) {
                var n = "Top"
                  , r = "Right"
                  , i = "Bottom"
                  , a = "Left"
                  , s = (t < 3 ? [n, r, i, a] : [n + a, n + r, i + r, i + a]).map((function(n) {
                    return t < 2 ? e + n : "border" + n + e
                }
                ));
                ei[t > 1 ? "border" + e : e] = function(e, t, n, r, i) {
                    var a, o;
                    if (arguments.length < 4)
                        return a = s.map((function(t) {
                            return Kr(e, t, n)
                        }
                        )),
                        5 === (o = a.join(" ")).split(a[0]).length ? a[0] : o;
                    a = (r + "").split(" "),
                    o = {},
                    s.forEach((function(e, t) {
                        return o[e] = a[t] = a[t] || a[(t - 1) / 2 | 0]
                    }
                    )),
                    e.init(t, o, i)
                }
            }
            ));
            var yi, xi, bi, Ei = {
                name: "css",
                register: Br,
                targetTest: function(e) {
                    return e.style && e.nodeType
                },
                init: function(e, t, n, r, i) {
                    var a, s, o, l, c, u, d, h, p, f, m, g, v, _, y, x, b, E, S, w, M = this._props, T = e.style, A = n.vars.startAt;
                    for (d in rr || Br(),
                    this.styles = this.styles || Nr(e),
                    x = this.styles.props,
                    this.tween = n,
                    t)
                        if ("autoRound" !== d && (s = t[d],
                        !De[d] || !xn(d, t, n, r, e, i)))
                            if (c = typeof s,
                            u = ei[d],
                            "function" === c && (c = typeof (s = s.call(n, r, e, i))),
                            "string" === c && ~s.indexOf("random(") && (s = kt(s)),
                            u)
                                u(this, e, d, s, n) && (y = 1);
                            else if ("--" === d.substr(0, 2))
                                a = (getComputedStyle(e).getPropertyValue(d) + "").trim(),
                                s += "",
                                Kt.lastIndex = 0,
                                Kt.test(a) || (h = Mt(a),
                                p = Mt(s)),
                                p ? h !== p && (a = $r(e, d, a, p) + p) : h && (s += h),
                                this.add(T, "setProperty", a, s, r, i, 0, 0, d),
                                M.push(d),
                                x.push(d, 0, T[d]);
                            else if ("undefined" !== c) {
                                if (A && d in A ? (a = "function" == typeof A[d] ? A[d].call(n, r, e, i) : A[d],
                                re(a) && ~a.indexOf("random(") && (a = kt(a)),
                                Mt(a + "") || "auto" === a || (a += q.units[d] || Mt(Kr(e, d)) || ""),
                                "=" === (a + "").charAt(1) && (a = Kr(e, d))) : a = Kr(e, d),
                                l = parseFloat(a),
                                (f = "string" === c && "=" === s.charAt(1) && s.substr(0, 2)) && (s = s.substr(2)),
                                o = parseFloat(s),
                                d in vr && ("autoAlpha" === d && (1 === l && "hidden" === Kr(e, "visibility") && o && (l = 0),
                                x.push("visibility", 0, T.visibility),
                                Xr(this, T, "visibility", l ? "inherit" : "hidden", o ? "inherit" : "hidden", !o)),
                                "scale" !== d && "transform" !== d && ~(d = vr[d]).indexOf(",") && (d = d.split(",")[0])),
                                m = d in ur)
                                    if (this.styles.save(d),
                                    g || ((v = e._gsap).renderTransform && !t.parseTransform || oi(e, t.parseTransform),
                                    _ = !1 !== t.smoothOrigin && v.smooth,
                                    (g = this._pt = new Bn(this._pt,T,Rr,0,1,v.renderTransform,v,0,-1)).dep = 1),
                                    "scale" === d)
                                        this._pt = new Bn(this._pt,v,"scaleY",v.scaleY,(f ? We(v.scaleY, f + o) : o) - v.scaleY || 0,_r),
                                        this._pt.u = 0,
                                        M.push("scaleY", d),
                                        d += "X";
                                    else {
                                        if ("transformOrigin" === d) {
                                            x.push(Lr, 0, T[Lr]),
                                            E = void 0,
                                            S = void 0,
                                            w = void 0,
                                            E = (b = s).split(" "),
                                            S = E[0],
                                            w = E[1] || "50%",
                                            "top" !== S && "bottom" !== S && "left" !== w && "right" !== w || (b = S,
                                            S = w,
                                            w = b),
                                            E[0] = Jr[S] || S,
                                            E[1] = Jr[w] || w,
                                            s = E.join(" "),
                                            v.svg ? si(e, s, 0, _, 0, this) : ((p = parseFloat(s.split(" ")[2]) || 0) !== v.zOrigin && Xr(this, v, "zOrigin", v.zOrigin, p),
                                            Xr(this, T, d, li(a), li(s)));
                                            continue
                                        }
                                        if ("svgOrigin" === d) {
                                            si(e, s, 1, _, 0, this);
                                            continue
                                        }
                                        if (d in ni) {
                                            gi(this, v, d, l, f ? We(l, f + s) : s);
                                            continue
                                        }
                                        if ("smoothOrigin" === d) {
                                            Xr(this, v, "smooth", v.smooth, s);
                                            continue
                                        }
                                        if ("force3D" === d) {
                                            v[d] = s;
                                            continue
                                        }
                                        if ("transform" === d) {
                                            _i(this, s, e);
                                            continue
                                        }
                                    }
                                else
                                    d in T || (d = zr(d) || d);
                                if (m || (o || 0 === o) && (l || 0 === l) && !gr.test(s) && d in T)
                                    o || (o = 0),
                                    (h = (a + "").substr((l + "").length)) !== (p = Mt(s) || (d in q.units ? q.units[d] : h)) && (l = $r(e, d, a, p)),
                                    this._pt = new Bn(this._pt,m ? v : T,d,l,(f ? We(l, f + o) : o) - l,m || "px" !== p && "zIndex" !== d || !1 === t.autoRound ? _r : br),
                                    this._pt.u = p || 0,
                                    h !== p && "%" !== p && (this._pt.b = a,
                                    this._pt.r = xr);
                                else if (d in T)
                                    Zr.call(this, e, d, a, f ? f + s : s);
                                else if (d in e)
                                    this.add(e, d, a || e[d], f ? f + s : s, r, i);
                                else if ("parseTransform" !== d) {
                                    Se(d, s);
                                    continue
                                }
                                m || (d in T ? x.push(d, 0, T[d]) : x.push(d, 1, a || e[d])),
                                M.push(d)
                            }
                    y && zn(this)
                },
                render: function(e, t) {
                    if (t.tween._time || !sr())
                        for (var n = t._pt; n; )
                            n.r(e, n.d),
                            n = n._next;
                    else
                        t.styles.revert()
                },
                get: Kr,
                aliases: vr,
                getSetter: function(e, t, n) {
                    var r = vr[t];
                    return r && r.indexOf(",") < 0 && (t = r),
                    t in ur && t !== Lr && (e._gsap.x || Kr(e, "x")) ? n && ar === n ? "scale" === t ? Ar : Tr : (ar = n || {}) && ("scale" === t ? Cr : Pr) : e.style && !se(e.style[t]) ? wr : ~t.indexOf("-") ? Mr : Ln(e, t)
                },
                core: {
                    _removeProperty: jr,
                    _getMatrix: ai
                }
            };
            Qn.utils.checkPrefix = zr,
            Qn.core.getStyleSaver = Nr,
            bi = He((yi = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") + "," + (xi = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function(e) {
                ur[e] = 1
            }
            )),
            He(xi, (function(e) {
                q.units[e] = "deg",
                ni[e] = 1
            }
            )),
            vr[bi[13]] = yi + "," + xi,
            He("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function(e) {
                var t = e.split(":");
                vr[t[1]] = bi[t[0]]
            }
            )),
            He("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function(e) {
                q.units[e] = "px"
            }
            )),
            Qn.registerPlugin(Ei);
            var Si = Qn.registerPlugin(Ei) || Qn;
            Si.core.Tween;
            function wi(e) {
                return wi = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                }
                : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }
                ,
                wi(e)
            }
            function Mi(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1,
                    r.configurable = !0,
                    "value"in r && (r.writable = !0),
                    Object.defineProperty(e, Ti(r.key), r)
                }
            }
            function Ti(e) {
                var t = function(e, t) {
                    if ("object" != wi(e) || !e)
                        return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var r = n.call(e, t || "default");
                        if ("object" != wi(r))
                            return r;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return ("string" === t ? String : Number)(e)
                }(e, "string");
                return "symbol" == wi(t) ? t : String(t)
            }
            function Ai(e, t, n) {
                return t = Pi(t),
                function(e, t) {
                    if (t && ("object" === wi(t) || "function" == typeof t))
                        return t;
                    if (void 0 !== t)
                        throw new TypeError("Derived constructors may only return object or undefined");
                    return function(e) {
                        if (void 0 === e)
                            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return e
                    }(e)
                }(e, Ci() ? Reflect.construct(t, n || [], Pi(e).constructor) : t.apply(e, n))
            }
            function Ci() {
                try {
                    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
                    )))
                } catch (e) {}
                return (Ci = function() {
                    return !!e
                }
                )()
            }
            function Pi(e) {
                return Pi = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                }
                ,
                Pi(e)
            }
            function Ri(e, t) {
                return Ri = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
                    return e.__proto__ = t,
                    e
                }
                ,
                Ri(e, t)
            }
            var Li = function(e) {
                function t(e) {
                    return function(e, t) {
                        if (!(e instanceof t))
                            throw new TypeError("Cannot call a class as a function")
                    }(this, t),
                    Ai(this, t, [e])
                }
                var n, r, i;
                return function(e, t) {
                    if ("function" != typeof t && null !== t)
                        throw new TypeError("Super expression must either be null or a function");
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            writable: !0,
                            configurable: !0
                        }
                    }),
                    Object.defineProperty(e, "prototype", {
                        writable: !1
                    }),
                    t && Ri(e, t)
                }(t, e),
                n = t,
                (r = [{
                    key: "init",
                    value: function() {
                        y.IS_DESKTOP && !y.IS_REDUCED_MOTION ? (Si.set(".e-cursor", {
                            scale: 0
                        }),
                        document.onmousemove = function(e) {
                            Si.to(".e-cursor", {
                                x: e.clientX,
                                y: e.clientY,
                                ease: lr.easeOut
                            }),
                            "A" === e.target.tagName || e.target.closest("a") || "BUTTON" === e.target.tagName || e.target.closest("button") ? Si.to(".e-cursor", {
                                scale: 0
                            }) : Si.to(".e-cursor", {
                                scale: 1
                            })
                        }
                        ,
                        window.addEventListener("mouseout", (function() {
                            Si.to(".e-cursor", {
                                scale: 0
                            })
                        }
                        ))) : this.el.style = "transform: scale(0) !important; transition: none !important",
                        y.IS_DEV && console.log("Cursor: Initiated")
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        this.el.style = "transform: scale(0) !important; transition: none !important",
                        y.IS_DEV && console.log("Cursor: Destroyed")
                    }
                }]) && Mi(n.prototype, r),
                i && Mi(n, i),
                Object.defineProperty(n, "prototype", {
                    writable: !1
                }),
                t
            }(p)
              , Oi = n(714)
              , Di = n.n(Oi)
              , Ii = n(943)
              , Ni = n.n(Ii);
            function Ui(e) {
                return Ui = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                }
                : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }
                ,
                Ui(e)
            }
            function ki(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1,
                    r.configurable = !0,
                    "value"in r && (r.writable = !0),
                    Object.defineProperty(e, Fi(r.key), r)
                }
            }
            function Fi(e) {
                var t = function(e, t) {
                    if ("object" != Ui(e) || !e)
                        return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var r = n.call(e, t || "default");
                        if ("object" != Ui(r))
                            return r;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return ("string" === t ? String : Number)(e)
                }(e, "string");
                return "symbol" == Ui(t) ? t : String(t)
            }
            function zi(e, t, n) {
                return t = Hi(t),
                function(e, t) {
                    if (t && ("object" === Ui(t) || "function" == typeof t))
                        return t;
                    if (void 0 !== t)
                        throw new TypeError("Derived constructors may only return object or undefined");
                    return function(e) {
                        if (void 0 === e)
                            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return e
                    }(e)
                }(e, Bi() ? Reflect.construct(t, n || [], Hi(e).constructor) : t.apply(e, n))
            }
            function Bi() {
                try {
                    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
                    )))
                } catch (e) {}
                return (Bi = function() {
                    return !!e
                }
                )()
            }
            function Hi(e) {
                return Hi = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                }
                ,
                Hi(e)
            }
            function Gi(e, t) {
                return Gi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
                    return e.__proto__ = t,
                    e
                }
                ,
                Gi(e, t)
            }
            var Vi = function(e) {
                function t(e) {
                    var n;
                    return function(e, t) {
                        if (!(e instanceof t))
                            throw new TypeError("Cannot call a class as a function")
                    }(this, t),
                    (n = zi(this, t, [e])).primaryLinks = n.el.querySelectorAll("[data-navigation-primary-link]"),
                    n.pageDirection = "right",
                    n.currentNavigationIndex = null,
                    n.nextNavigationIndex = null,
                    n
                }
                var n, r, i;
                return function(e, t) {
                    if ("function" != typeof t && null !== t)
                        throw new TypeError("Super expression must either be null or a function");
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            writable: !0,
                            configurable: !0
                        }
                    }),
                    Object.defineProperty(e, "prototype", {
                        writable: !1
                    }),
                    t && Gi(e, t)
                }(t, e),
                n = t,
                (r = [{
                    key: "init",
                    value: function() {
                        var e = this;
                        Di().init({
                            prevent: function(t) {
                                var n = t.event
                                  , r = t.href;
                                if ("click" === n.type && r.split("#")[0] === window.location.href.split("#")[0]) {
                                    if (r === window.location.href)
                                        return n.preventDefault(),
                                        n.stopPropagation(),
                                        0 !== window.scrollY && r.split("#").length <= 1 ? e.call("scrollTo", null, "Scroll", "main") : r.split("#").length >= 2 && e.call("scrollTo", r.split("#")[1], "Scroll", "main"),
                                        g.classList.remove(x.NAVIGATION_OPEN),
                                        e.call("pauseScroll", !1, "Scroll", "main"),
                                        !0;
                                    if (r.split("#").length >= 2)
                                        return n.stopPropagation(),
                                        e.call("scrollTo", "#" + r.split("#")[1], "Scroll", "main"),
                                        g.classList.remove(x.NAVIGATION_OPEN),
                                        e.call("pauseScroll", !1, "Scroll", "main"),
                                        !0;
                                    if (window.location.href.split("#").length >= 2 && r.split("#").length <= 1)
                                        return n.preventDefault(),
                                        n.stopPropagation(),
                                        0 !== window.scrollY && e.call("scrollTo", null, "Scroll", "main"),
                                        Di().history.add(r, "barba"),
                                        g.classList.remove(x.NAVIGATION_OPEN),
                                        e.call("pauseScroll", !1, "Scroll", "main"),
                                        !0
                                }
                            },
                            debug: y.IS_DEV,
                            schema: {
                                prefix: "data-load"
                            },
                            transitions: [{
                                name: "default-transition",
                                sync: !0,
                                before: function(t) {
                                    return g.classList.remove(x.LOADED),
                                    g.classList.remove(x.READY),
                                    g.classList.remove(x.NAVIGATION_OPEN),
                                    g.classList.add(x.LOADING),
                                    e.call("setScrollProgress", 0, "Scroll", "main"),
                                    e.call("pauseScroll", !1, "Scroll", "main"),
                                    e.call("closeVideo", "CloseVideo"),
                                    e.currentNavigationIndex = e.getIndex(t.current.url.path),
                                    e.nextNavigationIndex = e.getIndex(t.next.url.path),
                                    y.IS_REDUCED_MOTION ? Si.set(t.next.container, {
                                        x: "0vw",
                                        y: "0vw",
                                        opacity: 0,
                                        duration: 0
                                    }) : "/" !== t.current.url.path && "/" === t.next.url.path ? (e.pageDirection = "left",
                                    Si.set(t.next.container, {
                                        x: "-100vw",
                                        opacity: 0,
                                        duration: 0
                                    })) : e.currentNavigationIndex && e.nextNavigationIndex ? e.currentNavigationIndex < e.nextNavigationIndex ? (e.pageDirection = "up",
                                    Si.set(t.next.container, {
                                        y: "100vh",
                                        opacity: 0,
                                        duration: 0
                                    })) : (e.pageDirection = "down",
                                    Si.set(t.next.container, {
                                        y: "-100vh",
                                        opacity: 0,
                                        duration: 0
                                    })) : "/" !== t.current.url.path && !e.currentNavigationIndex && e.nextNavigationIndex ? (e.pageDirection = "left",
                                    Si.set(t.next.container, {
                                        x: "-100vw",
                                        opacity: 0,
                                        duration: 0
                                    })) : (e.pageDirection = "right",
                                    Si.set(t.next.container, {
                                        x: "100vw",
                                        opacity: 0,
                                        duration: 0
                                    })),
                                    new Promise((function(n) {
                                        Ni()(t.next.container, (function() {
                                            e.call("setActive", t.next.url.path, "Navigation", "main"),
                                            y.IS_DEV && console.log("Load: Before"),
                                            n()
                                        }
                                        ))
                                    }
                                    ))
                                },
                                leave: function(t) {
                                    var n = {
                                        y: 0,
                                        x: 0,
                                        opacity: 0,
                                        duration: .75
                                    };
                                    return y.IS_REDUCED_MOTION || ("up" === e.pageDirection ? n.y = "-100vh" : "down" === e.pageDirection ? n.y = "100vh" : "left" === e.pageDirection ? n.x = "100vw" : (e.pageDirection,
                                    n.x = "-100vw")),
                                    new Promise((function(r) {
                                        Si.to(t.current.container, {
                                            y: n.y,
                                            x: n.x,
                                            opacity: n.opacity,
                                            duration: n.duration,
                                            onComplete: function() {
                                                g.classList.add(x.LOADED),
                                                g.classList.add(x.READY),
                                                g.classList.remove(x.LOADING),
                                                e.call("destroy", t.current.container, "app"),
                                                y.IS_DEV && console.log("Load: Leave Finished"),
                                                r()
                                            }
                                        })
                                    }
                                    ))
                                },
                                enter: function(e) {
                                    return new Promise((function(t) {
                                        Si.to(e.next.container, {
                                            y: "0vh",
                                            x: "0vw",
                                            opacity: 1,
                                            duration: .75,
                                            onComplete: function() {
                                                y.IS_DEV && console.log("Load: Enter Finished"),
                                                t()
                                            }
                                        })
                                    }
                                    ))
                                },
                                after: function(t) {
                                    e.call("update", t.next.container, "app"),
                                    e.call("pauseScroll", !0, "Scroll", "main"),
                                    e.call("refresh", !0, "Magnetic", "main"),
                                    setTimeout((function() {
                                        e.call("pauseScroll", !1, "Scroll", "main")
                                    }
                                    ), 750),
                                    "function" == typeof gtag && (gtag("event", "page_view", {
                                        page_title: document.title,
                                        page_location: location.href,
                                        page_path: location.pathname
                                    }),
                                    y.IS_DEV && console.log("Google Analytics: Logged")),
                                    y.IS_DEV && console.log("Load: After Finished")
                                }
                            }],
                            preventRunning: !0
                        }),
                        y.IS_DEV && console.log("Load: Initiated")
                    }
                }, {
                    key: "getIndex",
                    value: function(e) {
                        for (var t = null, n = 0; n < this.primaryLinks.length; n++)
                            this.primaryLinks[n].href.includes(e) && "/" !== e && (t = n + 1);
                        return t
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        y.IS_DEV && console.log("Load: Destroyed")
                    }
                }]) && ki(n.prototype, r),
                i && ki(n, i),
                Object.defineProperty(n, "prototype", {
                    writable: !1
                }),
                t
            }(p);
            function Wi(e) {
                return Wi = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                }
                : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }
                ,
                Wi(e)
            }
            function ji(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1,
                    r.configurable = !0,
                    "value"in r && (r.writable = !0),
                    Object.defineProperty(e, Xi(r.key), r)
                }
            }
            function Xi(e) {
                var t = function(e, t) {
                    if ("object" != Wi(e) || !e)
                        return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var r = n.call(e, t || "default");
                        if ("object" != Wi(r))
                            return r;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return ("string" === t ? String : Number)(e)
                }(e, "string");
                return "symbol" == Wi(t) ? t : String(t)
            }
            function qi(e, t, n) {
                return t = $i(t),
                function(e, t) {
                    if (t && ("object" === Wi(t) || "function" == typeof t))
                        return t;
                    if (void 0 !== t)
                        throw new TypeError("Derived constructors may only return object or undefined");
                    return function(e) {
                        if (void 0 === e)
                            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return e
                    }(e)
                }(e, Yi() ? Reflect.construct(t, n || [], $i(e).constructor) : t.apply(e, n))
            }
            function Yi() {
                try {
                    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
                    )))
                } catch (e) {}
                return (Yi = function() {
                    return !!e
                }
                )()
            }
            function $i(e) {
                return $i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                }
                ,
                $i(e)
            }
            function Ki(e, t) {
                return Ki = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
                    return e.__proto__ = t,
                    e
                }
                ,
                Ki(e, t)
            }
            var Zi = function(e) {
                function t(e) {
                    var n;
                    return function(e, t) {
                        if (!(e instanceof t))
                            throw new TypeError("Cannot call a class as a function")
                    }(this, t),
                    (n = qi(this, t, [e])).magnets = null,
                    n.strength = 20,
                    n
                }
                var n, r, i;
                return function(e, t) {
                    if ("function" != typeof t && null !== t)
                        throw new TypeError("Super expression must either be null or a function");
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            writable: !0,
                            configurable: !0
                        }
                    }),
                    Object.defineProperty(e, "prototype", {
                        writable: !1
                    }),
                    t && Ki(e, t)
                }(t, e),
                n = t,
                (r = [{
                    key: "init",
                    value: function() {
                        y.IS_DESKTOP && !y.IS_REDUCED_MOTION && this.queryMagnets(),
                        y.IS_DEV && console.log("Magnetic: Initiated")
                    }
                }, {
                    key: "queryMagnets",
                    value: function() {
                        this.magnets = this.el.querySelectorAll("[data-magnetic-element]"),
                        this.magnets.length && this.setupMagnets()
                    }
                }, {
                    key: "setupMagnets",
                    value: function() {
                        var e = this;
                        this.magnets.forEach((function(t) {
                            t.addEventListener("mousemove", (function(t) {
                                return e.moveMagnet(t)
                            }
                            )),
                            t.addEventListener("mouseout", (function(e) {
                                Si.to(e.currentTarget, {
                                    x: 0,
                                    y: 0,
                                    ease: cr.easeOut
                                })
                            }
                            ))
                        }
                        ))
                    }
                }, {
                    key: "moveMagnet",
                    value: function(e) {
                        var t = e.currentTarget
                          , n = t.getBoundingClientRect();
                        Si.to(t, {
                            x: ((e.clientX - n.left) / t.offsetWidth - .5) * this.strength,
                            y: ((e.clientY - n.top) / t.offsetHeight - .5) * this.strength,
                            ease: cr.easeOut
                        })
                    }
                }, {
                    key: "refresh",
                    value: function() {
                        y.IS_DESKTOP && (this.magnets.forEach((function(e) {
                            removeEventListener("mousemove", e),
                            removeEventListener("mouseout", e)
                        }
                        )),
                        this.queryMagnets())
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        y.IS_DEV && console.log("Magnetic: Destroyed")
                    }
                }]) && ji(n.prototype, r),
                i && ji(n, i),
                Object.defineProperty(n, "prototype", {
                    writable: !1
                }),
                t
            }(p);
            function Ji(e) {
                return Ji = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                }
                : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }
                ,
                Ji(e)
            }
            function Qi(e, t) {
                var n = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                if (!n) {
                    if (Array.isArray(e) || (n = function(e, t) {
                        if (!e)
                            return;
                        if ("string" == typeof e)
                            return ea(e, t);
                        var n = Object.prototype.toString.call(e).slice(8, -1);
                        "Object" === n && e.constructor && (n = e.constructor.name);
                        if ("Map" === n || "Set" === n)
                            return Array.from(e);
                        if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                            return ea(e, t)
                    }(e)) || t && e && "number" == typeof e.length) {
                        n && (e = n);
                        var r = 0
                          , i = function() {};
                        return {
                            s: i,
                            n: function() {
                                return r >= e.length ? {
                                    done: !0
                                } : {
                                    done: !1,
                                    value: e[r++]
                                }
                            },
                            e: function(e) {
                                throw e
                            },
                            f: i
                        }
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }
                var a, s = !0, o = !1;
                return {
                    s: function() {
                        n = n.call(e)
                    },
                    n: function() {
                        var e = n.next();
                        return s = e.done,
                        e
                    },
                    e: function(e) {
                        o = !0,
                        a = e
                    },
                    f: function() {
                        try {
                            s || null == n.return || n.return()
                        } finally {
                            if (o)
                                throw a
                        }
                    }
                }
            }
            function ea(e, t) {
                (null == t || t > e.length) && (t = e.length);
                for (var n = 0, r = new Array(t); n < t; n++)
                    r[n] = e[n];
                return r
            }
            function ta(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1,
                    r.configurable = !0,
                    "value"in r && (r.writable = !0),
                    Object.defineProperty(e, na(r.key), r)
                }
            }
            function na(e) {
                var t = function(e, t) {
                    if ("object" != Ji(e) || !e)
                        return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var r = n.call(e, t || "default");
                        if ("object" != Ji(r))
                            return r;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return ("string" === t ? String : Number)(e)
                }(e, "string");
                return "symbol" == Ji(t) ? t : String(t)
            }
            function ra(e, t, n) {
                return t = aa(t),
                function(e, t) {
                    if (t && ("object" === Ji(t) || "function" == typeof t))
                        return t;
                    if (void 0 !== t)
                        throw new TypeError("Derived constructors may only return object or undefined");
                    return function(e) {
                        if (void 0 === e)
                            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return e
                    }(e)
                }(e, ia() ? Reflect.construct(t, n || [], aa(e).constructor) : t.apply(e, n))
            }
            function ia() {
                try {
                    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
                    )))
                } catch (e) {}
                return (ia = function() {
                    return !!e
                }
                )()
            }
            function aa(e) {
                return aa = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                }
                ,
                aa(e)
            }
            function sa(e, t) {
                return sa = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
                    return e.__proto__ = t,
                    e
                }
                ,
                sa(e, t)
            }
            var oa = function(e) {
                function t(e) {
                    var n;
                    return function(e, t) {
                        if (!(e instanceof t))
                            throw new TypeError("Cannot call a class as a function")
                    }(this, t),
                    (n = ra(this, t, [e])).triggers = n.el.querySelectorAll("[data-navigation-trigger]"),
                    n.primaryLinks = n.el.querySelectorAll("[data-navigation-primary-link]"),
                    n
                }
                var n, r, i;
                return function(e, t) {
                    if ("function" != typeof t && null !== t)
                        throw new TypeError("Super expression must either be null or a function");
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            writable: !0,
                            configurable: !0
                        }
                    }),
                    Object.defineProperty(e, "prototype", {
                        writable: !1
                    }),
                    t && sa(e, t)
                }(t, e),
                n = t,
                (r = [{
                    key: "init",
                    value: function() {
                        var e, t = this, n = Qi(this.triggers);
                        try {
                            for (n.s(); !(e = n.n()).done; )
                                e.value.addEventListener("click", (function(e) {
                                    g.classList.contains(x.NAVIGATION_OPEN) ? (g.classList.remove(x.NAVIGATION_OPEN),
                                    g.classList.contains(x.VIDEO_PLAYING) || t.call("pauseScroll", !1, "Scroll", "main")) : (g.classList.add(x.NAVIGATION_OPEN),
                                    t.call("pauseScroll", !0, "Scroll", "main"))
                                }
                                ))
                        } catch (e) {
                            n.e(e)
                        } finally {
                            n.f()
                        }
                        window.addEventListener("resize", (function() {
                            window.innerWidth >= 1440 && (g.classList.contains(x.VIDEO_PLAYING) || t.call("pauseScroll", !1, "Scroll", "main"))
                        }
                        )),
                        y.IS_DEV && console.log("Navigation: Initiated")
                    }
                }, {
                    key: "setActive",
                    value: function(e) {
                        var t, n = Qi(this.primaryLinks);
                        try {
                            for (n.s(); !(t = n.n()).done; ) {
                                var r = t.value
                                  , i = new URL(r.href).pathname;
                                (i.includes(e) || e.includes(i)) && "/" !== e ? r.classList.add("is-active") : r.classList.remove("is-active")
                            }
                        } catch (e) {
                            n.e(e)
                        } finally {
                            n.f()
                        }
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        y.IS_DEV && console.log("Navigation: Destroyed")
                    }
                }]) && ta(n.prototype, r),
                i && ta(n, i),
                Object.defineProperty(n, "prototype", {
                    writable: !1
                }),
                t
            }(p);
            const la = "162"
              , ca = 1
              , ua = 2
              , da = 3
              , ha = 0
              , pa = 1
              , fa = 100
              , ma = 0
              , ga = 1
              , va = 2
              , _a = 0
              , ya = 1
              , xa = 2
              , ba = 3
              , Ea = 4
              , Sa = 5
              , wa = 6
              , Ma = 7
              , Ta = 301
              , Aa = 302
              , Ca = 303
              , Pa = 304
              , Ra = 306
              , La = 1e3
              , Oa = 1001
              , Da = 1002
              , Ia = 1003
              , Na = 1004
              , Ua = 1005
              , ka = 1006
              , Fa = 1007
              , za = 1008
              , Ba = 1009
              , Ha = 1012
              , Ga = 1013
              , Va = 1014
              , Wa = 1015
              , ja = 1016
              , Xa = 1020
              , qa = 1023
              , Ya = 1026
              , $a = 1027
              , Ka = 33776
              , Za = 33777
              , Ja = 33778
              , Qa = 33779
              , es = 36492
              , ts = 2300
              , ns = 2301
              , rs = 2302
              , is = 2400
              , as = 2401
              , ss = 2402
              , os = ""
              , ls = "srgb"
              , cs = "srgb-linear"
              , us = "display-p3"
              , ds = "display-p3-linear"
              , hs = "linear"
              , ps = "srgb"
              , fs = "rec709"
              , ms = "p3"
              , gs = 7680
              , vs = 35044
              , _s = "300 es"
              , ys = 1035
              , xs = 2e3
              , bs = 2001;
            class Es {
                addEventListener(e, t) {
                    void 0 === this._listeners && (this._listeners = {});
                    const n = this._listeners;
                    void 0 === n[e] && (n[e] = []),
                    -1 === n[e].indexOf(t) && n[e].push(t)
                }
                hasEventListener(e, t) {
                    if (void 0 === this._listeners)
                        return !1;
                    const n = this._listeners;
                    return void 0 !== n[e] && -1 !== n[e].indexOf(t)
                }
                removeEventListener(e, t) {
                    if (void 0 === this._listeners)
                        return;
                    const n = this._listeners[e];
                    if (void 0 !== n) {
                        const e = n.indexOf(t);
                        -1 !== e && n.splice(e, 1)
                    }
                }
                dispatchEvent(e) {
                    if (void 0 === this._listeners)
                        return;
                    const t = this._listeners[e.type];
                    if (void 0 !== t) {
                        e.target = this;
                        const n = t.slice(0);
                        for (let t = 0, r = n.length; t < r; t++)
                            n[t].call(this, e);
                        e.target = null
                    }
                }
            }
            const Ss = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
            const ws = Math.PI / 180
              , Ms = 180 / Math.PI;
            function Ts() {
                const e = 4294967295 * Math.random() | 0
                  , t = 4294967295 * Math.random() | 0
                  , n = 4294967295 * Math.random() | 0
                  , r = 4294967295 * Math.random() | 0;
                return (Ss[255 & e] + Ss[e >> 8 & 255] + Ss[e >> 16 & 255] + Ss[e >> 24 & 255] + "-" + Ss[255 & t] + Ss[t >> 8 & 255] + "-" + Ss[t >> 16 & 15 | 64] + Ss[t >> 24 & 255] + "-" + Ss[63 & n | 128] + Ss[n >> 8 & 255] + "-" + Ss[n >> 16 & 255] + Ss[n >> 24 & 255] + Ss[255 & r] + Ss[r >> 8 & 255] + Ss[r >> 16 & 255] + Ss[r >> 24 & 255]).toLowerCase()
            }
            function As(e, t, n) {
                return Math.max(t, Math.min(n, e))
            }
            function Cs(e, t) {
                return (e % t + t) % t
            }
            function Ps(e, t, n) {
                return (1 - n) * e + n * t
            }
            function Rs(e) {
                return 0 == (e & e - 1) && 0 !== e
            }
            function Ls(e) {
                return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
            }
            function Os(e, t) {
                switch (t.constructor) {
                case Float32Array:
                    return e;
                case Uint32Array:
                    return e / 4294967295;
                case Uint16Array:
                    return e / 65535;
                case Uint8Array:
                    return e / 255;
                case Int32Array:
                    return Math.max(e / 2147483647, -1);
                case Int16Array:
                    return Math.max(e / 32767, -1);
                case Int8Array:
                    return Math.max(e / 127, -1);
                default:
                    throw new Error("Invalid component type.")
                }
            }
            function Ds(e, t) {
                switch (t.constructor) {
                case Float32Array:
                    return e;
                case Uint32Array:
                    return Math.round(4294967295 * e);
                case Uint16Array:
                    return Math.round(65535 * e);
                case Uint8Array:
                    return Math.round(255 * e);
                case Int32Array:
                    return Math.round(2147483647 * e);
                case Int16Array:
                    return Math.round(32767 * e);
                case Int8Array:
                    return Math.round(127 * e);
                default:
                    throw new Error("Invalid component type.")
                }
            }
            class Is {
                constructor(e=0, t=0) {
                    Is.prototype.isVector2 = !0,
                    this.x = e,
                    this.y = t
                }
                get width() {
                    return this.x
                }
                set width(e) {
                    this.x = e
                }
                get height() {
                    return this.y
                }
                set height(e) {
                    this.y = e
                }
                set(e, t) {
                    return this.x = e,
                    this.y = t,
                    this
                }
                setScalar(e) {
                    return this.x = e,
                    this.y = e,
                    this
                }
                setX(e) {
                    return this.x = e,
                    this
                }
                setY(e) {
                    return this.y = e,
                    this
                }
                setComponent(e, t) {
                    switch (e) {
                    case 0:
                        this.x = t;
                        break;
                    case 1:
                        this.y = t;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                    }
                    return this
                }
                getComponent(e) {
                    switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw new Error("index is out of range: " + e)
                    }
                }
                clone() {
                    return new this.constructor(this.x,this.y)
                }
                copy(e) {
                    return this.x = e.x,
                    this.y = e.y,
                    this
                }
                add(e) {
                    return this.x += e.x,
                    this.y += e.y,
                    this
                }
                addScalar(e) {
                    return this.x += e,
                    this.y += e,
                    this
                }
                addVectors(e, t) {
                    return this.x = e.x + t.x,
                    this.y = e.y + t.y,
                    this
                }
                addScaledVector(e, t) {
                    return this.x += e.x * t,
                    this.y += e.y * t,
                    this
                }
                sub(e) {
                    return this.x -= e.x,
                    this.y -= e.y,
                    this
                }
                subScalar(e) {
                    return this.x -= e,
                    this.y -= e,
                    this
                }
                subVectors(e, t) {
                    return this.x = e.x - t.x,
                    this.y = e.y - t.y,
                    this
                }
                multiply(e) {
                    return this.x *= e.x,
                    this.y *= e.y,
                    this
                }
                multiplyScalar(e) {
                    return this.x *= e,
                    this.y *= e,
                    this
                }
                divide(e) {
                    return this.x /= e.x,
                    this.y /= e.y,
                    this
                }
                divideScalar(e) {
                    return this.multiplyScalar(1 / e)
                }
                applyMatrix3(e) {
                    const t = this.x
                      , n = this.y
                      , r = e.elements;
                    return this.x = r[0] * t + r[3] * n + r[6],
                    this.y = r[1] * t + r[4] * n + r[7],
                    this
                }
                min(e) {
                    return this.x = Math.min(this.x, e.x),
                    this.y = Math.min(this.y, e.y),
                    this
                }
                max(e) {
                    return this.x = Math.max(this.x, e.x),
                    this.y = Math.max(this.y, e.y),
                    this
                }
                clamp(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)),
                    this.y = Math.max(e.y, Math.min(t.y, this.y)),
                    this
                }
                clampScalar(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)),
                    this.y = Math.max(e, Math.min(t, this.y)),
                    this
                }
                clampLength(e, t) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                }
                floor() {
                    return this.x = Math.floor(this.x),
                    this.y = Math.floor(this.y),
                    this
                }
                ceil() {
                    return this.x = Math.ceil(this.x),
                    this.y = Math.ceil(this.y),
                    this
                }
                round() {
                    return this.x = Math.round(this.x),
                    this.y = Math.round(this.y),
                    this
                }
                roundToZero() {
                    return this.x = Math.trunc(this.x),
                    this.y = Math.trunc(this.y),
                    this
                }
                negate() {
                    return this.x = -this.x,
                    this.y = -this.y,
                    this
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y
                }
                cross(e) {
                    return this.x * e.y - this.y * e.x
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                angle() {
                    return Math.atan2(-this.y, -this.x) + Math.PI
                }
                angleTo(e) {
                    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
                    if (0 === t)
                        return Math.PI / 2;
                    const n = this.dot(e) / t;
                    return Math.acos(As(n, -1, 1))
                }
                distanceTo(e) {
                    return Math.sqrt(this.distanceToSquared(e))
                }
                distanceToSquared(e) {
                    const t = this.x - e.x
                      , n = this.y - e.y;
                    return t * t + n * n
                }
                manhattanDistanceTo(e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
                }
                setLength(e) {
                    return this.normalize().multiplyScalar(e)
                }
                lerp(e, t) {
                    return this.x += (e.x - this.x) * t,
                    this.y += (e.y - this.y) * t,
                    this
                }
                lerpVectors(e, t, n) {
                    return this.x = e.x + (t.x - e.x) * n,
                    this.y = e.y + (t.y - e.y) * n,
                    this
                }
                equals(e) {
                    return e.x === this.x && e.y === this.y
                }
                fromArray(e, t=0) {
                    return this.x = e[t],
                    this.y = e[t + 1],
                    this
                }
                toArray(e=[], t=0) {
                    return e[t] = this.x,
                    e[t + 1] = this.y,
                    e
                }
                fromBufferAttribute(e, t) {
                    return this.x = e.getX(t),
                    this.y = e.getY(t),
                    this
                }
                rotateAround(e, t) {
                    const n = Math.cos(t)
                      , r = Math.sin(t)
                      , i = this.x - e.x
                      , a = this.y - e.y;
                    return this.x = i * n - a * r + e.x,
                    this.y = i * r + a * n + e.y,
                    this
                }
                random() {
                    return this.x = Math.random(),
                    this.y = Math.random(),
                    this
                }
                *[Symbol.iterator]() {
                    yield this.x,
                    yield this.y
                }
            }
            class Ns {
                constructor(e, t, n, r, i, a, s, o, l) {
                    Ns.prototype.isMatrix3 = !0,
                    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                    void 0 !== e && this.set(e, t, n, r, i, a, s, o, l)
                }
                set(e, t, n, r, i, a, s, o, l) {
                    const c = this.elements;
                    return c[0] = e,
                    c[1] = r,
                    c[2] = s,
                    c[3] = t,
                    c[4] = i,
                    c[5] = o,
                    c[6] = n,
                    c[7] = a,
                    c[8] = l,
                    this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
                    this
                }
                copy(e) {
                    const t = this.elements
                      , n = e.elements;
                    return t[0] = n[0],
                    t[1] = n[1],
                    t[2] = n[2],
                    t[3] = n[3],
                    t[4] = n[4],
                    t[5] = n[5],
                    t[6] = n[6],
                    t[7] = n[7],
                    t[8] = n[8],
                    this
                }
                extractBasis(e, t, n) {
                    return e.setFromMatrix3Column(this, 0),
                    t.setFromMatrix3Column(this, 1),
                    n.setFromMatrix3Column(this, 2),
                    this
                }
                setFromMatrix4(e) {
                    const t = e.elements;
                    return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
                    this
                }
                multiply(e) {
                    return this.multiplyMatrices(this, e)
                }
                premultiply(e) {
                    return this.multiplyMatrices(e, this)
                }
                multiplyMatrices(e, t) {
                    const n = e.elements
                      , r = t.elements
                      , i = this.elements
                      , a = n[0]
                      , s = n[3]
                      , o = n[6]
                      , l = n[1]
                      , c = n[4]
                      , u = n[7]
                      , d = n[2]
                      , h = n[5]
                      , p = n[8]
                      , f = r[0]
                      , m = r[3]
                      , g = r[6]
                      , v = r[1]
                      , _ = r[4]
                      , y = r[7]
                      , x = r[2]
                      , b = r[5]
                      , E = r[8];
                    return i[0] = a * f + s * v + o * x,
                    i[3] = a * m + s * _ + o * b,
                    i[6] = a * g + s * y + o * E,
                    i[1] = l * f + c * v + u * x,
                    i[4] = l * m + c * _ + u * b,
                    i[7] = l * g + c * y + u * E,
                    i[2] = d * f + h * v + p * x,
                    i[5] = d * m + h * _ + p * b,
                    i[8] = d * g + h * y + p * E,
                    this
                }
                multiplyScalar(e) {
                    const t = this.elements;
                    return t[0] *= e,
                    t[3] *= e,
                    t[6] *= e,
                    t[1] *= e,
                    t[4] *= e,
                    t[7] *= e,
                    t[2] *= e,
                    t[5] *= e,
                    t[8] *= e,
                    this
                }
                determinant() {
                    const e = this.elements
                      , t = e[0]
                      , n = e[1]
                      , r = e[2]
                      , i = e[3]
                      , a = e[4]
                      , s = e[5]
                      , o = e[6]
                      , l = e[7]
                      , c = e[8];
                    return t * a * c - t * s * l - n * i * c + n * s * o + r * i * l - r * a * o
                }
                invert() {
                    const e = this.elements
                      , t = e[0]
                      , n = e[1]
                      , r = e[2]
                      , i = e[3]
                      , a = e[4]
                      , s = e[5]
                      , o = e[6]
                      , l = e[7]
                      , c = e[8]
                      , u = c * a - s * l
                      , d = s * o - c * i
                      , h = l * i - a * o
                      , p = t * u + n * d + r * h;
                    if (0 === p)
                        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const f = 1 / p;
                    return e[0] = u * f,
                    e[1] = (r * l - c * n) * f,
                    e[2] = (s * n - r * a) * f,
                    e[3] = d * f,
                    e[4] = (c * t - r * o) * f,
                    e[5] = (r * i - s * t) * f,
                    e[6] = h * f,
                    e[7] = (n * o - l * t) * f,
                    e[8] = (a * t - n * i) * f,
                    this
                }
                transpose() {
                    let e;
                    const t = this.elements;
                    return e = t[1],
                    t[1] = t[3],
                    t[3] = e,
                    e = t[2],
                    t[2] = t[6],
                    t[6] = e,
                    e = t[5],
                    t[5] = t[7],
                    t[7] = e,
                    this
                }
                getNormalMatrix(e) {
                    return this.setFromMatrix4(e).invert().transpose()
                }
                transposeIntoArray(e) {
                    const t = this.elements;
                    return e[0] = t[0],
                    e[1] = t[3],
                    e[2] = t[6],
                    e[3] = t[1],
                    e[4] = t[4],
                    e[5] = t[7],
                    e[6] = t[2],
                    e[7] = t[5],
                    e[8] = t[8],
                    this
                }
                setUvTransform(e, t, n, r, i, a, s) {
                    const o = Math.cos(i)
                      , l = Math.sin(i);
                    return this.set(n * o, n * l, -n * (o * a + l * s) + a + e, -r * l, r * o, -r * (-l * a + o * s) + s + t, 0, 0, 1),
                    this
                }
                scale(e, t) {
                    return this.premultiply(Us.makeScale(e, t)),
                    this
                }
                rotate(e) {
                    return this.premultiply(Us.makeRotation(-e)),
                    this
                }
                translate(e, t) {
                    return this.premultiply(Us.makeTranslation(e, t)),
                    this
                }
                makeTranslation(e, t) {
                    return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
                    this
                }
                makeRotation(e) {
                    const t = Math.cos(e)
                      , n = Math.sin(e);
                    return this.set(t, -n, 0, n, t, 0, 0, 0, 1),
                    this
                }
                makeScale(e, t) {
                    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1),
                    this
                }
                equals(e) {
                    const t = this.elements
                      , n = e.elements;
                    for (let e = 0; e < 9; e++)
                        if (t[e] !== n[e])
                            return !1;
                    return !0
                }
                fromArray(e, t=0) {
                    for (let n = 0; n < 9; n++)
                        this.elements[n] = e[n + t];
                    return this
                }
                toArray(e=[], t=0) {
                    const n = this.elements;
                    return e[t] = n[0],
                    e[t + 1] = n[1],
                    e[t + 2] = n[2],
                    e[t + 3] = n[3],
                    e[t + 4] = n[4],
                    e[t + 5] = n[5],
                    e[t + 6] = n[6],
                    e[t + 7] = n[7],
                    e[t + 8] = n[8],
                    e
                }
                clone() {
                    return (new this.constructor).fromArray(this.elements)
                }
            }
            const Us = new Ns;
            function ks(e) {
                for (let t = e.length - 1; t >= 0; --t)
                    if (e[t] >= 65535)
                        return !0;
                return !1
            }
            Int8Array,
            Uint8Array,
            Uint8ClampedArray,
            Int16Array,
            Uint16Array,
            Int32Array,
            Uint32Array,
            Float32Array,
            Float64Array;
            function Fs(e) {
                return document.createElementNS("http://www.w3.org/1999/xhtml", e)
            }
            function zs() {
                const e = Fs("canvas");
                return e.style.display = "block",
                e
            }
            const Bs = {};
            function Hs(e) {
                e in Bs || (Bs[e] = !0,
                console.warn(e))
            }
            const Gs = (new Ns).set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199)
              , Vs = (new Ns).set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735)
              , Ws = {
                [cs]: {
                    transfer: hs,
                    primaries: fs,
                    toReference: e => e,
                    fromReference: e => e
                },
                [ls]: {
                    transfer: ps,
                    primaries: fs,
                    toReference: e => e.convertSRGBToLinear(),
                    fromReference: e => e.convertLinearToSRGB()
                },
                [ds]: {
                    transfer: hs,
                    primaries: ms,
                    toReference: e => e.applyMatrix3(Vs),
                    fromReference: e => e.applyMatrix3(Gs)
                },
                [us]: {
                    transfer: ps,
                    primaries: ms,
                    toReference: e => e.convertSRGBToLinear().applyMatrix3(Vs),
                    fromReference: e => e.applyMatrix3(Gs).convertLinearToSRGB()
                }
            }
              , js = new Set([cs, ds])
              , Xs = {
                enabled: !0,
                _workingColorSpace: cs,
                get workingColorSpace() {
                    return this._workingColorSpace
                },
                set workingColorSpace(e) {
                    if (!js.has(e))
                        throw new Error(`Unsupported working color space, "${e}".`);
                    this._workingColorSpace = e
                },
                convert: function(e, t, n) {
                    if (!1 === this.enabled || t === n || !t || !n)
                        return e;
                    const r = Ws[t].toReference;
                    return (0,
                    Ws[n].fromReference)(r(e))
                },
                fromWorkingColorSpace: function(e, t) {
                    return this.convert(e, this._workingColorSpace, t)
                },
                toWorkingColorSpace: function(e, t) {
                    return this.convert(e, t, this._workingColorSpace)
                },
                getPrimaries: function(e) {
                    return Ws[e].primaries
                },
                getTransfer: function(e) {
                    return e === os ? hs : Ws[e].transfer
                }
            };
            function qs(e) {
                return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
            }
            function Ys(e) {
                return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
            }
            let $s;
            class Ks {
                static getDataURL(e) {
                    if (/^data:/i.test(e.src))
                        return e.src;
                    if ("undefined" == typeof HTMLCanvasElement)
                        return e.src;
                    let t;
                    if (e instanceof HTMLCanvasElement)
                        t = e;
                    else {
                        void 0 === $s && ($s = Fs("canvas")),
                        $s.width = e.width,
                        $s.height = e.height;
                        const n = $s.getContext("2d");
                        e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height),
                        t = $s
                    }
                    return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e),
                    t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
                }
                static sRGBToLinear(e) {
                    if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                        const t = Fs("canvas");
                        t.width = e.width,
                        t.height = e.height;
                        const n = t.getContext("2d");
                        n.drawImage(e, 0, 0, e.width, e.height);
                        const r = n.getImageData(0, 0, e.width, e.height)
                          , i = r.data;
                        for (let e = 0; e < i.length; e++)
                            i[e] = 255 * qs(i[e] / 255);
                        return n.putImageData(r, 0, 0),
                        t
                    }
                    if (e.data) {
                        const t = e.data.slice(0);
                        for (let e = 0; e < t.length; e++)
                            t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e] = Math.floor(255 * qs(t[e] / 255)) : t[e] = qs(t[e]);
                        return {
                            data: t,
                            width: e.width,
                            height: e.height
                        }
                    }
                    return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
                    e
                }
            }
            let Zs = 0;
            class Js {
                constructor(e=null) {
                    this.isSource = !0,
                    Object.defineProperty(this, "id", {
                        value: Zs++
                    }),
                    this.uuid = Ts(),
                    this.data = e,
                    this.dataReady = !0,
                    this.version = 0
                }
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
                toJSON(e) {
                    const t = void 0 === e || "string" == typeof e;
                    if (!t && void 0 !== e.images[this.uuid])
                        return e.images[this.uuid];
                    const n = {
                        uuid: this.uuid,
                        url: ""
                    }
                      , r = this.data;
                    if (null !== r) {
                        let e;
                        if (Array.isArray(r)) {
                            e = [];
                            for (let t = 0, n = r.length; t < n; t++)
                                r[t].isDataTexture ? e.push(Qs(r[t].image)) : e.push(Qs(r[t]))
                        } else
                            e = Qs(r);
                        n.url = e
                    }
                    return t || (e.images[this.uuid] = n),
                    n
                }
            }
            function Qs(e) {
                return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? Ks.getDataURL(e) : e.data ? {
                    data: Array.from(e.data),
                    width: e.width,
                    height: e.height,
                    type: e.data.constructor.name
                } : (console.warn("THREE.Texture: Unable to serialize Texture."),
                {})
            }
            let eo = 0;
            class to extends Es {
                constructor(e=to.DEFAULT_IMAGE, t=to.DEFAULT_MAPPING, n=1001, r=1001, i=1006, a=1008, s=1023, o=1009, l=to.DEFAULT_ANISOTROPY, c="") {
                    super(),
                    this.isTexture = !0,
                    Object.defineProperty(this, "id", {
                        value: eo++
                    }),
                    this.uuid = Ts(),
                    this.name = "",
                    this.source = new Js(e),
                    this.mipmaps = [],
                    this.mapping = t,
                    this.channel = 0,
                    this.wrapS = n,
                    this.wrapT = r,
                    this.magFilter = i,
                    this.minFilter = a,
                    this.anisotropy = l,
                    this.format = s,
                    this.internalFormat = null,
                    this.type = o,
                    this.offset = new Is(0,0),
                    this.repeat = new Is(1,1),
                    this.center = new Is(0,0),
                    this.rotation = 0,
                    this.matrixAutoUpdate = !0,
                    this.matrix = new Ns,
                    this.generateMipmaps = !0,
                    this.premultiplyAlpha = !1,
                    this.flipY = !0,
                    this.unpackAlignment = 4,
                    this.colorSpace = c,
                    this.userData = {},
                    this.version = 0,
                    this.onUpdate = null,
                    this.isRenderTargetTexture = !1,
                    this.needsPMREMUpdate = !1
                }
                get image() {
                    return this.source.data
                }
                set image(e=null) {
                    this.source.data = e
                }
                updateMatrix() {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.name = e.name,
                    this.source = e.source,
                    this.mipmaps = e.mipmaps.slice(0),
                    this.mapping = e.mapping,
                    this.channel = e.channel,
                    this.wrapS = e.wrapS,
                    this.wrapT = e.wrapT,
                    this.magFilter = e.magFilter,
                    this.minFilter = e.minFilter,
                    this.anisotropy = e.anisotropy,
                    this.format = e.format,
                    this.internalFormat = e.internalFormat,
                    this.type = e.type,
                    this.offset.copy(e.offset),
                    this.repeat.copy(e.repeat),
                    this.center.copy(e.center),
                    this.rotation = e.rotation,
                    this.matrixAutoUpdate = e.matrixAutoUpdate,
                    this.matrix.copy(e.matrix),
                    this.generateMipmaps = e.generateMipmaps,
                    this.premultiplyAlpha = e.premultiplyAlpha,
                    this.flipY = e.flipY,
                    this.unpackAlignment = e.unpackAlignment,
                    this.colorSpace = e.colorSpace,
                    this.userData = JSON.parse(JSON.stringify(e.userData)),
                    this.needsUpdate = !0,
                    this
                }
                toJSON(e) {
                    const t = void 0 === e || "string" == typeof e;
                    if (!t && void 0 !== e.textures[this.uuid])
                        return e.textures[this.uuid];
                    const n = {
                        metadata: {
                            version: 4.6,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        image: this.source.toJSON(e).uuid,
                        mapping: this.mapping,
                        channel: this.channel,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        internalFormat: this.internalFormat,
                        type: this.type,
                        colorSpace: this.colorSpace,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY,
                        generateMipmaps: this.generateMipmaps,
                        premultiplyAlpha: this.premultiplyAlpha,
                        unpackAlignment: this.unpackAlignment
                    };
                    return Object.keys(this.userData).length > 0 && (n.userData = this.userData),
                    t || (e.textures[this.uuid] = n),
                    n
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
                transformUv(e) {
                    if (300 !== this.mapping)
                        return e;
                    if (e.applyMatrix3(this.matrix),
                    e.x < 0 || e.x > 1)
                        switch (this.wrapS) {
                        case La:
                            e.x = e.x - Math.floor(e.x);
                            break;
                        case Oa:
                            e.x = e.x < 0 ? 0 : 1;
                            break;
                        case Da:
                            1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                        }
                    if (e.y < 0 || e.y > 1)
                        switch (this.wrapT) {
                        case La:
                            e.y = e.y - Math.floor(e.y);
                            break;
                        case Oa:
                            e.y = e.y < 0 ? 0 : 1;
                            break;
                        case Da:
                            1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                        }
                    return this.flipY && (e.y = 1 - e.y),
                    e
                }
                set needsUpdate(e) {
                    !0 === e && (this.version++,
                    this.source.needsUpdate = !0)
                }
            }
            to.DEFAULT_IMAGE = null,
            to.DEFAULT_MAPPING = 300,
            to.DEFAULT_ANISOTROPY = 1;
            class no {
                constructor(e=0, t=0, n=0, r=1) {
                    no.prototype.isVector4 = !0,
                    this.x = e,
                    this.y = t,
                    this.z = n,
                    this.w = r
                }
                get width() {
                    return this.z
                }
                set width(e) {
                    this.z = e
                }
                get height() {
                    return this.w
                }
                set height(e) {
                    this.w = e
                }
                set(e, t, n, r) {
                    return this.x = e,
                    this.y = t,
                    this.z = n,
                    this.w = r,
                    this
                }
                setScalar(e) {
                    return this.x = e,
                    this.y = e,
                    this.z = e,
                    this.w = e,
                    this
                }
                setX(e) {
                    return this.x = e,
                    this
                }
                setY(e) {
                    return this.y = e,
                    this
                }
                setZ(e) {
                    return this.z = e,
                    this
                }
                setW(e) {
                    return this.w = e,
                    this
                }
                setComponent(e, t) {
                    switch (e) {
                    case 0:
                        this.x = t;
                        break;
                    case 1:
                        this.y = t;
                        break;
                    case 2:
                        this.z = t;
                        break;
                    case 3:
                        this.w = t;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                    }
                    return this
                }
                getComponent(e) {
                    switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw new Error("index is out of range: " + e)
                    }
                }
                clone() {
                    return new this.constructor(this.x,this.y,this.z,this.w)
                }
                copy(e) {
                    return this.x = e.x,
                    this.y = e.y,
                    this.z = e.z,
                    this.w = void 0 !== e.w ? e.w : 1,
                    this
                }
                add(e) {
                    return this.x += e.x,
                    this.y += e.y,
                    this.z += e.z,
                    this.w += e.w,
                    this
                }
                addScalar(e) {
                    return this.x += e,
                    this.y += e,
                    this.z += e,
                    this.w += e,
                    this
                }
                addVectors(e, t) {
                    return this.x = e.x + t.x,
                    this.y = e.y + t.y,
                    this.z = e.z + t.z,
                    this.w = e.w + t.w,
                    this
                }
                addScaledVector(e, t) {
                    return this.x += e.x * t,
                    this.y += e.y * t,
                    this.z += e.z * t,
                    this.w += e.w * t,
                    this
                }
                sub(e) {
                    return this.x -= e.x,
                    this.y -= e.y,
                    this.z -= e.z,
                    this.w -= e.w,
                    this
                }
                subScalar(e) {
                    return this.x -= e,
                    this.y -= e,
                    this.z -= e,
                    this.w -= e,
                    this
                }
                subVectors(e, t) {
                    return this.x = e.x - t.x,
                    this.y = e.y - t.y,
                    this.z = e.z - t.z,
                    this.w = e.w - t.w,
                    this
                }
                multiply(e) {
                    return this.x *= e.x,
                    this.y *= e.y,
                    this.z *= e.z,
                    this.w *= e.w,
                    this
                }
                multiplyScalar(e) {
                    return this.x *= e,
                    this.y *= e,
                    this.z *= e,
                    this.w *= e,
                    this
                }
                applyMatrix4(e) {
                    const t = this.x
                      , n = this.y
                      , r = this.z
                      , i = this.w
                      , a = e.elements;
                    return this.x = a[0] * t + a[4] * n + a[8] * r + a[12] * i,
                    this.y = a[1] * t + a[5] * n + a[9] * r + a[13] * i,
                    this.z = a[2] * t + a[6] * n + a[10] * r + a[14] * i,
                    this.w = a[3] * t + a[7] * n + a[11] * r + a[15] * i,
                    this
                }
                divideScalar(e) {
                    return this.multiplyScalar(1 / e)
                }
                setAxisAngleFromQuaternion(e) {
                    this.w = 2 * Math.acos(e.w);
                    const t = Math.sqrt(1 - e.w * e.w);
                    return t < 1e-4 ? (this.x = 1,
                    this.y = 0,
                    this.z = 0) : (this.x = e.x / t,
                    this.y = e.y / t,
                    this.z = e.z / t),
                    this
                }
                setAxisAngleFromRotationMatrix(e) {
                    let t, n, r, i;
                    const a = .01
                      , s = .1
                      , o = e.elements
                      , l = o[0]
                      , c = o[4]
                      , u = o[8]
                      , d = o[1]
                      , h = o[5]
                      , p = o[9]
                      , f = o[2]
                      , m = o[6]
                      , g = o[10];
                    if (Math.abs(c - d) < a && Math.abs(u - f) < a && Math.abs(p - m) < a) {
                        if (Math.abs(c + d) < s && Math.abs(u + f) < s && Math.abs(p + m) < s && Math.abs(l + h + g - 3) < s)
                            return this.set(1, 0, 0, 0),
                            this;
                        t = Math.PI;
                        const e = (l + 1) / 2
                          , o = (h + 1) / 2
                          , v = (g + 1) / 2
                          , _ = (c + d) / 4
                          , y = (u + f) / 4
                          , x = (p + m) / 4;
                        return e > o && e > v ? e < a ? (n = 0,
                        r = .707106781,
                        i = .707106781) : (n = Math.sqrt(e),
                        r = _ / n,
                        i = y / n) : o > v ? o < a ? (n = .707106781,
                        r = 0,
                        i = .707106781) : (r = Math.sqrt(o),
                        n = _ / r,
                        i = x / r) : v < a ? (n = .707106781,
                        r = .707106781,
                        i = 0) : (i = Math.sqrt(v),
                        n = y / i,
                        r = x / i),
                        this.set(n, r, i, t),
                        this
                    }
                    let v = Math.sqrt((m - p) * (m - p) + (u - f) * (u - f) + (d - c) * (d - c));
                    return Math.abs(v) < .001 && (v = 1),
                    this.x = (m - p) / v,
                    this.y = (u - f) / v,
                    this.z = (d - c) / v,
                    this.w = Math.acos((l + h + g - 1) / 2),
                    this
                }
                min(e) {
                    return this.x = Math.min(this.x, e.x),
                    this.y = Math.min(this.y, e.y),
                    this.z = Math.min(this.z, e.z),
                    this.w = Math.min(this.w, e.w),
                    this
                }
                max(e) {
                    return this.x = Math.max(this.x, e.x),
                    this.y = Math.max(this.y, e.y),
                    this.z = Math.max(this.z, e.z),
                    this.w = Math.max(this.w, e.w),
                    this
                }
                clamp(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)),
                    this.y = Math.max(e.y, Math.min(t.y, this.y)),
                    this.z = Math.max(e.z, Math.min(t.z, this.z)),
                    this.w = Math.max(e.w, Math.min(t.w, this.w)),
                    this
                }
                clampScalar(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)),
                    this.y = Math.max(e, Math.min(t, this.y)),
                    this.z = Math.max(e, Math.min(t, this.z)),
                    this.w = Math.max(e, Math.min(t, this.w)),
                    this
                }
                clampLength(e, t) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                }
                floor() {
                    return this.x = Math.floor(this.x),
                    this.y = Math.floor(this.y),
                    this.z = Math.floor(this.z),
                    this.w = Math.floor(this.w),
                    this
                }
                ceil() {
                    return this.x = Math.ceil(this.x),
                    this.y = Math.ceil(this.y),
                    this.z = Math.ceil(this.z),
                    this.w = Math.ceil(this.w),
                    this
                }
                round() {
                    return this.x = Math.round(this.x),
                    this.y = Math.round(this.y),
                    this.z = Math.round(this.z),
                    this.w = Math.round(this.w),
                    this
                }
                roundToZero() {
                    return this.x = Math.trunc(this.x),
                    this.y = Math.trunc(this.y),
                    this.z = Math.trunc(this.z),
                    this.w = Math.trunc(this.w),
                    this
                }
                negate() {
                    return this.x = -this.x,
                    this.y = -this.y,
                    this.z = -this.z,
                    this.w = -this.w,
                    this
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(e) {
                    return this.normalize().multiplyScalar(e)
                }
                lerp(e, t) {
                    return this.x += (e.x - this.x) * t,
                    this.y += (e.y - this.y) * t,
                    this.z += (e.z - this.z) * t,
                    this.w += (e.w - this.w) * t,
                    this
                }
                lerpVectors(e, t, n) {
                    return this.x = e.x + (t.x - e.x) * n,
                    this.y = e.y + (t.y - e.y) * n,
                    this.z = e.z + (t.z - e.z) * n,
                    this.w = e.w + (t.w - e.w) * n,
                    this
                }
                equals(e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
                }
                fromArray(e, t=0) {
                    return this.x = e[t],
                    this.y = e[t + 1],
                    this.z = e[t + 2],
                    this.w = e[t + 3],
                    this
                }
                toArray(e=[], t=0) {
                    return e[t] = this.x,
                    e[t + 1] = this.y,
                    e[t + 2] = this.z,
                    e[t + 3] = this.w,
                    e
                }
                fromBufferAttribute(e, t) {
                    return this.x = e.getX(t),
                    this.y = e.getY(t),
                    this.z = e.getZ(t),
                    this.w = e.getW(t),
                    this
                }
                random() {
                    return this.x = Math.random(),
                    this.y = Math.random(),
                    this.z = Math.random(),
                    this.w = Math.random(),
                    this
                }
                *[Symbol.iterator]() {
                    yield this.x,
                    yield this.y,
                    yield this.z,
                    yield this.w
                }
            }
            class ro extends Es {
                constructor(e=1, t=1, n={}) {
                    super(),
                    this.isRenderTarget = !0,
                    this.width = e,
                    this.height = t,
                    this.depth = 1,
                    this.scissor = new no(0,0,e,t),
                    this.scissorTest = !1,
                    this.viewport = new no(0,0,e,t);
                    const r = {
                        width: e,
                        height: t,
                        depth: 1
                    };
                    n = Object.assign({
                        generateMipmaps: !1,
                        internalFormat: null,
                        minFilter: ka,
                        depthBuffer: !0,
                        stencilBuffer: !1,
                        depthTexture: null,
                        samples: 0,
                        count: 1
                    }, n);
                    const i = new to(r,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.colorSpace);
                    i.flipY = !1,
                    i.generateMipmaps = n.generateMipmaps,
                    i.internalFormat = n.internalFormat,
                    this.textures = [];
                    const a = n.count;
                    for (let e = 0; e < a; e++)
                        this.textures[e] = i.clone(),
                        this.textures[e].isRenderTargetTexture = !0;
                    this.depthBuffer = n.depthBuffer,
                    this.stencilBuffer = n.stencilBuffer,
                    this.depthTexture = n.depthTexture,
                    this.samples = n.samples
                }
                get texture() {
                    return this.textures[0]
                }
                set texture(e) {
                    this.textures[0] = e
                }
                setSize(e, t, n=1) {
                    if (this.width !== e || this.height !== t || this.depth !== n) {
                        this.width = e,
                        this.height = t,
                        this.depth = n;
                        for (let r = 0, i = this.textures.length; r < i; r++)
                            this.textures[r].image.width = e,
                            this.textures[r].image.height = t,
                            this.textures[r].image.depth = n;
                        this.dispose()
                    }
                    this.viewport.set(0, 0, e, t),
                    this.scissor.set(0, 0, e, t)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    this.width = e.width,
                    this.height = e.height,
                    this.depth = e.depth,
                    this.scissor.copy(e.scissor),
                    this.scissorTest = e.scissorTest,
                    this.viewport.copy(e.viewport),
                    this.textures.length = 0;
                    for (let t = 0, n = e.textures.length; t < n; t++)
                        this.textures[t] = e.textures[t].clone(),
                        this.textures[t].isRenderTargetTexture = !0;
                    const t = Object.assign({}, e.texture.image);
                    return this.texture.source = new Js(t),
                    this.depthBuffer = e.depthBuffer,
                    this.stencilBuffer = e.stencilBuffer,
                    null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()),
                    this.samples = e.samples,
                    this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            class io extends ro {
                constructor(e=1, t=1, n={}) {
                    super(e, t, n),
                    this.isWebGLRenderTarget = !0
                }
            }
            class ao extends to {
                constructor(e=null, t=1, n=1, r=1) {
                    super(null),
                    this.isDataArrayTexture = !0,
                    this.image = {
                        data: e,
                        width: t,
                        height: n,
                        depth: r
                    },
                    this.magFilter = Ia,
                    this.minFilter = Ia,
                    this.wrapR = Oa,
                    this.generateMipmaps = !1,
                    this.flipY = !1,
                    this.unpackAlignment = 1
                }
            }
            class so extends to {
                constructor(e=null, t=1, n=1, r=1) {
                    super(null),
                    this.isData3DTexture = !0,
                    this.image = {
                        data: e,
                        width: t,
                        height: n,
                        depth: r
                    },
                    this.magFilter = Ia,
                    this.minFilter = Ia,
                    this.wrapR = Oa,
                    this.generateMipmaps = !1,
                    this.flipY = !1,
                    this.unpackAlignment = 1
                }
            }
            class oo {
                constructor(e=0, t=0, n=0, r=1) {
                    this.isQuaternion = !0,
                    this._x = e,
                    this._y = t,
                    this._z = n,
                    this._w = r
                }
                static slerpFlat(e, t, n, r, i, a, s) {
                    let o = n[r + 0]
                      , l = n[r + 1]
                      , c = n[r + 2]
                      , u = n[r + 3];
                    const d = i[a + 0]
                      , h = i[a + 1]
                      , p = i[a + 2]
                      , f = i[a + 3];
                    if (0 === s)
                        return e[t + 0] = o,
                        e[t + 1] = l,
                        e[t + 2] = c,
                        void (e[t + 3] = u);
                    if (1 === s)
                        return e[t + 0] = d,
                        e[t + 1] = h,
                        e[t + 2] = p,
                        void (e[t + 3] = f);
                    if (u !== f || o !== d || l !== h || c !== p) {
                        let e = 1 - s;
                        const t = o * d + l * h + c * p + u * f
                          , n = t >= 0 ? 1 : -1
                          , r = 1 - t * t;
                        if (r > Number.EPSILON) {
                            const i = Math.sqrt(r)
                              , a = Math.atan2(i, t * n);
                            e = Math.sin(e * a) / i,
                            s = Math.sin(s * a) / i
                        }
                        const i = s * n;
                        if (o = o * e + d * i,
                        l = l * e + h * i,
                        c = c * e + p * i,
                        u = u * e + f * i,
                        e === 1 - s) {
                            const e = 1 / Math.sqrt(o * o + l * l + c * c + u * u);
                            o *= e,
                            l *= e,
                            c *= e,
                            u *= e
                        }
                    }
                    e[t] = o,
                    e[t + 1] = l,
                    e[t + 2] = c,
                    e[t + 3] = u
                }
                static multiplyQuaternionsFlat(e, t, n, r, i, a) {
                    const s = n[r]
                      , o = n[r + 1]
                      , l = n[r + 2]
                      , c = n[r + 3]
                      , u = i[a]
                      , d = i[a + 1]
                      , h = i[a + 2]
                      , p = i[a + 3];
                    return e[t] = s * p + c * u + o * h - l * d,
                    e[t + 1] = o * p + c * d + l * u - s * h,
                    e[t + 2] = l * p + c * h + s * d - o * u,
                    e[t + 3] = c * p - s * u - o * d - l * h,
                    e
                }
                get x() {
                    return this._x
                }
                set x(e) {
                    this._x = e,
                    this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(e) {
                    this._y = e,
                    this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(e) {
                    this._z = e,
                    this._onChangeCallback()
                }
                get w() {
                    return this._w
                }
                set w(e) {
                    this._w = e,
                    this._onChangeCallback()
                }
                set(e, t, n, r) {
                    return this._x = e,
                    this._y = t,
                    this._z = n,
                    this._w = r,
                    this._onChangeCallback(),
                    this
                }
                clone() {
                    return new this.constructor(this._x,this._y,this._z,this._w)
                }
                copy(e) {
                    return this._x = e.x,
                    this._y = e.y,
                    this._z = e.z,
                    this._w = e.w,
                    this._onChangeCallback(),
                    this
                }
                setFromEuler(e, t=!0) {
                    const n = e._x
                      , r = e._y
                      , i = e._z
                      , a = e._order
                      , s = Math.cos
                      , o = Math.sin
                      , l = s(n / 2)
                      , c = s(r / 2)
                      , u = s(i / 2)
                      , d = o(n / 2)
                      , h = o(r / 2)
                      , p = o(i / 2);
                    switch (a) {
                    case "XYZ":
                        this._x = d * c * u + l * h * p,
                        this._y = l * h * u - d * c * p,
                        this._z = l * c * p + d * h * u,
                        this._w = l * c * u - d * h * p;
                        break;
                    case "YXZ":
                        this._x = d * c * u + l * h * p,
                        this._y = l * h * u - d * c * p,
                        this._z = l * c * p - d * h * u,
                        this._w = l * c * u + d * h * p;
                        break;
                    case "ZXY":
                        this._x = d * c * u - l * h * p,
                        this._y = l * h * u + d * c * p,
                        this._z = l * c * p + d * h * u,
                        this._w = l * c * u - d * h * p;
                        break;
                    case "ZYX":
                        this._x = d * c * u - l * h * p,
                        this._y = l * h * u + d * c * p,
                        this._z = l * c * p - d * h * u,
                        this._w = l * c * u + d * h * p;
                        break;
                    case "YZX":
                        this._x = d * c * u + l * h * p,
                        this._y = l * h * u + d * c * p,
                        this._z = l * c * p - d * h * u,
                        this._w = l * c * u - d * h * p;
                        break;
                    case "XZY":
                        this._x = d * c * u - l * h * p,
                        this._y = l * h * u - d * c * p,
                        this._z = l * c * p + d * h * u,
                        this._w = l * c * u + d * h * p;
                        break;
                    default:
                        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a)
                    }
                    return !0 === t && this._onChangeCallback(),
                    this
                }
                setFromAxisAngle(e, t) {
                    const n = t / 2
                      , r = Math.sin(n);
                    return this._x = e.x * r,
                    this._y = e.y * r,
                    this._z = e.z * r,
                    this._w = Math.cos(n),
                    this._onChangeCallback(),
                    this
                }
                setFromRotationMatrix(e) {
                    const t = e.elements
                      , n = t[0]
                      , r = t[4]
                      , i = t[8]
                      , a = t[1]
                      , s = t[5]
                      , o = t[9]
                      , l = t[2]
                      , c = t[6]
                      , u = t[10]
                      , d = n + s + u;
                    if (d > 0) {
                        const e = .5 / Math.sqrt(d + 1);
                        this._w = .25 / e,
                        this._x = (c - o) * e,
                        this._y = (i - l) * e,
                        this._z = (a - r) * e
                    } else if (n > s && n > u) {
                        const e = 2 * Math.sqrt(1 + n - s - u);
                        this._w = (c - o) / e,
                        this._x = .25 * e,
                        this._y = (r + a) / e,
                        this._z = (i + l) / e
                    } else if (s > u) {
                        const e = 2 * Math.sqrt(1 + s - n - u);
                        this._w = (i - l) / e,
                        this._x = (r + a) / e,
                        this._y = .25 * e,
                        this._z = (o + c) / e
                    } else {
                        const e = 2 * Math.sqrt(1 + u - n - s);
                        this._w = (a - r) / e,
                        this._x = (i + l) / e,
                        this._y = (o + c) / e,
                        this._z = .25 * e
                    }
                    return this._onChangeCallback(),
                    this
                }
                setFromUnitVectors(e, t) {
                    let n = e.dot(t) + 1;
                    return n < Number.EPSILON ? (n = 0,
                    Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
                    this._y = e.x,
                    this._z = 0,
                    this._w = n) : (this._x = 0,
                    this._y = -e.z,
                    this._z = e.y,
                    this._w = n)) : (this._x = e.y * t.z - e.z * t.y,
                    this._y = e.z * t.x - e.x * t.z,
                    this._z = e.x * t.y - e.y * t.x,
                    this._w = n),
                    this.normalize()
                }
                angleTo(e) {
                    return 2 * Math.acos(Math.abs(As(this.dot(e), -1, 1)))
                }
                rotateTowards(e, t) {
                    const n = this.angleTo(e);
                    if (0 === n)
                        return this;
                    const r = Math.min(1, t / n);
                    return this.slerp(e, r),
                    this
                }
                identity() {
                    return this.set(0, 0, 0, 1)
                }
                invert() {
                    return this.conjugate()
                }
                conjugate() {
                    return this._x *= -1,
                    this._y *= -1,
                    this._z *= -1,
                    this._onChangeCallback(),
                    this
                }
                dot(e) {
                    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
                }
                lengthSq() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                }
                length() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                }
                normalize() {
                    let e = this.length();
                    return 0 === e ? (this._x = 0,
                    this._y = 0,
                    this._z = 0,
                    this._w = 1) : (e = 1 / e,
                    this._x = this._x * e,
                    this._y = this._y * e,
                    this._z = this._z * e,
                    this._w = this._w * e),
                    this._onChangeCallback(),
                    this
                }
                multiply(e) {
                    return this.multiplyQuaternions(this, e)
                }
                premultiply(e) {
                    return this.multiplyQuaternions(e, this)
                }
                multiplyQuaternions(e, t) {
                    const n = e._x
                      , r = e._y
                      , i = e._z
                      , a = e._w
                      , s = t._x
                      , o = t._y
                      , l = t._z
                      , c = t._w;
                    return this._x = n * c + a * s + r * l - i * o,
                    this._y = r * c + a * o + i * s - n * l,
                    this._z = i * c + a * l + n * o - r * s,
                    this._w = a * c - n * s - r * o - i * l,
                    this._onChangeCallback(),
                    this
                }
                slerp(e, t) {
                    if (0 === t)
                        return this;
                    if (1 === t)
                        return this.copy(e);
                    const n = this._x
                      , r = this._y
                      , i = this._z
                      , a = this._w;
                    let s = a * e._w + n * e._x + r * e._y + i * e._z;
                    if (s < 0 ? (this._w = -e._w,
                    this._x = -e._x,
                    this._y = -e._y,
                    this._z = -e._z,
                    s = -s) : this.copy(e),
                    s >= 1)
                        return this._w = a,
                        this._x = n,
                        this._y = r,
                        this._z = i,
                        this;
                    const o = 1 - s * s;
                    if (o <= Number.EPSILON) {
                        const e = 1 - t;
                        return this._w = e * a + t * this._w,
                        this._x = e * n + t * this._x,
                        this._y = e * r + t * this._y,
                        this._z = e * i + t * this._z,
                        this.normalize(),
                        this
                    }
                    const l = Math.sqrt(o)
                      , c = Math.atan2(l, s)
                      , u = Math.sin((1 - t) * c) / l
                      , d = Math.sin(t * c) / l;
                    return this._w = a * u + this._w * d,
                    this._x = n * u + this._x * d,
                    this._y = r * u + this._y * d,
                    this._z = i * u + this._z * d,
                    this._onChangeCallback(),
                    this
                }
                slerpQuaternions(e, t, n) {
                    return this.copy(e).slerp(t, n)
                }
                random() {
                    const e = 2 * Math.PI * Math.random()
                      , t = 2 * Math.PI * Math.random()
                      , n = Math.random()
                      , r = Math.sqrt(1 - n)
                      , i = Math.sqrt(n);
                    return this.set(r * Math.sin(e), r * Math.cos(e), i * Math.sin(t), i * Math.cos(t))
                }
                equals(e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
                }
                fromArray(e, t=0) {
                    return this._x = e[t],
                    this._y = e[t + 1],
                    this._z = e[t + 2],
                    this._w = e[t + 3],
                    this._onChangeCallback(),
                    this
                }
                toArray(e=[], t=0) {
                    return e[t] = this._x,
                    e[t + 1] = this._y,
                    e[t + 2] = this._z,
                    e[t + 3] = this._w,
                    e
                }
                fromBufferAttribute(e, t) {
                    return this._x = e.getX(t),
                    this._y = e.getY(t),
                    this._z = e.getZ(t),
                    this._w = e.getW(t),
                    this._onChangeCallback(),
                    this
                }
                toJSON() {
                    return this.toArray()
                }
                _onChange(e) {
                    return this._onChangeCallback = e,
                    this
                }
                _onChangeCallback() {}
                *[Symbol.iterator]() {
                    yield this._x,
                    yield this._y,
                    yield this._z,
                    yield this._w
                }
            }
            class lo {
                constructor(e=0, t=0, n=0) {
                    lo.prototype.isVector3 = !0,
                    this.x = e,
                    this.y = t,
                    this.z = n
                }
                set(e, t, n) {
                    return void 0 === n && (n = this.z),
                    this.x = e,
                    this.y = t,
                    this.z = n,
                    this
                }
                setScalar(e) {
                    return this.x = e,
                    this.y = e,
                    this.z = e,
                    this
                }
                setX(e) {
                    return this.x = e,
                    this
                }
                setY(e) {
                    return this.y = e,
                    this
                }
                setZ(e) {
                    return this.z = e,
                    this
                }
                setComponent(e, t) {
                    switch (e) {
                    case 0:
                        this.x = t;
                        break;
                    case 1:
                        this.y = t;
                        break;
                    case 2:
                        this.z = t;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                    }
                    return this
                }
                getComponent(e) {
                    switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw new Error("index is out of range: " + e)
                    }
                }
                clone() {
                    return new this.constructor(this.x,this.y,this.z)
                }
                copy(e) {
                    return this.x = e.x,
                    this.y = e.y,
                    this.z = e.z,
                    this
                }
                add(e) {
                    return this.x += e.x,
                    this.y += e.y,
                    this.z += e.z,
                    this
                }
                addScalar(e) {
                    return this.x += e,
                    this.y += e,
                    this.z += e,
                    this
                }
                addVectors(e, t) {
                    return this.x = e.x + t.x,
                    this.y = e.y + t.y,
                    this.z = e.z + t.z,
                    this
                }
                addScaledVector(e, t) {
                    return this.x += e.x * t,
                    this.y += e.y * t,
                    this.z += e.z * t,
                    this
                }
                sub(e) {
                    return this.x -= e.x,
                    this.y -= e.y,
                    this.z -= e.z,
                    this
                }
                subScalar(e) {
                    return this.x -= e,
                    this.y -= e,
                    this.z -= e,
                    this
                }
                subVectors(e, t) {
                    return this.x = e.x - t.x,
                    this.y = e.y - t.y,
                    this.z = e.z - t.z,
                    this
                }
                multiply(e) {
                    return this.x *= e.x,
                    this.y *= e.y,
                    this.z *= e.z,
                    this
                }
                multiplyScalar(e) {
                    return this.x *= e,
                    this.y *= e,
                    this.z *= e,
                    this
                }
                multiplyVectors(e, t) {
                    return this.x = e.x * t.x,
                    this.y = e.y * t.y,
                    this.z = e.z * t.z,
                    this
                }
                applyEuler(e) {
                    return this.applyQuaternion(uo.setFromEuler(e))
                }
                applyAxisAngle(e, t) {
                    return this.applyQuaternion(uo.setFromAxisAngle(e, t))
                }
                applyMatrix3(e) {
                    const t = this.x
                      , n = this.y
                      , r = this.z
                      , i = e.elements;
                    return this.x = i[0] * t + i[3] * n + i[6] * r,
                    this.y = i[1] * t + i[4] * n + i[7] * r,
                    this.z = i[2] * t + i[5] * n + i[8] * r,
                    this
                }
                applyNormalMatrix(e) {
                    return this.applyMatrix3(e).normalize()
                }
                applyMatrix4(e) {
                    const t = this.x
                      , n = this.y
                      , r = this.z
                      , i = e.elements
                      , a = 1 / (i[3] * t + i[7] * n + i[11] * r + i[15]);
                    return this.x = (i[0] * t + i[4] * n + i[8] * r + i[12]) * a,
                    this.y = (i[1] * t + i[5] * n + i[9] * r + i[13]) * a,
                    this.z = (i[2] * t + i[6] * n + i[10] * r + i[14]) * a,
                    this
                }
                applyQuaternion(e) {
                    const t = this.x
                      , n = this.y
                      , r = this.z
                      , i = e.x
                      , a = e.y
                      , s = e.z
                      , o = e.w
                      , l = 2 * (a * r - s * n)
                      , c = 2 * (s * t - i * r)
                      , u = 2 * (i * n - a * t);
                    return this.x = t + o * l + a * u - s * c,
                    this.y = n + o * c + s * l - i * u,
                    this.z = r + o * u + i * c - a * l,
                    this
                }
                project(e) {
                    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
                }
                unproject(e) {
                    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
                }
                transformDirection(e) {
                    const t = this.x
                      , n = this.y
                      , r = this.z
                      , i = e.elements;
                    return this.x = i[0] * t + i[4] * n + i[8] * r,
                    this.y = i[1] * t + i[5] * n + i[9] * r,
                    this.z = i[2] * t + i[6] * n + i[10] * r,
                    this.normalize()
                }
                divide(e) {
                    return this.x /= e.x,
                    this.y /= e.y,
                    this.z /= e.z,
                    this
                }
                divideScalar(e) {
                    return this.multiplyScalar(1 / e)
                }
                min(e) {
                    return this.x = Math.min(this.x, e.x),
                    this.y = Math.min(this.y, e.y),
                    this.z = Math.min(this.z, e.z),
                    this
                }
                max(e) {
                    return this.x = Math.max(this.x, e.x),
                    this.y = Math.max(this.y, e.y),
                    this.z = Math.max(this.z, e.z),
                    this
                }
                clamp(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)),
                    this.y = Math.max(e.y, Math.min(t.y, this.y)),
                    this.z = Math.max(e.z, Math.min(t.z, this.z)),
                    this
                }
                clampScalar(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)),
                    this.y = Math.max(e, Math.min(t, this.y)),
                    this.z = Math.max(e, Math.min(t, this.z)),
                    this
                }
                clampLength(e, t) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                }
                floor() {
                    return this.x = Math.floor(this.x),
                    this.y = Math.floor(this.y),
                    this.z = Math.floor(this.z),
                    this
                }
                ceil() {
                    return this.x = Math.ceil(this.x),
                    this.y = Math.ceil(this.y),
                    this.z = Math.ceil(this.z),
                    this
                }
                round() {
                    return this.x = Math.round(this.x),
                    this.y = Math.round(this.y),
                    this.z = Math.round(this.z),
                    this
                }
                roundToZero() {
                    return this.x = Math.trunc(this.x),
                    this.y = Math.trunc(this.y),
                    this.z = Math.trunc(this.z),
                    this
                }
                negate() {
                    return this.x = -this.x,
                    this.y = -this.y,
                    this.z = -this.z,
                    this
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(e) {
                    return this.normalize().multiplyScalar(e)
                }
                lerp(e, t) {
                    return this.x += (e.x - this.x) * t,
                    this.y += (e.y - this.y) * t,
                    this.z += (e.z - this.z) * t,
                    this
                }
                lerpVectors(e, t, n) {
                    return this.x = e.x + (t.x - e.x) * n,
                    this.y = e.y + (t.y - e.y) * n,
                    this.z = e.z + (t.z - e.z) * n,
                    this
                }
                cross(e) {
                    return this.crossVectors(this, e)
                }
                crossVectors(e, t) {
                    const n = e.x
                      , r = e.y
                      , i = e.z
                      , a = t.x
                      , s = t.y
                      , o = t.z;
                    return this.x = r * o - i * s,
                    this.y = i * a - n * o,
                    this.z = n * s - r * a,
                    this
                }
                projectOnVector(e) {
                    const t = e.lengthSq();
                    if (0 === t)
                        return this.set(0, 0, 0);
                    const n = e.dot(this) / t;
                    return this.copy(e).multiplyScalar(n)
                }
                projectOnPlane(e) {
                    return co.copy(this).projectOnVector(e),
                    this.sub(co)
                }
                reflect(e) {
                    return this.sub(co.copy(e).multiplyScalar(2 * this.dot(e)))
                }
                angleTo(e) {
                    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
                    if (0 === t)
                        return Math.PI / 2;
                    const n = this.dot(e) / t;
                    return Math.acos(As(n, -1, 1))
                }
                distanceTo(e) {
                    return Math.sqrt(this.distanceToSquared(e))
                }
                distanceToSquared(e) {
                    const t = this.x - e.x
                      , n = this.y - e.y
                      , r = this.z - e.z;
                    return t * t + n * n + r * r
                }
                manhattanDistanceTo(e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
                }
                setFromSpherical(e) {
                    return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
                }
                setFromSphericalCoords(e, t, n) {
                    const r = Math.sin(t) * e;
                    return this.x = r * Math.sin(n),
                    this.y = Math.cos(t) * e,
                    this.z = r * Math.cos(n),
                    this
                }
                setFromCylindrical(e) {
                    return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
                }
                setFromCylindricalCoords(e, t, n) {
                    return this.x = e * Math.sin(t),
                    this.y = n,
                    this.z = e * Math.cos(t),
                    this
                }
                setFromMatrixPosition(e) {
                    const t = e.elements;
                    return this.x = t[12],
                    this.y = t[13],
                    this.z = t[14],
                    this
                }
                setFromMatrixScale(e) {
                    const t = this.setFromMatrixColumn(e, 0).length()
                      , n = this.setFromMatrixColumn(e, 1).length()
                      , r = this.setFromMatrixColumn(e, 2).length();
                    return this.x = t,
                    this.y = n,
                    this.z = r,
                    this
                }
                setFromMatrixColumn(e, t) {
                    return this.fromArray(e.elements, 4 * t)
                }
                setFromMatrix3Column(e, t) {
                    return this.fromArray(e.elements, 3 * t)
                }
                setFromEuler(e) {
                    return this.x = e._x,
                    this.y = e._y,
                    this.z = e._z,
                    this
                }
                setFromColor(e) {
                    return this.x = e.r,
                    this.y = e.g,
                    this.z = e.b,
                    this
                }
                equals(e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z
                }
                fromArray(e, t=0) {
                    return this.x = e[t],
                    this.y = e[t + 1],
                    this.z = e[t + 2],
                    this
                }
                toArray(e=[], t=0) {
                    return e[t] = this.x,
                    e[t + 1] = this.y,
                    e[t + 2] = this.z,
                    e
                }
                fromBufferAttribute(e, t) {
                    return this.x = e.getX(t),
                    this.y = e.getY(t),
                    this.z = e.getZ(t),
                    this
                }
                random() {
                    return this.x = Math.random(),
                    this.y = Math.random(),
                    this.z = Math.random(),
                    this
                }
                randomDirection() {
                    const e = Math.random() * Math.PI * 2
                      , t = 2 * Math.random() - 1
                      , n = Math.sqrt(1 - t * t);
                    return this.x = n * Math.cos(e),
                    this.y = t,
                    this.z = n * Math.sin(e),
                    this
                }
                *[Symbol.iterator]() {
                    yield this.x,
                    yield this.y,
                    yield this.z
                }
            }
            const co = new lo
              , uo = new oo;
            class ho {
                constructor(e=new lo(1 / 0,1 / 0,1 / 0), t=new lo(-1 / 0,-1 / 0,-1 / 0)) {
                    this.isBox3 = !0,
                    this.min = e,
                    this.max = t
                }
                set(e, t) {
                    return this.min.copy(e),
                    this.max.copy(t),
                    this
                }
                setFromArray(e) {
                    this.makeEmpty();
                    for (let t = 0, n = e.length; t < n; t += 3)
                        this.expandByPoint(fo.fromArray(e, t));
                    return this
                }
                setFromBufferAttribute(e) {
                    this.makeEmpty();
                    for (let t = 0, n = e.count; t < n; t++)
                        this.expandByPoint(fo.fromBufferAttribute(e, t));
                    return this
                }
                setFromPoints(e) {
                    this.makeEmpty();
                    for (let t = 0, n = e.length; t < n; t++)
                        this.expandByPoint(e[t]);
                    return this
                }
                setFromCenterAndSize(e, t) {
                    const n = fo.copy(t).multiplyScalar(.5);
                    return this.min.copy(e).sub(n),
                    this.max.copy(e).add(n),
                    this
                }
                setFromObject(e, t=!1) {
                    return this.makeEmpty(),
                    this.expandByObject(e, t)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.min.copy(e.min),
                    this.max.copy(e.max),
                    this
                }
                makeEmpty() {
                    return this.min.x = this.min.y = this.min.z = 1 / 0,
                    this.max.x = this.max.y = this.max.z = -1 / 0,
                    this
                }
                isEmpty() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                }
                getCenter(e) {
                    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                }
                getSize(e) {
                    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
                }
                expandByPoint(e) {
                    return this.min.min(e),
                    this.max.max(e),
                    this
                }
                expandByVector(e) {
                    return this.min.sub(e),
                    this.max.add(e),
                    this
                }
                expandByScalar(e) {
                    return this.min.addScalar(-e),
                    this.max.addScalar(e),
                    this
                }
                expandByObject(e, t=!1) {
                    e.updateWorldMatrix(!1, !1);
                    const n = e.geometry;
                    if (void 0 !== n) {
                        const r = n.getAttribute("position");
                        if (!0 === t && void 0 !== r && !0 !== e.isInstancedMesh)
                            for (let t = 0, n = r.count; t < n; t++)
                                !0 === e.isMesh ? e.getVertexPosition(t, fo) : fo.fromBufferAttribute(r, t),
                                fo.applyMatrix4(e.matrixWorld),
                                this.expandByPoint(fo);
                        else
                            void 0 !== e.boundingBox ? (null === e.boundingBox && e.computeBoundingBox(),
                            mo.copy(e.boundingBox)) : (null === n.boundingBox && n.computeBoundingBox(),
                            mo.copy(n.boundingBox)),
                            mo.applyMatrix4(e.matrixWorld),
                            this.union(mo)
                    }
                    const r = e.children;
                    for (let e = 0, n = r.length; e < n; e++)
                        this.expandByObject(r[e], t);
                    return this
                }
                containsPoint(e) {
                    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
                }
                containsBox(e) {
                    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
                }
                getParameter(e, t) {
                    return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
                }
                intersectsBox(e) {
                    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
                }
                intersectsSphere(e) {
                    return this.clampPoint(e.center, fo),
                    fo.distanceToSquared(e.center) <= e.radius * e.radius
                }
                intersectsPlane(e) {
                    let t, n;
                    return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
                    n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
                    n = e.normal.x * this.min.x),
                    e.normal.y > 0 ? (t += e.normal.y * this.min.y,
                    n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
                    n += e.normal.y * this.min.y),
                    e.normal.z > 0 ? (t += e.normal.z * this.min.z,
                    n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
                    n += e.normal.z * this.min.z),
                    t <= -e.constant && n >= -e.constant
                }
                intersectsTriangle(e) {
                    if (this.isEmpty())
                        return !1;
                    this.getCenter(Eo),
                    So.subVectors(this.max, Eo),
                    go.subVectors(e.a, Eo),
                    vo.subVectors(e.b, Eo),
                    _o.subVectors(e.c, Eo),
                    yo.subVectors(vo, go),
                    xo.subVectors(_o, vo),
                    bo.subVectors(go, _o);
                    let t = [0, -yo.z, yo.y, 0, -xo.z, xo.y, 0, -bo.z, bo.y, yo.z, 0, -yo.x, xo.z, 0, -xo.x, bo.z, 0, -bo.x, -yo.y, yo.x, 0, -xo.y, xo.x, 0, -bo.y, bo.x, 0];
                    return !!To(t, go, vo, _o, So) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                    !!To(t, go, vo, _o, So) && (wo.crossVectors(yo, xo),
                    t = [wo.x, wo.y, wo.z],
                    To(t, go, vo, _o, So)))
                }
                clampPoint(e, t) {
                    return t.copy(e).clamp(this.min, this.max)
                }
                distanceToPoint(e) {
                    return this.clampPoint(e, fo).distanceTo(e)
                }
                getBoundingSphere(e) {
                    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
                    e.radius = .5 * this.getSize(fo).length()),
                    e
                }
                intersect(e) {
                    return this.min.max(e.min),
                    this.max.min(e.max),
                    this.isEmpty() && this.makeEmpty(),
                    this
                }
                union(e) {
                    return this.min.min(e.min),
                    this.max.max(e.max),
                    this
                }
                applyMatrix4(e) {
                    return this.isEmpty() || (po[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
                    po[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
                    po[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
                    po[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
                    po[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
                    po[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
                    po[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
                    po[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
                    this.setFromPoints(po)),
                    this
                }
                translate(e) {
                    return this.min.add(e),
                    this.max.add(e),
                    this
                }
                equals(e) {
                    return e.min.equals(this.min) && e.max.equals(this.max)
                }
            }
            const po = [new lo, new lo, new lo, new lo, new lo, new lo, new lo, new lo]
              , fo = new lo
              , mo = new ho
              , go = new lo
              , vo = new lo
              , _o = new lo
              , yo = new lo
              , xo = new lo
              , bo = new lo
              , Eo = new lo
              , So = new lo
              , wo = new lo
              , Mo = new lo;
            function To(e, t, n, r, i) {
                for (let a = 0, s = e.length - 3; a <= s; a += 3) {
                    Mo.fromArray(e, a);
                    const s = i.x * Math.abs(Mo.x) + i.y * Math.abs(Mo.y) + i.z * Math.abs(Mo.z)
                      , o = t.dot(Mo)
                      , l = n.dot(Mo)
                      , c = r.dot(Mo);
                    if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > s)
                        return !1
                }
                return !0
            }
            const Ao = new ho
              , Co = new lo
              , Po = new lo;
            class Ro {
                constructor(e=new lo, t=-1) {
                    this.isSphere = !0,
                    this.center = e,
                    this.radius = t
                }
                set(e, t) {
                    return this.center.copy(e),
                    this.radius = t,
                    this
                }
                setFromPoints(e, t) {
                    const n = this.center;
                    void 0 !== t ? n.copy(t) : Ao.setFromPoints(e).getCenter(n);
                    let r = 0;
                    for (let t = 0, i = e.length; t < i; t++)
                        r = Math.max(r, n.distanceToSquared(e[t]));
                    return this.radius = Math.sqrt(r),
                    this
                }
                copy(e) {
                    return this.center.copy(e.center),
                    this.radius = e.radius,
                    this
                }
                isEmpty() {
                    return this.radius < 0
                }
                makeEmpty() {
                    return this.center.set(0, 0, 0),
                    this.radius = -1,
                    this
                }
                containsPoint(e) {
                    return e.distanceToSquared(this.center) <= this.radius * this.radius
                }
                distanceToPoint(e) {
                    return e.distanceTo(this.center) - this.radius
                }
                intersectsSphere(e) {
                    const t = this.radius + e.radius;
                    return e.center.distanceToSquared(this.center) <= t * t
                }
                intersectsBox(e) {
                    return e.intersectsSphere(this)
                }
                intersectsPlane(e) {
                    return Math.abs(e.distanceToPoint(this.center)) <= this.radius
                }
                clampPoint(e, t) {
                    const n = this.center.distanceToSquared(e);
                    return t.copy(e),
                    n > this.radius * this.radius && (t.sub(this.center).normalize(),
                    t.multiplyScalar(this.radius).add(this.center)),
                    t
                }
                getBoundingBox(e) {
                    return this.isEmpty() ? (e.makeEmpty(),
                    e) : (e.set(this.center, this.center),
                    e.expandByScalar(this.radius),
                    e)
                }
                applyMatrix4(e) {
                    return this.center.applyMatrix4(e),
                    this.radius = this.radius * e.getMaxScaleOnAxis(),
                    this
                }
                translate(e) {
                    return this.center.add(e),
                    this
                }
                expandByPoint(e) {
                    if (this.isEmpty())
                        return this.center.copy(e),
                        this.radius = 0,
                        this;
                    Co.subVectors(e, this.center);
                    const t = Co.lengthSq();
                    if (t > this.radius * this.radius) {
                        const e = Math.sqrt(t)
                          , n = .5 * (e - this.radius);
                        this.center.addScaledVector(Co, n / e),
                        this.radius += n
                    }
                    return this
                }
                union(e) {
                    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
                    this) : (!0 === this.center.equals(e.center) ? this.radius = Math.max(this.radius, e.radius) : (Po.subVectors(e.center, this.center).setLength(e.radius),
                    this.expandByPoint(Co.copy(e.center).add(Po)),
                    this.expandByPoint(Co.copy(e.center).sub(Po))),
                    this)
                }
                equals(e) {
                    return e.center.equals(this.center) && e.radius === this.radius
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            const Lo = new lo
              , Oo = new lo
              , Do = new lo
              , Io = new lo
              , No = new lo
              , Uo = new lo
              , ko = new lo;
            class Fo {
                constructor(e=new lo, t=new lo(0,0,-1)) {
                    this.origin = e,
                    this.direction = t
                }
                set(e, t) {
                    return this.origin.copy(e),
                    this.direction.copy(t),
                    this
                }
                copy(e) {
                    return this.origin.copy(e.origin),
                    this.direction.copy(e.direction),
                    this
                }
                at(e, t) {
                    return t.copy(this.origin).addScaledVector(this.direction, e)
                }
                lookAt(e) {
                    return this.direction.copy(e).sub(this.origin).normalize(),
                    this
                }
                recast(e) {
                    return this.origin.copy(this.at(e, Lo)),
                    this
                }
                closestPointToPoint(e, t) {
                    t.subVectors(e, this.origin);
                    const n = t.dot(this.direction);
                    return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n)
                }
                distanceToPoint(e) {
                    return Math.sqrt(this.distanceSqToPoint(e))
                }
                distanceSqToPoint(e) {
                    const t = Lo.subVectors(e, this.origin).dot(this.direction);
                    return t < 0 ? this.origin.distanceToSquared(e) : (Lo.copy(this.origin).addScaledVector(this.direction, t),
                    Lo.distanceToSquared(e))
                }
                distanceSqToSegment(e, t, n, r) {
                    Oo.copy(e).add(t).multiplyScalar(.5),
                    Do.copy(t).sub(e).normalize(),
                    Io.copy(this.origin).sub(Oo);
                    const i = .5 * e.distanceTo(t)
                      , a = -this.direction.dot(Do)
                      , s = Io.dot(this.direction)
                      , o = -Io.dot(Do)
                      , l = Io.lengthSq()
                      , c = Math.abs(1 - a * a);
                    let u, d, h, p;
                    if (c > 0)
                        if (u = a * o - s,
                        d = a * s - o,
                        p = i * c,
                        u >= 0)
                            if (d >= -p)
                                if (d <= p) {
                                    const e = 1 / c;
                                    u *= e,
                                    d *= e,
                                    h = u * (u + a * d + 2 * s) + d * (a * u + d + 2 * o) + l
                                } else
                                    d = i,
                                    u = Math.max(0, -(a * d + s)),
                                    h = -u * u + d * (d + 2 * o) + l;
                            else
                                d = -i,
                                u = Math.max(0, -(a * d + s)),
                                h = -u * u + d * (d + 2 * o) + l;
                        else
                            d <= -p ? (u = Math.max(0, -(-a * i + s)),
                            d = u > 0 ? -i : Math.min(Math.max(-i, -o), i),
                            h = -u * u + d * (d + 2 * o) + l) : d <= p ? (u = 0,
                            d = Math.min(Math.max(-i, -o), i),
                            h = d * (d + 2 * o) + l) : (u = Math.max(0, -(a * i + s)),
                            d = u > 0 ? i : Math.min(Math.max(-i, -o), i),
                            h = -u * u + d * (d + 2 * o) + l);
                    else
                        d = a > 0 ? -i : i,
                        u = Math.max(0, -(a * d + s)),
                        h = -u * u + d * (d + 2 * o) + l;
                    return n && n.copy(this.origin).addScaledVector(this.direction, u),
                    r && r.copy(Oo).addScaledVector(Do, d),
                    h
                }
                intersectSphere(e, t) {
                    Lo.subVectors(e.center, this.origin);
                    const n = Lo.dot(this.direction)
                      , r = Lo.dot(Lo) - n * n
                      , i = e.radius * e.radius;
                    if (r > i)
                        return null;
                    const a = Math.sqrt(i - r)
                      , s = n - a
                      , o = n + a;
                    return o < 0 ? null : s < 0 ? this.at(o, t) : this.at(s, t)
                }
                intersectsSphere(e) {
                    return this.distanceSqToPoint(e.center) <= e.radius * e.radius
                }
                distanceToPlane(e) {
                    const t = e.normal.dot(this.direction);
                    if (0 === t)
                        return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                    const n = -(this.origin.dot(e.normal) + e.constant) / t;
                    return n >= 0 ? n : null
                }
                intersectPlane(e, t) {
                    const n = this.distanceToPlane(e);
                    return null === n ? null : this.at(n, t)
                }
                intersectsPlane(e) {
                    const t = e.distanceToPoint(this.origin);
                    if (0 === t)
                        return !0;
                    return e.normal.dot(this.direction) * t < 0
                }
                intersectBox(e, t) {
                    let n, r, i, a, s, o;
                    const l = 1 / this.direction.x
                      , c = 1 / this.direction.y
                      , u = 1 / this.direction.z
                      , d = this.origin;
                    return l >= 0 ? (n = (e.min.x - d.x) * l,
                    r = (e.max.x - d.x) * l) : (n = (e.max.x - d.x) * l,
                    r = (e.min.x - d.x) * l),
                    c >= 0 ? (i = (e.min.y - d.y) * c,
                    a = (e.max.y - d.y) * c) : (i = (e.max.y - d.y) * c,
                    a = (e.min.y - d.y) * c),
                    n > a || i > r ? null : ((i > n || isNaN(n)) && (n = i),
                    (a < r || isNaN(r)) && (r = a),
                    u >= 0 ? (s = (e.min.z - d.z) * u,
                    o = (e.max.z - d.z) * u) : (s = (e.max.z - d.z) * u,
                    o = (e.min.z - d.z) * u),
                    n > o || s > r ? null : ((s > n || n != n) && (n = s),
                    (o < r || r != r) && (r = o),
                    r < 0 ? null : this.at(n >= 0 ? n : r, t)))
                }
                intersectsBox(e) {
                    return null !== this.intersectBox(e, Lo)
                }
                intersectTriangle(e, t, n, r, i) {
                    No.subVectors(t, e),
                    Uo.subVectors(n, e),
                    ko.crossVectors(No, Uo);
                    let a, s = this.direction.dot(ko);
                    if (s > 0) {
                        if (r)
                            return null;
                        a = 1
                    } else {
                        if (!(s < 0))
                            return null;
                        a = -1,
                        s = -s
                    }
                    Io.subVectors(this.origin, e);
                    const o = a * this.direction.dot(Uo.crossVectors(Io, Uo));
                    if (o < 0)
                        return null;
                    const l = a * this.direction.dot(No.cross(Io));
                    if (l < 0)
                        return null;
                    if (o + l > s)
                        return null;
                    const c = -a * Io.dot(ko);
                    return c < 0 ? null : this.at(c / s, i)
                }
                applyMatrix4(e) {
                    return this.origin.applyMatrix4(e),
                    this.direction.transformDirection(e),
                    this
                }
                equals(e) {
                    return e.origin.equals(this.origin) && e.direction.equals(this.direction)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            class zo {
                constructor(e, t, n, r, i, a, s, o, l, c, u, d, h, p, f, m) {
                    zo.prototype.isMatrix4 = !0,
                    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                    void 0 !== e && this.set(e, t, n, r, i, a, s, o, l, c, u, d, h, p, f, m)
                }
                set(e, t, n, r, i, a, s, o, l, c, u, d, h, p, f, m) {
                    const g = this.elements;
                    return g[0] = e,
                    g[4] = t,
                    g[8] = n,
                    g[12] = r,
                    g[1] = i,
                    g[5] = a,
                    g[9] = s,
                    g[13] = o,
                    g[2] = l,
                    g[6] = c,
                    g[10] = u,
                    g[14] = d,
                    g[3] = h,
                    g[7] = p,
                    g[11] = f,
                    g[15] = m,
                    this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                    this
                }
                clone() {
                    return (new zo).fromArray(this.elements)
                }
                copy(e) {
                    const t = this.elements
                      , n = e.elements;
                    return t[0] = n[0],
                    t[1] = n[1],
                    t[2] = n[2],
                    t[3] = n[3],
                    t[4] = n[4],
                    t[5] = n[5],
                    t[6] = n[6],
                    t[7] = n[7],
                    t[8] = n[8],
                    t[9] = n[9],
                    t[10] = n[10],
                    t[11] = n[11],
                    t[12] = n[12],
                    t[13] = n[13],
                    t[14] = n[14],
                    t[15] = n[15],
                    this
                }
                copyPosition(e) {
                    const t = this.elements
                      , n = e.elements;
                    return t[12] = n[12],
                    t[13] = n[13],
                    t[14] = n[14],
                    this
                }
                setFromMatrix3(e) {
                    const t = e.elements;
                    return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
                    this
                }
                extractBasis(e, t, n) {
                    return e.setFromMatrixColumn(this, 0),
                    t.setFromMatrixColumn(this, 1),
                    n.setFromMatrixColumn(this, 2),
                    this
                }
                makeBasis(e, t, n) {
                    return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1),
                    this
                }
                extractRotation(e) {
                    const t = this.elements
                      , n = e.elements
                      , r = 1 / Bo.setFromMatrixColumn(e, 0).length()
                      , i = 1 / Bo.setFromMatrixColumn(e, 1).length()
                      , a = 1 / Bo.setFromMatrixColumn(e, 2).length();
                    return t[0] = n[0] * r,
                    t[1] = n[1] * r,
                    t[2] = n[2] * r,
                    t[3] = 0,
                    t[4] = n[4] * i,
                    t[5] = n[5] * i,
                    t[6] = n[6] * i,
                    t[7] = 0,
                    t[8] = n[8] * a,
                    t[9] = n[9] * a,
                    t[10] = n[10] * a,
                    t[11] = 0,
                    t[12] = 0,
                    t[13] = 0,
                    t[14] = 0,
                    t[15] = 1,
                    this
                }
                makeRotationFromEuler(e) {
                    const t = this.elements
                      , n = e.x
                      , r = e.y
                      , i = e.z
                      , a = Math.cos(n)
                      , s = Math.sin(n)
                      , o = Math.cos(r)
                      , l = Math.sin(r)
                      , c = Math.cos(i)
                      , u = Math.sin(i);
                    if ("XYZ" === e.order) {
                        const e = a * c
                          , n = a * u
                          , r = s * c
                          , i = s * u;
                        t[0] = o * c,
                        t[4] = -o * u,
                        t[8] = l,
                        t[1] = n + r * l,
                        t[5] = e - i * l,
                        t[9] = -s * o,
                        t[2] = i - e * l,
                        t[6] = r + n * l,
                        t[10] = a * o
                    } else if ("YXZ" === e.order) {
                        const e = o * c
                          , n = o * u
                          , r = l * c
                          , i = l * u;
                        t[0] = e + i * s,
                        t[4] = r * s - n,
                        t[8] = a * l,
                        t[1] = a * u,
                        t[5] = a * c,
                        t[9] = -s,
                        t[2] = n * s - r,
                        t[6] = i + e * s,
                        t[10] = a * o
                    } else if ("ZXY" === e.order) {
                        const e = o * c
                          , n = o * u
                          , r = l * c
                          , i = l * u;
                        t[0] = e - i * s,
                        t[4] = -a * u,
                        t[8] = r + n * s,
                        t[1] = n + r * s,
                        t[5] = a * c,
                        t[9] = i - e * s,
                        t[2] = -a * l,
                        t[6] = s,
                        t[10] = a * o
                    } else if ("ZYX" === e.order) {
                        const e = a * c
                          , n = a * u
                          , r = s * c
                          , i = s * u;
                        t[0] = o * c,
                        t[4] = r * l - n,
                        t[8] = e * l + i,
                        t[1] = o * u,
                        t[5] = i * l + e,
                        t[9] = n * l - r,
                        t[2] = -l,
                        t[6] = s * o,
                        t[10] = a * o
                    } else if ("YZX" === e.order) {
                        const e = a * o
                          , n = a * l
                          , r = s * o
                          , i = s * l;
                        t[0] = o * c,
                        t[4] = i - e * u,
                        t[8] = r * u + n,
                        t[1] = u,
                        t[5] = a * c,
                        t[9] = -s * c,
                        t[2] = -l * c,
                        t[6] = n * u + r,
                        t[10] = e - i * u
                    } else if ("XZY" === e.order) {
                        const e = a * o
                          , n = a * l
                          , r = s * o
                          , i = s * l;
                        t[0] = o * c,
                        t[4] = -u,
                        t[8] = l * c,
                        t[1] = e * u + i,
                        t[5] = a * c,
                        t[9] = n * u - r,
                        t[2] = r * u - n,
                        t[6] = s * c,
                        t[10] = i * u + e
                    }
                    return t[3] = 0,
                    t[7] = 0,
                    t[11] = 0,
                    t[12] = 0,
                    t[13] = 0,
                    t[14] = 0,
                    t[15] = 1,
                    this
                }
                makeRotationFromQuaternion(e) {
                    return this.compose(Go, e, Vo)
                }
                lookAt(e, t, n) {
                    const r = this.elements;
                    return Xo.subVectors(e, t),
                    0 === Xo.lengthSq() && (Xo.z = 1),
                    Xo.normalize(),
                    Wo.crossVectors(n, Xo),
                    0 === Wo.lengthSq() && (1 === Math.abs(n.z) ? Xo.x += 1e-4 : Xo.z += 1e-4,
                    Xo.normalize(),
                    Wo.crossVectors(n, Xo)),
                    Wo.normalize(),
                    jo.crossVectors(Xo, Wo),
                    r[0] = Wo.x,
                    r[4] = jo.x,
                    r[8] = Xo.x,
                    r[1] = Wo.y,
                    r[5] = jo.y,
                    r[9] = Xo.y,
                    r[2] = Wo.z,
                    r[6] = jo.z,
                    r[10] = Xo.z,
                    this
                }
                multiply(e) {
                    return this.multiplyMatrices(this, e)
                }
                premultiply(e) {
                    return this.multiplyMatrices(e, this)
                }
                multiplyMatrices(e, t) {
                    const n = e.elements
                      , r = t.elements
                      , i = this.elements
                      , a = n[0]
                      , s = n[4]
                      , o = n[8]
                      , l = n[12]
                      , c = n[1]
                      , u = n[5]
                      , d = n[9]
                      , h = n[13]
                      , p = n[2]
                      , f = n[6]
                      , m = n[10]
                      , g = n[14]
                      , v = n[3]
                      , _ = n[7]
                      , y = n[11]
                      , x = n[15]
                      , b = r[0]
                      , E = r[4]
                      , S = r[8]
                      , w = r[12]
                      , M = r[1]
                      , T = r[5]
                      , A = r[9]
                      , C = r[13]
                      , P = r[2]
                      , R = r[6]
                      , L = r[10]
                      , O = r[14]
                      , D = r[3]
                      , I = r[7]
                      , N = r[11]
                      , U = r[15];
                    return i[0] = a * b + s * M + o * P + l * D,
                    i[4] = a * E + s * T + o * R + l * I,
                    i[8] = a * S + s * A + o * L + l * N,
                    i[12] = a * w + s * C + o * O + l * U,
                    i[1] = c * b + u * M + d * P + h * D,
                    i[5] = c * E + u * T + d * R + h * I,
                    i[9] = c * S + u * A + d * L + h * N,
                    i[13] = c * w + u * C + d * O + h * U,
                    i[2] = p * b + f * M + m * P + g * D,
                    i[6] = p * E + f * T + m * R + g * I,
                    i[10] = p * S + f * A + m * L + g * N,
                    i[14] = p * w + f * C + m * O + g * U,
                    i[3] = v * b + _ * M + y * P + x * D,
                    i[7] = v * E + _ * T + y * R + x * I,
                    i[11] = v * S + _ * A + y * L + x * N,
                    i[15] = v * w + _ * C + y * O + x * U,
                    this
                }
                multiplyScalar(e) {
                    const t = this.elements;
                    return t[0] *= e,
                    t[4] *= e,
                    t[8] *= e,
                    t[12] *= e,
                    t[1] *= e,
                    t[5] *= e,
                    t[9] *= e,
                    t[13] *= e,
                    t[2] *= e,
                    t[6] *= e,
                    t[10] *= e,
                    t[14] *= e,
                    t[3] *= e,
                    t[7] *= e,
                    t[11] *= e,
                    t[15] *= e,
                    this
                }
                determinant() {
                    const e = this.elements
                      , t = e[0]
                      , n = e[4]
                      , r = e[8]
                      , i = e[12]
                      , a = e[1]
                      , s = e[5]
                      , o = e[9]
                      , l = e[13]
                      , c = e[2]
                      , u = e[6]
                      , d = e[10]
                      , h = e[14];
                    return e[3] * (+i * o * u - r * l * u - i * s * d + n * l * d + r * s * h - n * o * h) + e[7] * (+t * o * h - t * l * d + i * a * d - r * a * h + r * l * c - i * o * c) + e[11] * (+t * l * u - t * s * h - i * a * u + n * a * h + i * s * c - n * l * c) + e[15] * (-r * s * c - t * o * u + t * s * d + r * a * u - n * a * d + n * o * c)
                }
                transpose() {
                    const e = this.elements;
                    let t;
                    return t = e[1],
                    e[1] = e[4],
                    e[4] = t,
                    t = e[2],
                    e[2] = e[8],
                    e[8] = t,
                    t = e[6],
                    e[6] = e[9],
                    e[9] = t,
                    t = e[3],
                    e[3] = e[12],
                    e[12] = t,
                    t = e[7],
                    e[7] = e[13],
                    e[13] = t,
                    t = e[11],
                    e[11] = e[14],
                    e[14] = t,
                    this
                }
                setPosition(e, t, n) {
                    const r = this.elements;
                    return e.isVector3 ? (r[12] = e.x,
                    r[13] = e.y,
                    r[14] = e.z) : (r[12] = e,
                    r[13] = t,
                    r[14] = n),
                    this
                }
                invert() {
                    const e = this.elements
                      , t = e[0]
                      , n = e[1]
                      , r = e[2]
                      , i = e[3]
                      , a = e[4]
                      , s = e[5]
                      , o = e[6]
                      , l = e[7]
                      , c = e[8]
                      , u = e[9]
                      , d = e[10]
                      , h = e[11]
                      , p = e[12]
                      , f = e[13]
                      , m = e[14]
                      , g = e[15]
                      , v = u * m * l - f * d * l + f * o * h - s * m * h - u * o * g + s * d * g
                      , _ = p * d * l - c * m * l - p * o * h + a * m * h + c * o * g - a * d * g
                      , y = c * f * l - p * u * l + p * s * h - a * f * h - c * s * g + a * u * g
                      , x = p * u * o - c * f * o - p * s * d + a * f * d + c * s * m - a * u * m
                      , b = t * v + n * _ + r * y + i * x;
                    if (0 === b)
                        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const E = 1 / b;
                    return e[0] = v * E,
                    e[1] = (f * d * i - u * m * i - f * r * h + n * m * h + u * r * g - n * d * g) * E,
                    e[2] = (s * m * i - f * o * i + f * r * l - n * m * l - s * r * g + n * o * g) * E,
                    e[3] = (u * o * i - s * d * i - u * r * l + n * d * l + s * r * h - n * o * h) * E,
                    e[4] = _ * E,
                    e[5] = (c * m * i - p * d * i + p * r * h - t * m * h - c * r * g + t * d * g) * E,
                    e[6] = (p * o * i - a * m * i - p * r * l + t * m * l + a * r * g - t * o * g) * E,
                    e[7] = (a * d * i - c * o * i + c * r * l - t * d * l - a * r * h + t * o * h) * E,
                    e[8] = y * E,
                    e[9] = (p * u * i - c * f * i - p * n * h + t * f * h + c * n * g - t * u * g) * E,
                    e[10] = (a * f * i - p * s * i + p * n * l - t * f * l - a * n * g + t * s * g) * E,
                    e[11] = (c * s * i - a * u * i - c * n * l + t * u * l + a * n * h - t * s * h) * E,
                    e[12] = x * E,
                    e[13] = (c * f * r - p * u * r + p * n * d - t * f * d - c * n * m + t * u * m) * E,
                    e[14] = (p * s * r - a * f * r - p * n * o + t * f * o + a * n * m - t * s * m) * E,
                    e[15] = (a * u * r - c * s * r + c * n * o - t * u * o - a * n * d + t * s * d) * E,
                    this
                }
                scale(e) {
                    const t = this.elements
                      , n = e.x
                      , r = e.y
                      , i = e.z;
                    return t[0] *= n,
                    t[4] *= r,
                    t[8] *= i,
                    t[1] *= n,
                    t[5] *= r,
                    t[9] *= i,
                    t[2] *= n,
                    t[6] *= r,
                    t[10] *= i,
                    t[3] *= n,
                    t[7] *= r,
                    t[11] *= i,
                    this
                }
                getMaxScaleOnAxis() {
                    const e = this.elements
                      , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
                      , n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
                      , r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                    return Math.sqrt(Math.max(t, n, r))
                }
                makeTranslation(e, t, n) {
                    return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
                    this
                }
                makeRotationX(e) {
                    const t = Math.cos(e)
                      , n = Math.sin(e);
                    return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1),
                    this
                }
                makeRotationY(e) {
                    const t = Math.cos(e)
                      , n = Math.sin(e);
                    return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1),
                    this
                }
                makeRotationZ(e) {
                    const t = Math.cos(e)
                      , n = Math.sin(e);
                    return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                    this
                }
                makeRotationAxis(e, t) {
                    const n = Math.cos(t)
                      , r = Math.sin(t)
                      , i = 1 - n
                      , a = e.x
                      , s = e.y
                      , o = e.z
                      , l = i * a
                      , c = i * s;
                    return this.set(l * a + n, l * s - r * o, l * o + r * s, 0, l * s + r * o, c * s + n, c * o - r * a, 0, l * o - r * s, c * o + r * a, i * o * o + n, 0, 0, 0, 0, 1),
                    this
                }
                makeScale(e, t, n) {
                    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
                    this
                }
                makeShear(e, t, n, r, i, a) {
                    return this.set(1, n, i, 0, e, 1, a, 0, t, r, 1, 0, 0, 0, 0, 1),
                    this
                }
                compose(e, t, n) {
                    const r = this.elements
                      , i = t._x
                      , a = t._y
                      , s = t._z
                      , o = t._w
                      , l = i + i
                      , c = a + a
                      , u = s + s
                      , d = i * l
                      , h = i * c
                      , p = i * u
                      , f = a * c
                      , m = a * u
                      , g = s * u
                      , v = o * l
                      , _ = o * c
                      , y = o * u
                      , x = n.x
                      , b = n.y
                      , E = n.z;
                    return r[0] = (1 - (f + g)) * x,
                    r[1] = (h + y) * x,
                    r[2] = (p - _) * x,
                    r[3] = 0,
                    r[4] = (h - y) * b,
                    r[5] = (1 - (d + g)) * b,
                    r[6] = (m + v) * b,
                    r[7] = 0,
                    r[8] = (p + _) * E,
                    r[9] = (m - v) * E,
                    r[10] = (1 - (d + f)) * E,
                    r[11] = 0,
                    r[12] = e.x,
                    r[13] = e.y,
                    r[14] = e.z,
                    r[15] = 1,
                    this
                }
                decompose(e, t, n) {
                    const r = this.elements;
                    let i = Bo.set(r[0], r[1], r[2]).length();
                    const a = Bo.set(r[4], r[5], r[6]).length()
                      , s = Bo.set(r[8], r[9], r[10]).length();
                    this.determinant() < 0 && (i = -i),
                    e.x = r[12],
                    e.y = r[13],
                    e.z = r[14],
                    Ho.copy(this);
                    const o = 1 / i
                      , l = 1 / a
                      , c = 1 / s;
                    return Ho.elements[0] *= o,
                    Ho.elements[1] *= o,
                    Ho.elements[2] *= o,
                    Ho.elements[4] *= l,
                    Ho.elements[5] *= l,
                    Ho.elements[6] *= l,
                    Ho.elements[8] *= c,
                    Ho.elements[9] *= c,
                    Ho.elements[10] *= c,
                    t.setFromRotationMatrix(Ho),
                    n.x = i,
                    n.y = a,
                    n.z = s,
                    this
                }
                makePerspective(e, t, n, r, i, a, s=2e3) {
                    const o = this.elements
                      , l = 2 * i / (t - e)
                      , c = 2 * i / (n - r)
                      , u = (t + e) / (t - e)
                      , d = (n + r) / (n - r);
                    let h, p;
                    if (s === xs)
                        h = -(a + i) / (a - i),
                        p = -2 * a * i / (a - i);
                    else {
                        if (s !== bs)
                            throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + s);
                        h = -a / (a - i),
                        p = -a * i / (a - i)
                    }
                    return o[0] = l,
                    o[4] = 0,
                    o[8] = u,
                    o[12] = 0,
                    o[1] = 0,
                    o[5] = c,
                    o[9] = d,
                    o[13] = 0,
                    o[2] = 0,
                    o[6] = 0,
                    o[10] = h,
                    o[14] = p,
                    o[3] = 0,
                    o[7] = 0,
                    o[11] = -1,
                    o[15] = 0,
                    this
                }
                makeOrthographic(e, t, n, r, i, a, s=2e3) {
                    const o = this.elements
                      , l = 1 / (t - e)
                      , c = 1 / (n - r)
                      , u = 1 / (a - i)
                      , d = (t + e) * l
                      , h = (n + r) * c;
                    let p, f;
                    if (s === xs)
                        p = (a + i) * u,
                        f = -2 * u;
                    else {
                        if (s !== bs)
                            throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + s);
                        p = i * u,
                        f = -1 * u
                    }
                    return o[0] = 2 * l,
                    o[4] = 0,
                    o[8] = 0,
                    o[12] = -d,
                    o[1] = 0,
                    o[5] = 2 * c,
                    o[9] = 0,
                    o[13] = -h,
                    o[2] = 0,
                    o[6] = 0,
                    o[10] = f,
                    o[14] = -p,
                    o[3] = 0,
                    o[7] = 0,
                    o[11] = 0,
                    o[15] = 1,
                    this
                }
                equals(e) {
                    const t = this.elements
                      , n = e.elements;
                    for (let e = 0; e < 16; e++)
                        if (t[e] !== n[e])
                            return !1;
                    return !0
                }
                fromArray(e, t=0) {
                    for (let n = 0; n < 16; n++)
                        this.elements[n] = e[n + t];
                    return this
                }
                toArray(e=[], t=0) {
                    const n = this.elements;
                    return e[t] = n[0],
                    e[t + 1] = n[1],
                    e[t + 2] = n[2],
                    e[t + 3] = n[3],
                    e[t + 4] = n[4],
                    e[t + 5] = n[5],
                    e[t + 6] = n[6],
                    e[t + 7] = n[7],
                    e[t + 8] = n[8],
                    e[t + 9] = n[9],
                    e[t + 10] = n[10],
                    e[t + 11] = n[11],
                    e[t + 12] = n[12],
                    e[t + 13] = n[13],
                    e[t + 14] = n[14],
                    e[t + 15] = n[15],
                    e
                }
            }
            const Bo = new lo
              , Ho = new zo
              , Go = new lo(0,0,0)
              , Vo = new lo(1,1,1)
              , Wo = new lo
              , jo = new lo
              , Xo = new lo
              , qo = new zo
              , Yo = new oo;
            class $o {
                constructor(e=0, t=0, n=0, r=$o.DEFAULT_ORDER) {
                    this.isEuler = !0,
                    this._x = e,
                    this._y = t,
                    this._z = n,
                    this._order = r
                }
                get x() {
                    return this._x
                }
                set x(e) {
                    this._x = e,
                    this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(e) {
                    this._y = e,
                    this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(e) {
                    this._z = e,
                    this._onChangeCallback()
                }
                get order() {
                    return this._order
                }
                set order(e) {
                    this._order = e,
                    this._onChangeCallback()
                }
                set(e, t, n, r=this._order) {
                    return this._x = e,
                    this._y = t,
                    this._z = n,
                    this._order = r,
                    this._onChangeCallback(),
                    this
                }
                clone() {
                    return new this.constructor(this._x,this._y,this._z,this._order)
                }
                copy(e) {
                    return this._x = e._x,
                    this._y = e._y,
                    this._z = e._z,
                    this._order = e._order,
                    this._onChangeCallback(),
                    this
                }
                setFromRotationMatrix(e, t=this._order, n=!0) {
                    const r = e.elements
                      , i = r[0]
                      , a = r[4]
                      , s = r[8]
                      , o = r[1]
                      , l = r[5]
                      , c = r[9]
                      , u = r[2]
                      , d = r[6]
                      , h = r[10];
                    switch (t) {
                    case "XYZ":
                        this._y = Math.asin(As(s, -1, 1)),
                        Math.abs(s) < .9999999 ? (this._x = Math.atan2(-c, h),
                        this._z = Math.atan2(-a, i)) : (this._x = Math.atan2(d, l),
                        this._z = 0);
                        break;
                    case "YXZ":
                        this._x = Math.asin(-As(c, -1, 1)),
                        Math.abs(c) < .9999999 ? (this._y = Math.atan2(s, h),
                        this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-u, i),
                        this._z = 0);
                        break;
                    case "ZXY":
                        this._x = Math.asin(As(d, -1, 1)),
                        Math.abs(d) < .9999999 ? (this._y = Math.atan2(-u, h),
                        this._z = Math.atan2(-a, l)) : (this._y = 0,
                        this._z = Math.atan2(o, i));
                        break;
                    case "ZYX":
                        this._y = Math.asin(-As(u, -1, 1)),
                        Math.abs(u) < .9999999 ? (this._x = Math.atan2(d, h),
                        this._z = Math.atan2(o, i)) : (this._x = 0,
                        this._z = Math.atan2(-a, l));
                        break;
                    case "YZX":
                        this._z = Math.asin(As(o, -1, 1)),
                        Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l),
                        this._y = Math.atan2(-u, i)) : (this._x = 0,
                        this._y = Math.atan2(s, h));
                        break;
                    case "XZY":
                        this._z = Math.asin(-As(a, -1, 1)),
                        Math.abs(a) < .9999999 ? (this._x = Math.atan2(d, l),
                        this._y = Math.atan2(s, i)) : (this._x = Math.atan2(-c, h),
                        this._y = 0);
                        break;
                    default:
                        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
                    }
                    return this._order = t,
                    !0 === n && this._onChangeCallback(),
                    this
                }
                setFromQuaternion(e, t, n) {
                    return qo.makeRotationFromQuaternion(e),
                    this.setFromRotationMatrix(qo, t, n)
                }
                setFromVector3(e, t=this._order) {
                    return this.set(e.x, e.y, e.z, t)
                }
                reorder(e) {
                    return Yo.setFromEuler(this),
                    this.setFromQuaternion(Yo, e)
                }
                equals(e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
                }
                fromArray(e) {
                    return this._x = e[0],
                    this._y = e[1],
                    this._z = e[2],
                    void 0 !== e[3] && (this._order = e[3]),
                    this._onChangeCallback(),
                    this
                }
                toArray(e=[], t=0) {
                    return e[t] = this._x,
                    e[t + 1] = this._y,
                    e[t + 2] = this._z,
                    e[t + 3] = this._order,
                    e
                }
                _onChange(e) {
                    return this._onChangeCallback = e,
                    this
                }
                _onChangeCallback() {}
                *[Symbol.iterator]() {
                    yield this._x,
                    yield this._y,
                    yield this._z,
                    yield this._order
                }
            }
            $o.DEFAULT_ORDER = "XYZ";
            class Ko {
                constructor() {
                    this.mask = 1
                }
                set(e) {
                    this.mask = (1 << e | 0) >>> 0
                }
                enable(e) {
                    this.mask |= 1 << e | 0
                }
                enableAll() {
                    this.mask = -1
                }
                toggle(e) {
                    this.mask ^= 1 << e | 0
                }
                disable(e) {
                    this.mask &= ~(1 << e | 0)
                }
                disableAll() {
                    this.mask = 0
                }
                test(e) {
                    return 0 != (this.mask & e.mask)
                }
                isEnabled(e) {
                    return 0 != (this.mask & (1 << e | 0))
                }
            }
            let Zo = 0;
            const Jo = new lo
              , Qo = new oo
              , el = new zo
              , tl = new lo
              , nl = new lo
              , rl = new lo
              , il = new oo
              , al = new lo(1,0,0)
              , sl = new lo(0,1,0)
              , ol = new lo(0,0,1)
              , ll = {
                type: "added"
            }
              , cl = {
                type: "removed"
            }
              , ul = {
                type: "childadded",
                child: null
            }
              , dl = {
                type: "childremoved",
                child: null
            };
            class hl extends Es {
                constructor() {
                    super(),
                    this.isObject3D = !0,
                    Object.defineProperty(this, "id", {
                        value: Zo++
                    }),
                    this.uuid = Ts(),
                    this.name = "",
                    this.type = "Object3D",
                    this.parent = null,
                    this.children = [],
                    this.up = hl.DEFAULT_UP.clone();
                    const e = new lo
                      , t = new $o
                      , n = new oo
                      , r = new lo(1,1,1);
                    t._onChange((function() {
                        n.setFromEuler(t, !1)
                    }
                    )),
                    n._onChange((function() {
                        t.setFromQuaternion(n, void 0, !1)
                    }
                    )),
                    Object.defineProperties(this, {
                        position: {
                            configurable: !0,
                            enumerable: !0,
                            value: e
                        },
                        rotation: {
                            configurable: !0,
                            enumerable: !0,
                            value: t
                        },
                        quaternion: {
                            configurable: !0,
                            enumerable: !0,
                            value: n
                        },
                        scale: {
                            configurable: !0,
                            enumerable: !0,
                            value: r
                        },
                        modelViewMatrix: {
                            value: new zo
                        },
                        normalMatrix: {
                            value: new Ns
                        }
                    }),
                    this.matrix = new zo,
                    this.matrixWorld = new zo,
                    this.matrixAutoUpdate = hl.DEFAULT_MATRIX_AUTO_UPDATE,
                    this.matrixWorldAutoUpdate = hl.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
                    this.matrixWorldNeedsUpdate = !1,
                    this.layers = new Ko,
                    this.visible = !0,
                    this.castShadow = !1,
                    this.receiveShadow = !1,
                    this.frustumCulled = !0,
                    this.renderOrder = 0,
                    this.animations = [],
                    this.userData = {}
                }
                onBeforeShadow() {}
                onAfterShadow() {}
                onBeforeRender() {}
                onAfterRender() {}
                applyMatrix4(e) {
                    this.matrixAutoUpdate && this.updateMatrix(),
                    this.matrix.premultiply(e),
                    this.matrix.decompose(this.position, this.quaternion, this.scale)
                }
                applyQuaternion(e) {
                    return this.quaternion.premultiply(e),
                    this
                }
                setRotationFromAxisAngle(e, t) {
                    this.quaternion.setFromAxisAngle(e, t)
                }
                setRotationFromEuler(e) {
                    this.quaternion.setFromEuler(e, !0)
                }
                setRotationFromMatrix(e) {
                    this.quaternion.setFromRotationMatrix(e)
                }
                setRotationFromQuaternion(e) {
                    this.quaternion.copy(e)
                }
                rotateOnAxis(e, t) {
                    return Qo.setFromAxisAngle(e, t),
                    this.quaternion.multiply(Qo),
                    this
                }
                rotateOnWorldAxis(e, t) {
                    return Qo.setFromAxisAngle(e, t),
                    this.quaternion.premultiply(Qo),
                    this
                }
                rotateX(e) {
                    return this.rotateOnAxis(al, e)
                }
                rotateY(e) {
                    return this.rotateOnAxis(sl, e)
                }
                rotateZ(e) {
                    return this.rotateOnAxis(ol, e)
                }
                translateOnAxis(e, t) {
                    return Jo.copy(e).applyQuaternion(this.quaternion),
                    this.position.add(Jo.multiplyScalar(t)),
                    this
                }
                translateX(e) {
                    return this.translateOnAxis(al, e)
                }
                translateY(e) {
                    return this.translateOnAxis(sl, e)
                }
                translateZ(e) {
                    return this.translateOnAxis(ol, e)
                }
                localToWorld(e) {
                    return this.updateWorldMatrix(!0, !1),
                    e.applyMatrix4(this.matrixWorld)
                }
                worldToLocal(e) {
                    return this.updateWorldMatrix(!0, !1),
                    e.applyMatrix4(el.copy(this.matrixWorld).invert())
                }
                lookAt(e, t, n) {
                    e.isVector3 ? tl.copy(e) : tl.set(e, t, n);
                    const r = this.parent;
                    this.updateWorldMatrix(!0, !1),
                    nl.setFromMatrixPosition(this.matrixWorld),
                    this.isCamera || this.isLight ? el.lookAt(nl, tl, this.up) : el.lookAt(tl, nl, this.up),
                    this.quaternion.setFromRotationMatrix(el),
                    r && (el.extractRotation(r.matrixWorld),
                    Qo.setFromRotationMatrix(el),
                    this.quaternion.premultiply(Qo.invert()))
                }
                add(e) {
                    if (arguments.length > 1) {
                        for (let e = 0; e < arguments.length; e++)
                            this.add(arguments[e]);
                        return this
                    }
                    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
                    this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e),
                    e.parent = this,
                    this.children.push(e),
                    e.dispatchEvent(ll),
                    ul.child = e,
                    this.dispatchEvent(ul),
                    ul.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
                    this)
                }
                remove(e) {
                    if (arguments.length > 1) {
                        for (let e = 0; e < arguments.length; e++)
                            this.remove(arguments[e]);
                        return this
                    }
                    const t = this.children.indexOf(e);
                    return -1 !== t && (e.parent = null,
                    this.children.splice(t, 1),
                    e.dispatchEvent(cl),
                    dl.child = e,
                    this.dispatchEvent(dl),
                    dl.child = null),
                    this
                }
                removeFromParent() {
                    const e = this.parent;
                    return null !== e && e.remove(this),
                    this
                }
                clear() {
                    return this.remove(...this.children)
                }
                attach(e) {
                    return this.updateWorldMatrix(!0, !1),
                    el.copy(this.matrixWorld).invert(),
                    null !== e.parent && (e.parent.updateWorldMatrix(!0, !1),
                    el.multiply(e.parent.matrixWorld)),
                    e.applyMatrix4(el),
                    this.add(e),
                    e.updateWorldMatrix(!1, !0),
                    this
                }
                getObjectById(e) {
                    return this.getObjectByProperty("id", e)
                }
                getObjectByName(e) {
                    return this.getObjectByProperty("name", e)
                }
                getObjectByProperty(e, t) {
                    if (this[e] === t)
                        return this;
                    for (let n = 0, r = this.children.length; n < r; n++) {
                        const r = this.children[n].getObjectByProperty(e, t);
                        if (void 0 !== r)
                            return r
                    }
                }
                getObjectsByProperty(e, t, n=[]) {
                    this[e] === t && n.push(this);
                    const r = this.children;
                    for (let i = 0, a = r.length; i < a; i++)
                        r[i].getObjectsByProperty(e, t, n);
                    return n
                }
                getWorldPosition(e) {
                    return this.updateWorldMatrix(!0, !1),
                    e.setFromMatrixPosition(this.matrixWorld)
                }
                getWorldQuaternion(e) {
                    return this.updateWorldMatrix(!0, !1),
                    this.matrixWorld.decompose(nl, e, rl),
                    e
                }
                getWorldScale(e) {
                    return this.updateWorldMatrix(!0, !1),
                    this.matrixWorld.decompose(nl, il, e),
                    e
                }
                getWorldDirection(e) {
                    this.updateWorldMatrix(!0, !1);
                    const t = this.matrixWorld.elements;
                    return e.set(t[8], t[9], t[10]).normalize()
                }
                raycast() {}
                traverse(e) {
                    e(this);
                    const t = this.children;
                    for (let n = 0, r = t.length; n < r; n++)
                        t[n].traverse(e)
                }
                traverseVisible(e) {
                    if (!1 === this.visible)
                        return;
                    e(this);
                    const t = this.children;
                    for (let n = 0, r = t.length; n < r; n++)
                        t[n].traverseVisible(e)
                }
                traverseAncestors(e) {
                    const t = this.parent;
                    null !== t && (e(t),
                    t.traverseAncestors(e))
                }
                updateMatrix() {
                    this.matrix.compose(this.position, this.quaternion, this.scale),
                    this.matrixWorldNeedsUpdate = !0
                }
                updateMatrixWorld(e) {
                    this.matrixAutoUpdate && this.updateMatrix(),
                    (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                    this.matrixWorldNeedsUpdate = !1,
                    e = !0);
                    const t = this.children;
                    for (let n = 0, r = t.length; n < r; n++) {
                        const r = t[n];
                        !0 !== r.matrixWorldAutoUpdate && !0 !== e || r.updateMatrixWorld(e)
                    }
                }
                updateWorldMatrix(e, t) {
                    const n = this.parent;
                    if (!0 === e && null !== n && !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!0, !1),
                    this.matrixAutoUpdate && this.updateMatrix(),
                    null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                    !0 === t) {
                        const e = this.children;
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t];
                            !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!1, !0)
                        }
                    }
                }
                toJSON(e) {
                    const t = void 0 === e || "string" == typeof e
                      , n = {};
                    t && (e = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {},
                        skeletons: {},
                        animations: {},
                        nodes: {}
                    },
                    n.metadata = {
                        version: 4.6,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    const r = {};
                    function i(t, n) {
                        return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)),
                        n.uuid
                    }
                    if (r.uuid = this.uuid,
                    r.type = this.type,
                    "" !== this.name && (r.name = this.name),
                    !0 === this.castShadow && (r.castShadow = !0),
                    !0 === this.receiveShadow && (r.receiveShadow = !0),
                    !1 === this.visible && (r.visible = !1),
                    !1 === this.frustumCulled && (r.frustumCulled = !1),
                    0 !== this.renderOrder && (r.renderOrder = this.renderOrder),
                    Object.keys(this.userData).length > 0 && (r.userData = this.userData),
                    r.layers = this.layers.mask,
                    r.matrix = this.matrix.toArray(),
                    r.up = this.up.toArray(),
                    !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1),
                    this.isInstancedMesh && (r.type = "InstancedMesh",
                    r.count = this.count,
                    r.instanceMatrix = this.instanceMatrix.toJSON(),
                    null !== this.instanceColor && (r.instanceColor = this.instanceColor.toJSON())),
                    this.isBatchedMesh && (r.type = "BatchedMesh",
                    r.perObjectFrustumCulled = this.perObjectFrustumCulled,
                    r.sortObjects = this.sortObjects,
                    r.drawRanges = this._drawRanges,
                    r.reservedRanges = this._reservedRanges,
                    r.visibility = this._visibility,
                    r.active = this._active,
                    r.bounds = this._bounds.map((e => ({
                        boxInitialized: e.boxInitialized,
                        boxMin: e.box.min.toArray(),
                        boxMax: e.box.max.toArray(),
                        sphereInitialized: e.sphereInitialized,
                        sphereRadius: e.sphere.radius,
                        sphereCenter: e.sphere.center.toArray()
                    }))),
                    r.maxGeometryCount = this._maxGeometryCount,
                    r.maxVertexCount = this._maxVertexCount,
                    r.maxIndexCount = this._maxIndexCount,
                    r.geometryInitialized = this._geometryInitialized,
                    r.geometryCount = this._geometryCount,
                    r.matricesTexture = this._matricesTexture.toJSON(e),
                    null !== this.boundingSphere && (r.boundingSphere = {
                        center: r.boundingSphere.center.toArray(),
                        radius: r.boundingSphere.radius
                    }),
                    null !== this.boundingBox && (r.boundingBox = {
                        min: r.boundingBox.min.toArray(),
                        max: r.boundingBox.max.toArray()
                    })),
                    this.isScene)
                        this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)),
                        this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (r.environment = this.environment.toJSON(e).uuid);
                    else if (this.isMesh || this.isLine || this.isPoints) {
                        r.geometry = i(e.geometries, this.geometry);
                        const t = this.geometry.parameters;
                        if (void 0 !== t && void 0 !== t.shapes) {
                            const n = t.shapes;
                            if (Array.isArray(n))
                                for (let t = 0, r = n.length; t < r; t++) {
                                    const r = n[t];
                                    i(e.shapes, r)
                                }
                            else
                                i(e.shapes, n)
                        }
                    }
                    if (this.isSkinnedMesh && (r.bindMode = this.bindMode,
                    r.bindMatrix = this.bindMatrix.toArray(),
                    void 0 !== this.skeleton && (i(e.skeletons, this.skeleton),
                    r.skeleton = this.skeleton.uuid)),
                    void 0 !== this.material)
                        if (Array.isArray(this.material)) {
                            const t = [];
                            for (let n = 0, r = this.material.length; n < r; n++)
                                t.push(i(e.materials, this.material[n]));
                            r.material = t
                        } else
                            r.material = i(e.materials, this.material);
                    if (this.children.length > 0) {
                        r.children = [];
                        for (let t = 0; t < this.children.length; t++)
                            r.children.push(this.children[t].toJSON(e).object)
                    }
                    if (this.animations.length > 0) {
                        r.animations = [];
                        for (let t = 0; t < this.animations.length; t++) {
                            const n = this.animations[t];
                            r.animations.push(i(e.animations, n))
                        }
                    }
                    if (t) {
                        const t = a(e.geometries)
                          , r = a(e.materials)
                          , i = a(e.textures)
                          , s = a(e.images)
                          , o = a(e.shapes)
                          , l = a(e.skeletons)
                          , c = a(e.animations)
                          , u = a(e.nodes);
                        t.length > 0 && (n.geometries = t),
                        r.length > 0 && (n.materials = r),
                        i.length > 0 && (n.textures = i),
                        s.length > 0 && (n.images = s),
                        o.length > 0 && (n.shapes = o),
                        l.length > 0 && (n.skeletons = l),
                        c.length > 0 && (n.animations = c),
                        u.length > 0 && (n.nodes = u)
                    }
                    return n.object = r,
                    n;
                    function a(e) {
                        const t = [];
                        for (const n in e) {
                            const r = e[n];
                            delete r.metadata,
                            t.push(r)
                        }
                        return t
                    }
                }
                clone(e) {
                    return (new this.constructor).copy(this, e)
                }
                copy(e, t=!0) {
                    if (this.name = e.name,
                    this.up.copy(e.up),
                    this.position.copy(e.position),
                    this.rotation.order = e.rotation.order,
                    this.quaternion.copy(e.quaternion),
                    this.scale.copy(e.scale),
                    this.matrix.copy(e.matrix),
                    this.matrixWorld.copy(e.matrixWorld),
                    this.matrixAutoUpdate = e.matrixAutoUpdate,
                    this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
                    this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
                    this.layers.mask = e.layers.mask,
                    this.visible = e.visible,
                    this.castShadow = e.castShadow,
                    this.receiveShadow = e.receiveShadow,
                    this.frustumCulled = e.frustumCulled,
                    this.renderOrder = e.renderOrder,
                    this.animations = e.animations.slice(),
                    this.userData = JSON.parse(JSON.stringify(e.userData)),
                    !0 === t)
                        for (let t = 0; t < e.children.length; t++) {
                            const n = e.children[t];
                            this.add(n.clone())
                        }
                    return this
                }
            }
            hl.DEFAULT_UP = new lo(0,1,0),
            hl.DEFAULT_MATRIX_AUTO_UPDATE = !0,
            hl.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
            const pl = new lo
              , fl = new lo
              , ml = new lo
              , gl = new lo
              , vl = new lo
              , _l = new lo
              , yl = new lo
              , xl = new lo
              , bl = new lo
              , El = new lo;
            class Sl {
                constructor(e=new lo, t=new lo, n=new lo) {
                    this.a = e,
                    this.b = t,
                    this.c = n
                }
                static getNormal(e, t, n, r) {
                    r.subVectors(n, t),
                    pl.subVectors(e, t),
                    r.cross(pl);
                    const i = r.lengthSq();
                    return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0)
                }
                static getBarycoord(e, t, n, r, i) {
                    pl.subVectors(r, t),
                    fl.subVectors(n, t),
                    ml.subVectors(e, t);
                    const a = pl.dot(pl)
                      , s = pl.dot(fl)
                      , o = pl.dot(ml)
                      , l = fl.dot(fl)
                      , c = fl.dot(ml)
                      , u = a * l - s * s;
                    if (0 === u)
                        return i.set(0, 0, 0),
                        null;
                    const d = 1 / u
                      , h = (l * o - s * c) * d
                      , p = (a * c - s * o) * d;
                    return i.set(1 - h - p, p, h)
                }
                static containsPoint(e, t, n, r) {
                    return null !== this.getBarycoord(e, t, n, r, gl) && (gl.x >= 0 && gl.y >= 0 && gl.x + gl.y <= 1)
                }
                static getInterpolation(e, t, n, r, i, a, s, o) {
                    return null === this.getBarycoord(e, t, n, r, gl) ? (o.x = 0,
                    o.y = 0,
                    "z"in o && (o.z = 0),
                    "w"in o && (o.w = 0),
                    null) : (o.setScalar(0),
                    o.addScaledVector(i, gl.x),
                    o.addScaledVector(a, gl.y),
                    o.addScaledVector(s, gl.z),
                    o)
                }
                static isFrontFacing(e, t, n, r) {
                    return pl.subVectors(n, t),
                    fl.subVectors(e, t),
                    pl.cross(fl).dot(r) < 0
                }
                set(e, t, n) {
                    return this.a.copy(e),
                    this.b.copy(t),
                    this.c.copy(n),
                    this
                }
                setFromPointsAndIndices(e, t, n, r) {
                    return this.a.copy(e[t]),
                    this.b.copy(e[n]),
                    this.c.copy(e[r]),
                    this
                }
                setFromAttributeAndIndices(e, t, n, r) {
                    return this.a.fromBufferAttribute(e, t),
                    this.b.fromBufferAttribute(e, n),
                    this.c.fromBufferAttribute(e, r),
                    this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.a.copy(e.a),
                    this.b.copy(e.b),
                    this.c.copy(e.c),
                    this
                }
                getArea() {
                    return pl.subVectors(this.c, this.b),
                    fl.subVectors(this.a, this.b),
                    .5 * pl.cross(fl).length()
                }
                getMidpoint(e) {
                    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                }
                getNormal(e) {
                    return Sl.getNormal(this.a, this.b, this.c, e)
                }
                getPlane(e) {
                    return e.setFromCoplanarPoints(this.a, this.b, this.c)
                }
                getBarycoord(e, t) {
                    return Sl.getBarycoord(e, this.a, this.b, this.c, t)
                }
                getInterpolation(e, t, n, r, i) {
                    return Sl.getInterpolation(e, this.a, this.b, this.c, t, n, r, i)
                }
                containsPoint(e) {
                    return Sl.containsPoint(e, this.a, this.b, this.c)
                }
                isFrontFacing(e) {
                    return Sl.isFrontFacing(this.a, this.b, this.c, e)
                }
                intersectsBox(e) {
                    return e.intersectsTriangle(this)
                }
                closestPointToPoint(e, t) {
                    const n = this.a
                      , r = this.b
                      , i = this.c;
                    let a, s;
                    vl.subVectors(r, n),
                    _l.subVectors(i, n),
                    xl.subVectors(e, n);
                    const o = vl.dot(xl)
                      , l = _l.dot(xl);
                    if (o <= 0 && l <= 0)
                        return t.copy(n);
                    bl.subVectors(e, r);
                    const c = vl.dot(bl)
                      , u = _l.dot(bl);
                    if (c >= 0 && u <= c)
                        return t.copy(r);
                    const d = o * u - c * l;
                    if (d <= 0 && o >= 0 && c <= 0)
                        return a = o / (o - c),
                        t.copy(n).addScaledVector(vl, a);
                    El.subVectors(e, i);
                    const h = vl.dot(El)
                      , p = _l.dot(El);
                    if (p >= 0 && h <= p)
                        return t.copy(i);
                    const f = h * l - o * p;
                    if (f <= 0 && l >= 0 && p <= 0)
                        return s = l / (l - p),
                        t.copy(n).addScaledVector(_l, s);
                    const m = c * p - h * u;
                    if (m <= 0 && u - c >= 0 && h - p >= 0)
                        return yl.subVectors(i, r),
                        s = (u - c) / (u - c + (h - p)),
                        t.copy(r).addScaledVector(yl, s);
                    const g = 1 / (m + f + d);
                    return a = f * g,
                    s = d * g,
                    t.copy(n).addScaledVector(vl, a).addScaledVector(_l, s)
                }
                equals(e) {
                    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
                }
            }
            const wl = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                rebeccapurple: 6697881,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074
            }
              , Ml = {
                h: 0,
                s: 0,
                l: 0
            }
              , Tl = {
                h: 0,
                s: 0,
                l: 0
            };
            function Al(e, t, n) {
                return n < 0 && (n += 1),
                n > 1 && (n -= 1),
                n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
            }
            class Cl {
                constructor(e, t, n) {
                    return this.isColor = !0,
                    this.r = 1,
                    this.g = 1,
                    this.b = 1,
                    this.set(e, t, n)
                }
                set(e, t, n) {
                    if (void 0 === t && void 0 === n) {
                        const t = e;
                        t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t)
                    } else
                        this.setRGB(e, t, n);
                    return this
                }
                setScalar(e) {
                    return this.r = e,
                    this.g = e,
                    this.b = e,
                    this
                }
                setHex(e, t=ls) {
                    return e = Math.floor(e),
                    this.r = (e >> 16 & 255) / 255,
                    this.g = (e >> 8 & 255) / 255,
                    this.b = (255 & e) / 255,
                    Xs.toWorkingColorSpace(this, t),
                    this
                }
                setRGB(e, t, n, r=Xs.workingColorSpace) {
                    return this.r = e,
                    this.g = t,
                    this.b = n,
                    Xs.toWorkingColorSpace(this, r),
                    this
                }
                setHSL(e, t, n, r=Xs.workingColorSpace) {
                    if (e = Cs(e, 1),
                    t = As(t, 0, 1),
                    n = As(n, 0, 1),
                    0 === t)
                        this.r = this.g = this.b = n;
                    else {
                        const r = n <= .5 ? n * (1 + t) : n + t - n * t
                          , i = 2 * n - r;
                        this.r = Al(i, r, e + 1 / 3),
                        this.g = Al(i, r, e),
                        this.b = Al(i, r, e - 1 / 3)
                    }
                    return Xs.toWorkingColorSpace(this, r),
                    this
                }
                setStyle(e, t=ls) {
                    function n(t) {
                        void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
                    }
                    let r;
                    if (r = /^(\w+)\(([^\)]*)\)/.exec(e)) {
                        let i;
                        const a = r[1]
                          , s = r[2];
                        switch (a) {
                        case "rgb":
                        case "rgba":
                            if (i = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
                                return n(i[4]),
                                this.setRGB(Math.min(255, parseInt(i[1], 10)) / 255, Math.min(255, parseInt(i[2], 10)) / 255, Math.min(255, parseInt(i[3], 10)) / 255, t);
                            if (i = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
                                return n(i[4]),
                                this.setRGB(Math.min(100, parseInt(i[1], 10)) / 100, Math.min(100, parseInt(i[2], 10)) / 100, Math.min(100, parseInt(i[3], 10)) / 100, t);
                            break;
                        case "hsl":
                        case "hsla":
                            if (i = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
                                return n(i[4]),
                                this.setHSL(parseFloat(i[1]) / 360, parseFloat(i[2]) / 100, parseFloat(i[3]) / 100, t);
                            break;
                        default:
                            console.warn("THREE.Color: Unknown color model " + e)
                        }
                    } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                        const n = r[1]
                          , i = n.length;
                        if (3 === i)
                            return this.setRGB(parseInt(n.charAt(0), 16) / 15, parseInt(n.charAt(1), 16) / 15, parseInt(n.charAt(2), 16) / 15, t);
                        if (6 === i)
                            return this.setHex(parseInt(n, 16), t);
                        console.warn("THREE.Color: Invalid hex color " + e)
                    } else if (e && e.length > 0)
                        return this.setColorName(e, t);
                    return this
                }
                setColorName(e, t=ls) {
                    const n = wl[e.toLowerCase()];
                    return void 0 !== n ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e),
                    this
                }
                clone() {
                    return new this.constructor(this.r,this.g,this.b)
                }
                copy(e) {
                    return this.r = e.r,
                    this.g = e.g,
                    this.b = e.b,
                    this
                }
                copySRGBToLinear(e) {
                    return this.r = qs(e.r),
                    this.g = qs(e.g),
                    this.b = qs(e.b),
                    this
                }
                copyLinearToSRGB(e) {
                    return this.r = Ys(e.r),
                    this.g = Ys(e.g),
                    this.b = Ys(e.b),
                    this
                }
                convertSRGBToLinear() {
                    return this.copySRGBToLinear(this),
                    this
                }
                convertLinearToSRGB() {
                    return this.copyLinearToSRGB(this),
                    this
                }
                getHex(e=ls) {
                    return Xs.fromWorkingColorSpace(Pl.copy(this), e),
                    65536 * Math.round(As(255 * Pl.r, 0, 255)) + 256 * Math.round(As(255 * Pl.g, 0, 255)) + Math.round(As(255 * Pl.b, 0, 255))
                }
                getHexString(e=ls) {
                    return ("000000" + this.getHex(e).toString(16)).slice(-6)
                }
                getHSL(e, t=Xs.workingColorSpace) {
                    Xs.fromWorkingColorSpace(Pl.copy(this), t);
                    const n = Pl.r
                      , r = Pl.g
                      , i = Pl.b
                      , a = Math.max(n, r, i)
                      , s = Math.min(n, r, i);
                    let o, l;
                    const c = (s + a) / 2;
                    if (s === a)
                        o = 0,
                        l = 0;
                    else {
                        const e = a - s;
                        switch (l = c <= .5 ? e / (a + s) : e / (2 - a - s),
                        a) {
                        case n:
                            o = (r - i) / e + (r < i ? 6 : 0);
                            break;
                        case r:
                            o = (i - n) / e + 2;
                            break;
                        case i:
                            o = (n - r) / e + 4
                        }
                        o /= 6
                    }
                    return e.h = o,
                    e.s = l,
                    e.l = c,
                    e
                }
                getRGB(e, t=Xs.workingColorSpace) {
                    return Xs.fromWorkingColorSpace(Pl.copy(this), t),
                    e.r = Pl.r,
                    e.g = Pl.g,
                    e.b = Pl.b,
                    e
                }
                getStyle(e=ls) {
                    Xs.fromWorkingColorSpace(Pl.copy(this), e);
                    const t = Pl.r
                      , n = Pl.g
                      , r = Pl.b;
                    return e !== ls ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(255 * t)},${Math.round(255 * n)},${Math.round(255 * r)})`
                }
                offsetHSL(e, t, n) {
                    return this.getHSL(Ml),
                    this.setHSL(Ml.h + e, Ml.s + t, Ml.l + n)
                }
                add(e) {
                    return this.r += e.r,
                    this.g += e.g,
                    this.b += e.b,
                    this
                }
                addColors(e, t) {
                    return this.r = e.r + t.r,
                    this.g = e.g + t.g,
                    this.b = e.b + t.b,
                    this
                }
                addScalar(e) {
                    return this.r += e,
                    this.g += e,
                    this.b += e,
                    this
                }
                sub(e) {
                    return this.r = Math.max(0, this.r - e.r),
                    this.g = Math.max(0, this.g - e.g),
                    this.b = Math.max(0, this.b - e.b),
                    this
                }
                multiply(e) {
                    return this.r *= e.r,
                    this.g *= e.g,
                    this.b *= e.b,
                    this
                }
                multiplyScalar(e) {
                    return this.r *= e,
                    this.g *= e,
                    this.b *= e,
                    this
                }
                lerp(e, t) {
                    return this.r += (e.r - this.r) * t,
                    this.g += (e.g - this.g) * t,
                    this.b += (e.b - this.b) * t,
                    this
                }
                lerpColors(e, t, n) {
                    return this.r = e.r + (t.r - e.r) * n,
                    this.g = e.g + (t.g - e.g) * n,
                    this.b = e.b + (t.b - e.b) * n,
                    this
                }
                lerpHSL(e, t) {
                    this.getHSL(Ml),
                    e.getHSL(Tl);
                    const n = Ps(Ml.h, Tl.h, t)
                      , r = Ps(Ml.s, Tl.s, t)
                      , i = Ps(Ml.l, Tl.l, t);
                    return this.setHSL(n, r, i),
                    this
                }
                setFromVector3(e) {
                    return this.r = e.x,
                    this.g = e.y,
                    this.b = e.z,
                    this
                }
                applyMatrix3(e) {
                    const t = this.r
                      , n = this.g
                      , r = this.b
                      , i = e.elements;
                    return this.r = i[0] * t + i[3] * n + i[6] * r,
                    this.g = i[1] * t + i[4] * n + i[7] * r,
                    this.b = i[2] * t + i[5] * n + i[8] * r,
                    this
                }
                equals(e) {
                    return e.r === this.r && e.g === this.g && e.b === this.b
                }
                fromArray(e, t=0) {
                    return this.r = e[t],
                    this.g = e[t + 1],
                    this.b = e[t + 2],
                    this
                }
                toArray(e=[], t=0) {
                    return e[t] = this.r,
                    e[t + 1] = this.g,
                    e[t + 2] = this.b,
                    e
                }
                fromBufferAttribute(e, t) {
                    return this.r = e.getX(t),
                    this.g = e.getY(t),
                    this.b = e.getZ(t),
                    this
                }
                toJSON() {
                    return this.getHex()
                }
                *[Symbol.iterator]() {
                    yield this.r,
                    yield this.g,
                    yield this.b
                }
            }
            const Pl = new Cl;
            Cl.NAMES = wl;
            let Rl = 0;
            class Ll extends Es {
                constructor() {
                    super(),
                    this.isMaterial = !0,
                    Object.defineProperty(this, "id", {
                        value: Rl++
                    }),
                    this.uuid = Ts(),
                    this.name = "",
                    this.type = "Material",
                    this.blending = 1,
                    this.side = ha,
                    this.vertexColors = !1,
                    this.opacity = 1,
                    this.transparent = !1,
                    this.alphaHash = !1,
                    this.blendSrc = 204,
                    this.blendDst = 205,
                    this.blendEquation = fa,
                    this.blendSrcAlpha = null,
                    this.blendDstAlpha = null,
                    this.blendEquationAlpha = null,
                    this.blendColor = new Cl(0,0,0),
                    this.blendAlpha = 0,
                    this.depthFunc = 3,
                    this.depthTest = !0,
                    this.depthWrite = !0,
                    this.stencilWriteMask = 255,
                    this.stencilFunc = 519,
                    this.stencilRef = 0,
                    this.stencilFuncMask = 255,
                    this.stencilFail = gs,
                    this.stencilZFail = gs,
                    this.stencilZPass = gs,
                    this.stencilWrite = !1,
                    this.clippingPlanes = null,
                    this.clipIntersection = !1,
                    this.clipShadows = !1,
                    this.shadowSide = null,
                    this.colorWrite = !0,
                    this.precision = null,
                    this.polygonOffset = !1,
                    this.polygonOffsetFactor = 0,
                    this.polygonOffsetUnits = 0,
                    this.dithering = !1,
                    this.alphaToCoverage = !1,
                    this.premultipliedAlpha = !1,
                    this.forceSinglePass = !1,
                    this.visible = !0,
                    this.toneMapped = !0,
                    this.userData = {},
                    this.version = 0,
                    this._alphaTest = 0
                }
                get alphaTest() {
                    return this._alphaTest
                }
                set alphaTest(e) {
                    this._alphaTest > 0 != e > 0 && this.version++,
                    this._alphaTest = e
                }
                onBuild() {}
                onBeforeRender() {}
                onBeforeCompile() {}
                customProgramCacheKey() {
                    return this.onBeforeCompile.toString()
                }
                setValues(e) {
                    if (void 0 !== e)
                        for (const t in e) {
                            const n = e[t];
                            if (void 0 === n) {
                                console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                                continue
                            }
                            const r = this[t];
                            void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = n : console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`)
                        }
                }
                toJSON(e) {
                    const t = void 0 === e || "string" == typeof e;
                    t && (e = {
                        textures: {},
                        images: {}
                    });
                    const n = {
                        metadata: {
                            version: 4.6,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };
                    function r(e) {
                        const t = [];
                        for (const n in e) {
                            const r = e[n];
                            delete r.metadata,
                            t.push(r)
                        }
                        return t
                    }
                    if (n.uuid = this.uuid,
                    n.type = this.type,
                    "" !== this.name && (n.name = this.name),
                    this.color && this.color.isColor && (n.color = this.color.getHex()),
                    void 0 !== this.roughness && (n.roughness = this.roughness),
                    void 0 !== this.metalness && (n.metalness = this.metalness),
                    void 0 !== this.sheen && (n.sheen = this.sheen),
                    this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()),
                    void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness),
                    this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
                    void 0 !== this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity),
                    this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
                    void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity),
                    this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()),
                    void 0 !== this.shininess && (n.shininess = this.shininess),
                    void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
                    void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness),
                    this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
                    this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
                    this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
                    n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
                    void 0 !== this.iridescence && (n.iridescence = this.iridescence),
                    void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR),
                    void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
                    this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
                    this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
                    void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy),
                    void 0 !== this.anisotropyRotation && (n.anisotropyRotation = this.anisotropyRotation),
                    this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
                    this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
                    this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid),
                    this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid),
                    this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid,
                    n.lightMapIntensity = this.lightMapIntensity),
                    this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid,
                    n.aoMapIntensity = this.aoMapIntensity),
                    this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid,
                    n.bumpScale = this.bumpScale),
                    this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid,
                    n.normalMapType = this.normalMapType,
                    n.normalScale = this.normalScale.toArray()),
                    this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid,
                    n.displacementScale = this.displacementScale,
                    n.displacementBias = this.displacementBias),
                    this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
                    this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
                    this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
                    this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid),
                    this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
                    this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
                    this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid,
                    void 0 !== this.combine && (n.combine = this.combine)),
                    void 0 !== this.envMapRotation && (n.envMapRotation = this.envMapRotation.toArray()),
                    void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity),
                    void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity),
                    void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio),
                    this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid),
                    void 0 !== this.transmission && (n.transmission = this.transmission),
                    this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
                    void 0 !== this.thickness && (n.thickness = this.thickness),
                    this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
                    void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance),
                    void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()),
                    void 0 !== this.size && (n.size = this.size),
                    null !== this.shadowSide && (n.shadowSide = this.shadowSide),
                    void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
                    1 !== this.blending && (n.blending = this.blending),
                    this.side !== ha && (n.side = this.side),
                    !0 === this.vertexColors && (n.vertexColors = !0),
                    this.opacity < 1 && (n.opacity = this.opacity),
                    !0 === this.transparent && (n.transparent = !0),
                    204 !== this.blendSrc && (n.blendSrc = this.blendSrc),
                    205 !== this.blendDst && (n.blendDst = this.blendDst),
                    this.blendEquation !== fa && (n.blendEquation = this.blendEquation),
                    null !== this.blendSrcAlpha && (n.blendSrcAlpha = this.blendSrcAlpha),
                    null !== this.blendDstAlpha && (n.blendDstAlpha = this.blendDstAlpha),
                    null !== this.blendEquationAlpha && (n.blendEquationAlpha = this.blendEquationAlpha),
                    this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()),
                    0 !== this.blendAlpha && (n.blendAlpha = this.blendAlpha),
                    3 !== this.depthFunc && (n.depthFunc = this.depthFunc),
                    !1 === this.depthTest && (n.depthTest = this.depthTest),
                    !1 === this.depthWrite && (n.depthWrite = this.depthWrite),
                    !1 === this.colorWrite && (n.colorWrite = this.colorWrite),
                    255 !== this.stencilWriteMask && (n.stencilWriteMask = this.stencilWriteMask),
                    519 !== this.stencilFunc && (n.stencilFunc = this.stencilFunc),
                    0 !== this.stencilRef && (n.stencilRef = this.stencilRef),
                    255 !== this.stencilFuncMask && (n.stencilFuncMask = this.stencilFuncMask),
                    this.stencilFail !== gs && (n.stencilFail = this.stencilFail),
                    this.stencilZFail !== gs && (n.stencilZFail = this.stencilZFail),
                    this.stencilZPass !== gs && (n.stencilZPass = this.stencilZPass),
                    !0 === this.stencilWrite && (n.stencilWrite = this.stencilWrite),
                    void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
                    !0 === this.polygonOffset && (n.polygonOffset = !0),
                    0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor),
                    0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits),
                    void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth),
                    void 0 !== this.dashSize && (n.dashSize = this.dashSize),
                    void 0 !== this.gapSize && (n.gapSize = this.gapSize),
                    void 0 !== this.scale && (n.scale = this.scale),
                    !0 === this.dithering && (n.dithering = !0),
                    this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
                    !0 === this.alphaHash && (n.alphaHash = !0),
                    !0 === this.alphaToCoverage && (n.alphaToCoverage = !0),
                    !0 === this.premultipliedAlpha && (n.premultipliedAlpha = !0),
                    !0 === this.forceSinglePass && (n.forceSinglePass = !0),
                    !0 === this.wireframe && (n.wireframe = !0),
                    this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
                    "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
                    "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
                    !0 === this.flatShading && (n.flatShading = !0),
                    !1 === this.visible && (n.visible = !1),
                    !1 === this.toneMapped && (n.toneMapped = !1),
                    !1 === this.fog && (n.fog = !1),
                    Object.keys(this.userData).length > 0 && (n.userData = this.userData),
                    t) {
                        const t = r(e.textures)
                          , i = r(e.images);
                        t.length > 0 && (n.textures = t),
                        i.length > 0 && (n.images = i)
                    }
                    return n
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    this.name = e.name,
                    this.blending = e.blending,
                    this.side = e.side,
                    this.vertexColors = e.vertexColors,
                    this.opacity = e.opacity,
                    this.transparent = e.transparent,
                    this.blendSrc = e.blendSrc,
                    this.blendDst = e.blendDst,
                    this.blendEquation = e.blendEquation,
                    this.blendSrcAlpha = e.blendSrcAlpha,
                    this.blendDstAlpha = e.blendDstAlpha,
                    this.blendEquationAlpha = e.blendEquationAlpha,
                    this.blendColor.copy(e.blendColor),
                    this.blendAlpha = e.blendAlpha,
                    this.depthFunc = e.depthFunc,
                    this.depthTest = e.depthTest,
                    this.depthWrite = e.depthWrite,
                    this.stencilWriteMask = e.stencilWriteMask,
                    this.stencilFunc = e.stencilFunc,
                    this.stencilRef = e.stencilRef,
                    this.stencilFuncMask = e.stencilFuncMask,
                    this.stencilFail = e.stencilFail,
                    this.stencilZFail = e.stencilZFail,
                    this.stencilZPass = e.stencilZPass,
                    this.stencilWrite = e.stencilWrite;
                    const t = e.clippingPlanes;
                    let n = null;
                    if (null !== t) {
                        const e = t.length;
                        n = new Array(e);
                        for (let r = 0; r !== e; ++r)
                            n[r] = t[r].clone()
                    }
                    return this.clippingPlanes = n,
                    this.clipIntersection = e.clipIntersection,
                    this.clipShadows = e.clipShadows,
                    this.shadowSide = e.shadowSide,
                    this.colorWrite = e.colorWrite,
                    this.precision = e.precision,
                    this.polygonOffset = e.polygonOffset,
                    this.polygonOffsetFactor = e.polygonOffsetFactor,
                    this.polygonOffsetUnits = e.polygonOffsetUnits,
                    this.dithering = e.dithering,
                    this.alphaTest = e.alphaTest,
                    this.alphaHash = e.alphaHash,
                    this.alphaToCoverage = e.alphaToCoverage,
                    this.premultipliedAlpha = e.premultipliedAlpha,
                    this.forceSinglePass = e.forceSinglePass,
                    this.visible = e.visible,
                    this.toneMapped = e.toneMapped,
                    this.userData = JSON.parse(JSON.stringify(e.userData)),
                    this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
            }
            class Ol extends Ll {
                constructor(e) {
                    super(),
                    this.isMeshBasicMaterial = !0,
                    this.type = "MeshBasicMaterial",
                    this.color = new Cl(16777215),
                    this.map = null,
                    this.lightMap = null,
                    this.lightMapIntensity = 1,
                    this.aoMap = null,
                    this.aoMapIntensity = 1,
                    this.specularMap = null,
                    this.alphaMap = null,
                    this.envMap = null,
                    this.envMapRotation = new $o,
                    this.combine = ma,
                    this.reflectivity = 1,
                    this.refractionRatio = .98,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.wireframeLinecap = "round",
                    this.wireframeLinejoin = "round",
                    this.fog = !0,
                    this.setValues(e)
                }
                copy(e) {
                    return super.copy(e),
                    this.color.copy(e.color),
                    this.map = e.map,
                    this.lightMap = e.lightMap,
                    this.lightMapIntensity = e.lightMapIntensity,
                    this.aoMap = e.aoMap,
                    this.aoMapIntensity = e.aoMapIntensity,
                    this.specularMap = e.specularMap,
                    this.alphaMap = e.alphaMap,
                    this.envMap = e.envMap,
                    this.envMapRotation.copy(e.envMapRotation),
                    this.combine = e.combine,
                    this.reflectivity = e.reflectivity,
                    this.refractionRatio = e.refractionRatio,
                    this.wireframe = e.wireframe,
                    this.wireframeLinewidth = e.wireframeLinewidth,
                    this.wireframeLinecap = e.wireframeLinecap,
                    this.wireframeLinejoin = e.wireframeLinejoin,
                    this.fog = e.fog,
                    this
                }
            }
            const Dl = new lo
              , Il = new Is;
            class Nl {
                constructor(e, t, n=!1) {
                    if (Array.isArray(e))
                        throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    this.isBufferAttribute = !0,
                    this.name = "",
                    this.array = e,
                    this.itemSize = t,
                    this.count = void 0 !== e ? e.length / t : 0,
                    this.normalized = n,
                    this.usage = vs,
                    this._updateRange = {
                        offset: 0,
                        count: -1
                    },
                    this.updateRanges = [],
                    this.gpuType = Wa,
                    this.version = 0
                }
                onUploadCallback() {}
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
                get updateRange() {
                    return Hs("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),
                    this._updateRange
                }
                setUsage(e) {
                    return this.usage = e,
                    this
                }
                addUpdateRange(e, t) {
                    this.updateRanges.push({
                        start: e,
                        count: t
                    })
                }
                clearUpdateRanges() {
                    this.updateRanges.length = 0
                }
                copy(e) {
                    return this.name = e.name,
                    this.array = new e.array.constructor(e.array),
                    this.itemSize = e.itemSize,
                    this.count = e.count,
                    this.normalized = e.normalized,
                    this.usage = e.usage,
                    this.gpuType = e.gpuType,
                    this
                }
                copyAt(e, t, n) {
                    e *= this.itemSize,
                    n *= t.itemSize;
                    for (let r = 0, i = this.itemSize; r < i; r++)
                        this.array[e + r] = t.array[n + r];
                    return this
                }
                copyArray(e) {
                    return this.array.set(e),
                    this
                }
                applyMatrix3(e) {
                    if (2 === this.itemSize)
                        for (let t = 0, n = this.count; t < n; t++)
                            Il.fromBufferAttribute(this, t),
                            Il.applyMatrix3(e),
                            this.setXY(t, Il.x, Il.y);
                    else if (3 === this.itemSize)
                        for (let t = 0, n = this.count; t < n; t++)
                            Dl.fromBufferAttribute(this, t),
                            Dl.applyMatrix3(e),
                            this.setXYZ(t, Dl.x, Dl.y, Dl.z);
                    return this
                }
                applyMatrix4(e) {
                    for (let t = 0, n = this.count; t < n; t++)
                        Dl.fromBufferAttribute(this, t),
                        Dl.applyMatrix4(e),
                        this.setXYZ(t, Dl.x, Dl.y, Dl.z);
                    return this
                }
                applyNormalMatrix(e) {
                    for (let t = 0, n = this.count; t < n; t++)
                        Dl.fromBufferAttribute(this, t),
                        Dl.applyNormalMatrix(e),
                        this.setXYZ(t, Dl.x, Dl.y, Dl.z);
                    return this
                }
                transformDirection(e) {
                    for (let t = 0, n = this.count; t < n; t++)
                        Dl.fromBufferAttribute(this, t),
                        Dl.transformDirection(e),
                        this.setXYZ(t, Dl.x, Dl.y, Dl.z);
                    return this
                }
                set(e, t=0) {
                    return this.array.set(e, t),
                    this
                }
                getComponent(e, t) {
                    let n = this.array[e * this.itemSize + t];
                    return this.normalized && (n = Os(n, this.array)),
                    n
                }
                setComponent(e, t, n) {
                    return this.normalized && (n = Ds(n, this.array)),
                    this.array[e * this.itemSize + t] = n,
                    this
                }
                getX(e) {
                    let t = this.array[e * this.itemSize];
                    return this.normalized && (t = Os(t, this.array)),
                    t
                }
                setX(e, t) {
                    return this.normalized && (t = Ds(t, this.array)),
                    this.array[e * this.itemSize] = t,
                    this
                }
                getY(e) {
                    let t = this.array[e * this.itemSize + 1];
                    return this.normalized && (t = Os(t, this.array)),
                    t
                }
                setY(e, t) {
                    return this.normalized && (t = Ds(t, this.array)),
                    this.array[e * this.itemSize + 1] = t,
                    this
                }
                getZ(e) {
                    let t = this.array[e * this.itemSize + 2];
                    return this.normalized && (t = Os(t, this.array)),
                    t
                }
                setZ(e, t) {
                    return this.normalized && (t = Ds(t, this.array)),
                    this.array[e * this.itemSize + 2] = t,
                    this
                }
                getW(e) {
                    let t = this.array[e * this.itemSize + 3];
                    return this.normalized && (t = Os(t, this.array)),
                    t
                }
                setW(e, t) {
                    return this.normalized && (t = Ds(t, this.array)),
                    this.array[e * this.itemSize + 3] = t,
                    this
                }
                setXY(e, t, n) {
                    return e *= this.itemSize,
                    this.normalized && (t = Ds(t, this.array),
                    n = Ds(n, this.array)),
                    this.array[e + 0] = t,
                    this.array[e + 1] = n,
                    this
                }
                setXYZ(e, t, n, r) {
                    return e *= this.itemSize,
                    this.normalized && (t = Ds(t, this.array),
                    n = Ds(n, this.array),
                    r = Ds(r, this.array)),
                    this.array[e + 0] = t,
                    this.array[e + 1] = n,
                    this.array[e + 2] = r,
                    this
                }
                setXYZW(e, t, n, r, i) {
                    return e *= this.itemSize,
                    this.normalized && (t = Ds(t, this.array),
                    n = Ds(n, this.array),
                    r = Ds(r, this.array),
                    i = Ds(i, this.array)),
                    this.array[e + 0] = t,
                    this.array[e + 1] = n,
                    this.array[e + 2] = r,
                    this.array[e + 3] = i,
                    this
                }
                onUpload(e) {
                    return this.onUploadCallback = e,
                    this
                }
                clone() {
                    return new this.constructor(this.array,this.itemSize).copy(this)
                }
                toJSON() {
                    const e = {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: Array.from(this.array),
                        normalized: this.normalized
                    };
                    return "" !== this.name && (e.name = this.name),
                    this.usage !== vs && (e.usage = this.usage),
                    e
                }
            }
            class Ul extends Nl {
                constructor(e, t, n) {
                    super(new Uint16Array(e), t, n)
                }
            }
            class kl extends Nl {
                constructor(e, t, n) {
                    super(new Uint32Array(e), t, n)
                }
            }
            class Fl extends Nl {
                constructor(e, t, n) {
                    super(new Float32Array(e), t, n)
                }
            }
            let zl = 0;
            const Bl = new zo
              , Hl = new hl
              , Gl = new lo
              , Vl = new ho
              , Wl = new ho
              , jl = new lo;
            class Xl extends Es {
                constructor() {
                    super(),
                    this.isBufferGeometry = !0,
                    Object.defineProperty(this, "id", {
                        value: zl++
                    }),
                    this.uuid = Ts(),
                    this.name = "",
                    this.type = "BufferGeometry",
                    this.index = null,
                    this.attributes = {},
                    this.morphAttributes = {},
                    this.morphTargetsRelative = !1,
                    this.groups = [],
                    this.boundingBox = null,
                    this.boundingSphere = null,
                    this.drawRange = {
                        start: 0,
                        count: 1 / 0
                    },
                    this.userData = {}
                }
                getIndex() {
                    return this.index
                }
                setIndex(e) {
                    return Array.isArray(e) ? this.index = new (ks(e) ? kl : Ul)(e,1) : this.index = e,
                    this
                }
                getAttribute(e) {
                    return this.attributes[e]
                }
                setAttribute(e, t) {
                    return this.attributes[e] = t,
                    this
                }
                deleteAttribute(e) {
                    return delete this.attributes[e],
                    this
                }
                hasAttribute(e) {
                    return void 0 !== this.attributes[e]
                }
                addGroup(e, t, n=0) {
                    this.groups.push({
                        start: e,
                        count: t,
                        materialIndex: n
                    })
                }
                clearGroups() {
                    this.groups = []
                }
                setDrawRange(e, t) {
                    this.drawRange.start = e,
                    this.drawRange.count = t
                }
                applyMatrix4(e) {
                    const t = this.attributes.position;
                    void 0 !== t && (t.applyMatrix4(e),
                    t.needsUpdate = !0);
                    const n = this.attributes.normal;
                    if (void 0 !== n) {
                        const t = (new Ns).getNormalMatrix(e);
                        n.applyNormalMatrix(t),
                        n.needsUpdate = !0
                    }
                    const r = this.attributes.tangent;
                    return void 0 !== r && (r.transformDirection(e),
                    r.needsUpdate = !0),
                    null !== this.boundingBox && this.computeBoundingBox(),
                    null !== this.boundingSphere && this.computeBoundingSphere(),
                    this
                }
                applyQuaternion(e) {
                    return Bl.makeRotationFromQuaternion(e),
                    this.applyMatrix4(Bl),
                    this
                }
                rotateX(e) {
                    return Bl.makeRotationX(e),
                    this.applyMatrix4(Bl),
                    this
                }
                rotateY(e) {
                    return Bl.makeRotationY(e),
                    this.applyMatrix4(Bl),
                    this
                }
                rotateZ(e) {
                    return Bl.makeRotationZ(e),
                    this.applyMatrix4(Bl),
                    this
                }
                translate(e, t, n) {
                    return Bl.makeTranslation(e, t, n),
                    this.applyMatrix4(Bl),
                    this
                }
                scale(e, t, n) {
                    return Bl.makeScale(e, t, n),
                    this.applyMatrix4(Bl),
                    this
                }
                lookAt(e) {
                    return Hl.lookAt(e),
                    Hl.updateMatrix(),
                    this.applyMatrix4(Hl.matrix),
                    this
                }
                center() {
                    return this.computeBoundingBox(),
                    this.boundingBox.getCenter(Gl).negate(),
                    this.translate(Gl.x, Gl.y, Gl.z),
                    this
                }
                setFromPoints(e) {
                    const t = [];
                    for (let n = 0, r = e.length; n < r; n++) {
                        const r = e[n];
                        t.push(r.x, r.y, r.z || 0)
                    }
                    return this.setAttribute("position", new Fl(t,3)),
                    this
                }
                computeBoundingBox() {
                    null === this.boundingBox && (this.boundingBox = new ho);
                    const e = this.attributes.position
                      , t = this.morphAttributes.position;
                    if (e && e.isGLBufferAttribute)
                        return console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this),
                        void this.boundingBox.set(new lo(-1 / 0,-1 / 0,-1 / 0), new lo(1 / 0,1 / 0,1 / 0));
                    if (void 0 !== e) {
                        if (this.boundingBox.setFromBufferAttribute(e),
                        t)
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e];
                                Vl.setFromBufferAttribute(n),
                                this.morphTargetsRelative ? (jl.addVectors(this.boundingBox.min, Vl.min),
                                this.boundingBox.expandByPoint(jl),
                                jl.addVectors(this.boundingBox.max, Vl.max),
                                this.boundingBox.expandByPoint(jl)) : (this.boundingBox.expandByPoint(Vl.min),
                                this.boundingBox.expandByPoint(Vl.max))
                            }
                    } else
                        this.boundingBox.makeEmpty();
                    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                }
                computeBoundingSphere() {
                    null === this.boundingSphere && (this.boundingSphere = new Ro);
                    const e = this.attributes.position
                      , t = this.morphAttributes.position;
                    if (e && e.isGLBufferAttribute)
                        return console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this),
                        void this.boundingSphere.set(new lo, 1 / 0);
                    if (e) {
                        const n = this.boundingSphere.center;
                        if (Vl.setFromBufferAttribute(e),
                        t)
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e];
                                Wl.setFromBufferAttribute(n),
                                this.morphTargetsRelative ? (jl.addVectors(Vl.min, Wl.min),
                                Vl.expandByPoint(jl),
                                jl.addVectors(Vl.max, Wl.max),
                                Vl.expandByPoint(jl)) : (Vl.expandByPoint(Wl.min),
                                Vl.expandByPoint(Wl.max))
                            }
                        Vl.getCenter(n);
                        let r = 0;
                        for (let t = 0, i = e.count; t < i; t++)
                            jl.fromBufferAttribute(e, t),
                            r = Math.max(r, n.distanceToSquared(jl));
                        if (t)
                            for (let i = 0, a = t.length; i < a; i++) {
                                const a = t[i]
                                  , s = this.morphTargetsRelative;
                                for (let t = 0, i = a.count; t < i; t++)
                                    jl.fromBufferAttribute(a, t),
                                    s && (Gl.fromBufferAttribute(e, t),
                                    jl.add(Gl)),
                                    r = Math.max(r, n.distanceToSquared(jl))
                            }
                        this.boundingSphere.radius = Math.sqrt(r),
                        isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                    }
                }
                computeTangents() {
                    const e = this.index
                      , t = this.attributes;
                    if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv)
                        return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                    const n = t.position
                      , r = t.normal
                      , i = t.uv;
                    !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Nl(new Float32Array(4 * n.count),4));
                    const a = this.getAttribute("tangent")
                      , s = []
                      , o = [];
                    for (let e = 0; e < n.count; e++)
                        s[e] = new lo,
                        o[e] = new lo;
                    const l = new lo
                      , c = new lo
                      , u = new lo
                      , d = new Is
                      , h = new Is
                      , p = new Is
                      , f = new lo
                      , m = new lo;
                    function g(e, t, r) {
                        l.fromBufferAttribute(n, e),
                        c.fromBufferAttribute(n, t),
                        u.fromBufferAttribute(n, r),
                        d.fromBufferAttribute(i, e),
                        h.fromBufferAttribute(i, t),
                        p.fromBufferAttribute(i, r),
                        c.sub(l),
                        u.sub(l),
                        h.sub(d),
                        p.sub(d);
                        const a = 1 / (h.x * p.y - p.x * h.y);
                        isFinite(a) && (f.copy(c).multiplyScalar(p.y).addScaledVector(u, -h.y).multiplyScalar(a),
                        m.copy(u).multiplyScalar(h.x).addScaledVector(c, -p.x).multiplyScalar(a),
                        s[e].add(f),
                        s[t].add(f),
                        s[r].add(f),
                        o[e].add(m),
                        o[t].add(m),
                        o[r].add(m))
                    }
                    let v = this.groups;
                    0 === v.length && (v = [{
                        start: 0,
                        count: e.count
                    }]);
                    for (let t = 0, n = v.length; t < n; ++t) {
                        const n = v[t]
                          , r = n.start;
                        for (let t = r, i = r + n.count; t < i; t += 3)
                            g(e.getX(t + 0), e.getX(t + 1), e.getX(t + 2))
                    }
                    const _ = new lo
                      , y = new lo
                      , x = new lo
                      , b = new lo;
                    function E(e) {
                        x.fromBufferAttribute(r, e),
                        b.copy(x);
                        const t = s[e];
                        _.copy(t),
                        _.sub(x.multiplyScalar(x.dot(t))).normalize(),
                        y.crossVectors(b, t);
                        const n = y.dot(o[e]) < 0 ? -1 : 1;
                        a.setXYZW(e, _.x, _.y, _.z, n)
                    }
                    for (let t = 0, n = v.length; t < n; ++t) {
                        const n = v[t]
                          , r = n.start;
                        for (let t = r, i = r + n.count; t < i; t += 3)
                            E(e.getX(t + 0)),
                            E(e.getX(t + 1)),
                            E(e.getX(t + 2))
                    }
                }
                computeVertexNormals() {
                    const e = this.index
                      , t = this.getAttribute("position");
                    if (void 0 !== t) {
                        let n = this.getAttribute("normal");
                        if (void 0 === n)
                            n = new Nl(new Float32Array(3 * t.count),3),
                            this.setAttribute("normal", n);
                        else
                            for (let e = 0, t = n.count; e < t; e++)
                                n.setXYZ(e, 0, 0, 0);
                        const r = new lo
                          , i = new lo
                          , a = new lo
                          , s = new lo
                          , o = new lo
                          , l = new lo
                          , c = new lo
                          , u = new lo;
                        if (e)
                            for (let d = 0, h = e.count; d < h; d += 3) {
                                const h = e.getX(d + 0)
                                  , p = e.getX(d + 1)
                                  , f = e.getX(d + 2);
                                r.fromBufferAttribute(t, h),
                                i.fromBufferAttribute(t, p),
                                a.fromBufferAttribute(t, f),
                                c.subVectors(a, i),
                                u.subVectors(r, i),
                                c.cross(u),
                                s.fromBufferAttribute(n, h),
                                o.fromBufferAttribute(n, p),
                                l.fromBufferAttribute(n, f),
                                s.add(c),
                                o.add(c),
                                l.add(c),
                                n.setXYZ(h, s.x, s.y, s.z),
                                n.setXYZ(p, o.x, o.y, o.z),
                                n.setXYZ(f, l.x, l.y, l.z)
                            }
                        else
                            for (let e = 0, s = t.count; e < s; e += 3)
                                r.fromBufferAttribute(t, e + 0),
                                i.fromBufferAttribute(t, e + 1),
                                a.fromBufferAttribute(t, e + 2),
                                c.subVectors(a, i),
                                u.subVectors(r, i),
                                c.cross(u),
                                n.setXYZ(e + 0, c.x, c.y, c.z),
                                n.setXYZ(e + 1, c.x, c.y, c.z),
                                n.setXYZ(e + 2, c.x, c.y, c.z);
                        this.normalizeNormals(),
                        n.needsUpdate = !0
                    }
                }
                normalizeNormals() {
                    const e = this.attributes.normal;
                    for (let t = 0, n = e.count; t < n; t++)
                        jl.fromBufferAttribute(e, t),
                        jl.normalize(),
                        e.setXYZ(t, jl.x, jl.y, jl.z)
                }
                toNonIndexed() {
                    function e(e, t) {
                        const n = e.array
                          , r = e.itemSize
                          , i = e.normalized
                          , a = new n.constructor(t.length * r);
                        let s = 0
                          , o = 0;
                        for (let i = 0, l = t.length; i < l; i++) {
                            s = e.isInterleavedBufferAttribute ? t[i] * e.data.stride + e.offset : t[i] * r;
                            for (let e = 0; e < r; e++)
                                a[o++] = n[s++]
                        }
                        return new Nl(a,r,i)
                    }
                    if (null === this.index)
                        return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
                        this;
                    const t = new Xl
                      , n = this.index.array
                      , r = this.attributes;
                    for (const i in r) {
                        const a = e(r[i], n);
                        t.setAttribute(i, a)
                    }
                    const i = this.morphAttributes;
                    for (const r in i) {
                        const a = []
                          , s = i[r];
                        for (let t = 0, r = s.length; t < r; t++) {
                            const r = e(s[t], n);
                            a.push(r)
                        }
                        t.morphAttributes[r] = a
                    }
                    t.morphTargetsRelative = this.morphTargetsRelative;
                    const a = this.groups;
                    for (let e = 0, n = a.length; e < n; e++) {
                        const n = a[e];
                        t.addGroup(n.start, n.count, n.materialIndex)
                    }
                    return t
                }
                toJSON() {
                    const e = {
                        metadata: {
                            version: 4.6,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (e.uuid = this.uuid,
                    e.type = this.type,
                    "" !== this.name && (e.name = this.name),
                    Object.keys(this.userData).length > 0 && (e.userData = this.userData),
                    void 0 !== this.parameters) {
                        const t = this.parameters;
                        for (const n in t)
                            void 0 !== t[n] && (e[n] = t[n]);
                        return e
                    }
                    e.data = {
                        attributes: {}
                    };
                    const t = this.index;
                    null !== t && (e.data.index = {
                        type: t.array.constructor.name,
                        array: Array.prototype.slice.call(t.array)
                    });
                    const n = this.attributes;
                    for (const t in n) {
                        const r = n[t];
                        e.data.attributes[t] = r.toJSON(e.data)
                    }
                    const r = {};
                    let i = !1;
                    for (const t in this.morphAttributes) {
                        const n = this.morphAttributes[t]
                          , a = [];
                        for (let t = 0, r = n.length; t < r; t++) {
                            const r = n[t];
                            a.push(r.toJSON(e.data))
                        }
                        a.length > 0 && (r[t] = a,
                        i = !0)
                    }
                    i && (e.data.morphAttributes = r,
                    e.data.morphTargetsRelative = this.morphTargetsRelative);
                    const a = this.groups;
                    a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
                    const s = this.boundingSphere;
                    return null !== s && (e.data.boundingSphere = {
                        center: s.center.toArray(),
                        radius: s.radius
                    }),
                    e
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    this.index = null,
                    this.attributes = {},
                    this.morphAttributes = {},
                    this.groups = [],
                    this.boundingBox = null,
                    this.boundingSphere = null;
                    const t = {};
                    this.name = e.name;
                    const n = e.index;
                    null !== n && this.setIndex(n.clone(t));
                    const r = e.attributes;
                    for (const e in r) {
                        const n = r[e];
                        this.setAttribute(e, n.clone(t))
                    }
                    const i = e.morphAttributes;
                    for (const e in i) {
                        const n = []
                          , r = i[e];
                        for (let e = 0, i = r.length; e < i; e++)
                            n.push(r[e].clone(t));
                        this.morphAttributes[e] = n
                    }
                    this.morphTargetsRelative = e.morphTargetsRelative;
                    const a = e.groups;
                    for (let e = 0, t = a.length; e < t; e++) {
                        const t = a[e];
                        this.addGroup(t.start, t.count, t.materialIndex)
                    }
                    const s = e.boundingBox;
                    null !== s && (this.boundingBox = s.clone());
                    const o = e.boundingSphere;
                    return null !== o && (this.boundingSphere = o.clone()),
                    this.drawRange.start = e.drawRange.start,
                    this.drawRange.count = e.drawRange.count,
                    this.userData = e.userData,
                    this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            const ql = new zo
              , Yl = new Fo
              , $l = new Ro
              , Kl = new lo
              , Zl = new lo
              , Jl = new lo
              , Ql = new lo
              , ec = new lo
              , tc = new lo
              , nc = new Is
              , rc = new Is
              , ic = new Is
              , ac = new lo
              , sc = new lo
              , oc = new lo
              , lc = new lo
              , cc = new lo;
            class uc extends hl {
                constructor(e=new Xl, t=new Ol) {
                    super(),
                    this.isMesh = !0,
                    this.type = "Mesh",
                    this.geometry = e,
                    this.material = t,
                    this.updateMorphTargets()
                }
                copy(e, t) {
                    return super.copy(e, t),
                    void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
                    void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
                    this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
                    this.geometry = e.geometry,
                    this
                }
                updateMorphTargets() {
                    const e = this.geometry.morphAttributes
                      , t = Object.keys(e);
                    if (t.length > 0) {
                        const n = e[t[0]];
                        if (void 0 !== n) {
                            this.morphTargetInfluences = [],
                            this.morphTargetDictionary = {};
                            for (let e = 0, t = n.length; e < t; e++) {
                                const t = n[e].name || String(e);
                                this.morphTargetInfluences.push(0),
                                this.morphTargetDictionary[t] = e
                            }
                        }
                    }
                }
                getVertexPosition(e, t) {
                    const n = this.geometry
                      , r = n.attributes.position
                      , i = n.morphAttributes.position
                      , a = n.morphTargetsRelative;
                    t.fromBufferAttribute(r, e);
                    const s = this.morphTargetInfluences;
                    if (i && s) {
                        tc.set(0, 0, 0);
                        for (let n = 0, r = i.length; n < r; n++) {
                            const r = s[n]
                              , o = i[n];
                            0 !== r && (ec.fromBufferAttribute(o, e),
                            a ? tc.addScaledVector(ec, r) : tc.addScaledVector(ec.sub(t), r))
                        }
                        t.add(tc)
                    }
                    return t
                }
                raycast(e, t) {
                    const n = this.geometry
                      , r = this.material
                      , i = this.matrixWorld;
                    if (void 0 !== r) {
                        if (null === n.boundingSphere && n.computeBoundingSphere(),
                        $l.copy(n.boundingSphere),
                        $l.applyMatrix4(i),
                        Yl.copy(e.ray).recast(e.near),
                        !1 === $l.containsPoint(Yl.origin)) {
                            if (null === Yl.intersectSphere($l, Kl))
                                return;
                            if (Yl.origin.distanceToSquared(Kl) > (e.far - e.near) ** 2)
                                return
                        }
                        ql.copy(i).invert(),
                        Yl.copy(e.ray).applyMatrix4(ql),
                        null !== n.boundingBox && !1 === Yl.intersectsBox(n.boundingBox) || this._computeIntersections(e, t, Yl)
                    }
                }
                _computeIntersections(e, t, n) {
                    let r;
                    const i = this.geometry
                      , a = this.material
                      , s = i.index
                      , o = i.attributes.position
                      , l = i.attributes.uv
                      , c = i.attributes.uv1
                      , u = i.attributes.normal
                      , d = i.groups
                      , h = i.drawRange;
                    if (null !== s)
                        if (Array.isArray(a))
                            for (let i = 0, o = d.length; i < o; i++) {
                                const o = d[i]
                                  , p = a[o.materialIndex];
                                for (let i = Math.max(o.start, h.start), a = Math.min(s.count, Math.min(o.start + o.count, h.start + h.count)); i < a; i += 3) {
                                    r = dc(this, p, e, n, l, c, u, s.getX(i), s.getX(i + 1), s.getX(i + 2)),
                                    r && (r.faceIndex = Math.floor(i / 3),
                                    r.face.materialIndex = o.materialIndex,
                                    t.push(r))
                                }
                            }
                        else {
                            for (let i = Math.max(0, h.start), o = Math.min(s.count, h.start + h.count); i < o; i += 3) {
                                r = dc(this, a, e, n, l, c, u, s.getX(i), s.getX(i + 1), s.getX(i + 2)),
                                r && (r.faceIndex = Math.floor(i / 3),
                                t.push(r))
                            }
                        }
                    else if (void 0 !== o)
                        if (Array.isArray(a))
                            for (let i = 0, s = d.length; i < s; i++) {
                                const s = d[i]
                                  , p = a[s.materialIndex];
                                for (let i = Math.max(s.start, h.start), a = Math.min(o.count, Math.min(s.start + s.count, h.start + h.count)); i < a; i += 3) {
                                    r = dc(this, p, e, n, l, c, u, i, i + 1, i + 2),
                                    r && (r.faceIndex = Math.floor(i / 3),
                                    r.face.materialIndex = s.materialIndex,
                                    t.push(r))
                                }
                            }
                        else {
                            for (let i = Math.max(0, h.start), s = Math.min(o.count, h.start + h.count); i < s; i += 3) {
                                r = dc(this, a, e, n, l, c, u, i, i + 1, i + 2),
                                r && (r.faceIndex = Math.floor(i / 3),
                                t.push(r))
                            }
                        }
                }
            }
            function dc(e, t, n, r, i, a, s, o, l, c) {
                e.getVertexPosition(o, Zl),
                e.getVertexPosition(l, Jl),
                e.getVertexPosition(c, Ql);
                const u = function(e, t, n, r, i, a, s, o) {
                    let l;
                    if (l = t.side === pa ? r.intersectTriangle(s, a, i, !0, o) : r.intersectTriangle(i, a, s, t.side === ha, o),
                    null === l)
                        return null;
                    cc.copy(o),
                    cc.applyMatrix4(e.matrixWorld);
                    const c = n.ray.origin.distanceTo(cc);
                    return c < n.near || c > n.far ? null : {
                        distance: c,
                        point: cc.clone(),
                        object: e
                    }
                }(e, t, n, r, Zl, Jl, Ql, lc);
                if (u) {
                    i && (nc.fromBufferAttribute(i, o),
                    rc.fromBufferAttribute(i, l),
                    ic.fromBufferAttribute(i, c),
                    u.uv = Sl.getInterpolation(lc, Zl, Jl, Ql, nc, rc, ic, new Is)),
                    a && (nc.fromBufferAttribute(a, o),
                    rc.fromBufferAttribute(a, l),
                    ic.fromBufferAttribute(a, c),
                    u.uv1 = Sl.getInterpolation(lc, Zl, Jl, Ql, nc, rc, ic, new Is)),
                    s && (ac.fromBufferAttribute(s, o),
                    sc.fromBufferAttribute(s, l),
                    oc.fromBufferAttribute(s, c),
                    u.normal = Sl.getInterpolation(lc, Zl, Jl, Ql, ac, sc, oc, new lo),
                    u.normal.dot(r.direction) > 0 && u.normal.multiplyScalar(-1));
                    const e = {
                        a: o,
                        b: l,
                        c: c,
                        normal: new lo,
                        materialIndex: 0
                    };
                    Sl.getNormal(Zl, Jl, Ql, e.normal),
                    u.face = e
                }
                return u
            }
            class hc extends Xl {
                constructor(e=1, t=1, n=1, r=1, i=1, a=1) {
                    super(),
                    this.type = "BoxGeometry",
                    this.parameters = {
                        width: e,
                        height: t,
                        depth: n,
                        widthSegments: r,
                        heightSegments: i,
                        depthSegments: a
                    };
                    const s = this;
                    r = Math.floor(r),
                    i = Math.floor(i),
                    a = Math.floor(a);
                    const o = []
                      , l = []
                      , c = []
                      , u = [];
                    let d = 0
                      , h = 0;
                    function p(e, t, n, r, i, a, p, f, m, g, v) {
                        const _ = a / m
                          , y = p / g
                          , x = a / 2
                          , b = p / 2
                          , E = f / 2
                          , S = m + 1
                          , w = g + 1;
                        let M = 0
                          , T = 0;
                        const A = new lo;
                        for (let a = 0; a < w; a++) {
                            const s = a * y - b;
                            for (let o = 0; o < S; o++) {
                                const d = o * _ - x;
                                A[e] = d * r,
                                A[t] = s * i,
                                A[n] = E,
                                l.push(A.x, A.y, A.z),
                                A[e] = 0,
                                A[t] = 0,
                                A[n] = f > 0 ? 1 : -1,
                                c.push(A.x, A.y, A.z),
                                u.push(o / m),
                                u.push(1 - a / g),
                                M += 1
                            }
                        }
                        for (let e = 0; e < g; e++)
                            for (let t = 0; t < m; t++) {
                                const n = d + t + S * e
                                  , r = d + t + S * (e + 1)
                                  , i = d + (t + 1) + S * (e + 1)
                                  , a = d + (t + 1) + S * e;
                                o.push(n, r, a),
                                o.push(r, i, a),
                                T += 6
                            }
                        s.addGroup(h, T, v),
                        h += T,
                        d += M
                    }
                    p("z", "y", "x", -1, -1, n, t, e, a, i, 0),
                    p("z", "y", "x", 1, -1, n, t, -e, a, i, 1),
                    p("x", "z", "y", 1, 1, e, n, t, r, a, 2),
                    p("x", "z", "y", 1, -1, e, n, -t, r, a, 3),
                    p("x", "y", "z", 1, -1, e, t, n, r, i, 4),
                    p("x", "y", "z", -1, -1, e, t, -n, r, i, 5),
                    this.setIndex(o),
                    this.setAttribute("position", new Fl(l,3)),
                    this.setAttribute("normal", new Fl(c,3)),
                    this.setAttribute("uv", new Fl(u,2))
                }
                copy(e) {
                    return super.copy(e),
                    this.parameters = Object.assign({}, e.parameters),
                    this
                }
                static fromJSON(e) {
                    return new hc(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
                }
            }
            function pc(e) {
                const t = {};
                for (const n in e) {
                    t[n] = {};
                    for (const r in e[n]) {
                        const i = e[n][r];
                        i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
                        t[n][r] = null) : t[n][r] = i.clone() : Array.isArray(i) ? t[n][r] = i.slice() : t[n][r] = i
                    }
                }
                return t
            }
            function fc(e) {
                const t = {};
                for (let n = 0; n < e.length; n++) {
                    const r = pc(e[n]);
                    for (const e in r)
                        t[e] = r[e]
                }
                return t
            }
            function mc(e) {
                return null === e.getRenderTarget() ? e.outputColorSpace : Xs.workingColorSpace
            }
            const gc = {
                clone: pc,
                merge: fc
            };
            class vc extends Ll {
                constructor(e) {
                    super(),
                    this.isShaderMaterial = !0,
                    this.type = "ShaderMaterial",
                    this.defines = {},
                    this.uniforms = {},
                    this.uniformsGroups = [],
                    this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
                    this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
                    this.linewidth = 1,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.fog = !1,
                    this.lights = !1,
                    this.clipping = !1,
                    this.forceSinglePass = !0,
                    this.extensions = {
                        derivatives: !1,
                        fragDepth: !1,
                        drawBuffers: !1,
                        shaderTextureLOD: !1,
                        clipCullDistance: !1,
                        multiDraw: !1
                    },
                    this.defaultAttributeValues = {
                        color: [1, 1, 1],
                        uv: [0, 0],
                        uv1: [0, 0]
                    },
                    this.index0AttributeName = void 0,
                    this.uniformsNeedUpdate = !1,
                    this.glslVersion = null,
                    void 0 !== e && this.setValues(e)
                }
                copy(e) {
                    return super.copy(e),
                    this.fragmentShader = e.fragmentShader,
                    this.vertexShader = e.vertexShader,
                    this.uniforms = pc(e.uniforms),
                    this.uniformsGroups = function(e) {
                        const t = [];
                        for (let n = 0; n < e.length; n++)
                            t.push(e[n].clone());
                        return t
                    }(e.uniformsGroups),
                    this.defines = Object.assign({}, e.defines),
                    this.wireframe = e.wireframe,
                    this.wireframeLinewidth = e.wireframeLinewidth,
                    this.fog = e.fog,
                    this.lights = e.lights,
                    this.clipping = e.clipping,
                    this.extensions = Object.assign({}, e.extensions),
                    this.glslVersion = e.glslVersion,
                    this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    t.glslVersion = this.glslVersion,
                    t.uniforms = {};
                    for (const n in this.uniforms) {
                        const r = this.uniforms[n].value;
                        r && r.isTexture ? t.uniforms[n] = {
                            type: "t",
                            value: r.toJSON(e).uuid
                        } : r && r.isColor ? t.uniforms[n] = {
                            type: "c",
                            value: r.getHex()
                        } : r && r.isVector2 ? t.uniforms[n] = {
                            type: "v2",
                            value: r.toArray()
                        } : r && r.isVector3 ? t.uniforms[n] = {
                            type: "v3",
                            value: r.toArray()
                        } : r && r.isVector4 ? t.uniforms[n] = {
                            type: "v4",
                            value: r.toArray()
                        } : r && r.isMatrix3 ? t.uniforms[n] = {
                            type: "m3",
                            value: r.toArray()
                        } : r && r.isMatrix4 ? t.uniforms[n] = {
                            type: "m4",
                            value: r.toArray()
                        } : t.uniforms[n] = {
                            value: r
                        }
                    }
                    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
                    t.vertexShader = this.vertexShader,
                    t.fragmentShader = this.fragmentShader,
                    t.lights = this.lights,
                    t.clipping = this.clipping;
                    const n = {};
                    for (const e in this.extensions)
                        !0 === this.extensions[e] && (n[e] = !0);
                    return Object.keys(n).length > 0 && (t.extensions = n),
                    t
                }
            }
            class _c extends hl {
                constructor() {
                    super(),
                    this.isCamera = !0,
                    this.type = "Camera",
                    this.matrixWorldInverse = new zo,
                    this.projectionMatrix = new zo,
                    this.projectionMatrixInverse = new zo,
                    this.coordinateSystem = xs
                }
                copy(e, t) {
                    return super.copy(e, t),
                    this.matrixWorldInverse.copy(e.matrixWorldInverse),
                    this.projectionMatrix.copy(e.projectionMatrix),
                    this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
                    this.coordinateSystem = e.coordinateSystem,
                    this
                }
                getWorldDirection(e) {
                    return super.getWorldDirection(e).negate()
                }
                updateMatrixWorld(e) {
                    super.updateMatrixWorld(e),
                    this.matrixWorldInverse.copy(this.matrixWorld).invert()
                }
                updateWorldMatrix(e, t) {
                    super.updateWorldMatrix(e, t),
                    this.matrixWorldInverse.copy(this.matrixWorld).invert()
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            const yc = new lo
              , xc = new Is
              , bc = new Is;
            class Ec extends _c {
                constructor(e=50, t=1, n=.1, r=2e3) {
                    super(),
                    this.isPerspectiveCamera = !0,
                    this.type = "PerspectiveCamera",
                    this.fov = e,
                    this.zoom = 1,
                    this.near = n,
                    this.far = r,
                    this.focus = 10,
                    this.aspect = t,
                    this.view = null,
                    this.filmGauge = 35,
                    this.filmOffset = 0,
                    this.updateProjectionMatrix()
                }
                copy(e, t) {
                    return super.copy(e, t),
                    this.fov = e.fov,
                    this.zoom = e.zoom,
                    this.near = e.near,
                    this.far = e.far,
                    this.focus = e.focus,
                    this.aspect = e.aspect,
                    this.view = null === e.view ? null : Object.assign({}, e.view),
                    this.filmGauge = e.filmGauge,
                    this.filmOffset = e.filmOffset,
                    this
                }
                setFocalLength(e) {
                    const t = .5 * this.getFilmHeight() / e;
                    this.fov = 2 * Ms * Math.atan(t),
                    this.updateProjectionMatrix()
                }
                getFocalLength() {
                    const e = Math.tan(.5 * ws * this.fov);
                    return .5 * this.getFilmHeight() / e
                }
                getEffectiveFOV() {
                    return 2 * Ms * Math.atan(Math.tan(.5 * ws * this.fov) / this.zoom)
                }
                getFilmWidth() {
                    return this.filmGauge * Math.min(this.aspect, 1)
                }
                getFilmHeight() {
                    return this.filmGauge / Math.max(this.aspect, 1)
                }
                getViewBounds(e, t, n) {
                    yc.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse),
                    t.set(yc.x, yc.y).multiplyScalar(-e / yc.z),
                    yc.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse),
                    n.set(yc.x, yc.y).multiplyScalar(-e / yc.z)
                }
                getViewSize(e, t) {
                    return this.getViewBounds(e, xc, bc),
                    t.subVectors(bc, xc)
                }
                setViewOffset(e, t, n, r, i, a) {
                    this.aspect = e / t,
                    null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }),
                    this.view.enabled = !0,
                    this.view.fullWidth = e,
                    this.view.fullHeight = t,
                    this.view.offsetX = n,
                    this.view.offsetY = r,
                    this.view.width = i,
                    this.view.height = a,
                    this.updateProjectionMatrix()
                }
                clearViewOffset() {
                    null !== this.view && (this.view.enabled = !1),
                    this.updateProjectionMatrix()
                }
                updateProjectionMatrix() {
                    const e = this.near;
                    let t = e * Math.tan(.5 * ws * this.fov) / this.zoom
                      , n = 2 * t
                      , r = this.aspect * n
                      , i = -.5 * r;
                    const a = this.view;
                    if (null !== this.view && this.view.enabled) {
                        const e = a.fullWidth
                          , s = a.fullHeight;
                        i += a.offsetX * r / e,
                        t -= a.offsetY * n / s,
                        r *= a.width / e,
                        n *= a.height / s
                    }
                    const s = this.filmOffset;
                    0 !== s && (i += e * s / this.getFilmWidth()),
                    this.projectionMatrix.makePerspective(i, i + r, t, t - n, e, this.far, this.coordinateSystem),
                    this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return t.object.fov = this.fov,
                    t.object.zoom = this.zoom,
                    t.object.near = this.near,
                    t.object.far = this.far,
                    t.object.focus = this.focus,
                    t.object.aspect = this.aspect,
                    null !== this.view && (t.object.view = Object.assign({}, this.view)),
                    t.object.filmGauge = this.filmGauge,
                    t.object.filmOffset = this.filmOffset,
                    t
                }
            }
            const Sc = -90;
            class wc extends hl {
                constructor(e, t, n) {
                    super(),
                    this.type = "CubeCamera",
                    this.renderTarget = n,
                    this.coordinateSystem = null,
                    this.activeMipmapLevel = 0;
                    const r = new Ec(Sc,1,e,t);
                    r.layers = this.layers,
                    this.add(r);
                    const i = new Ec(Sc,1,e,t);
                    i.layers = this.layers,
                    this.add(i);
                    const a = new Ec(Sc,1,e,t);
                    a.layers = this.layers,
                    this.add(a);
                    const s = new Ec(Sc,1,e,t);
                    s.layers = this.layers,
                    this.add(s);
                    const o = new Ec(Sc,1,e,t);
                    o.layers = this.layers,
                    this.add(o);
                    const l = new Ec(Sc,1,e,t);
                    l.layers = this.layers,
                    this.add(l)
                }
                updateCoordinateSystem() {
                    const e = this.coordinateSystem
                      , t = this.children.concat()
                      , [n,r,i,a,s,o] = t;
                    for (const e of t)
                        this.remove(e);
                    if (e === xs)
                        n.up.set(0, 1, 0),
                        n.lookAt(1, 0, 0),
                        r.up.set(0, 1, 0),
                        r.lookAt(-1, 0, 0),
                        i.up.set(0, 0, -1),
                        i.lookAt(0, 1, 0),
                        a.up.set(0, 0, 1),
                        a.lookAt(0, -1, 0),
                        s.up.set(0, 1, 0),
                        s.lookAt(0, 0, 1),
                        o.up.set(0, 1, 0),
                        o.lookAt(0, 0, -1);
                    else {
                        if (e !== bs)
                            throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
                        n.up.set(0, -1, 0),
                        n.lookAt(-1, 0, 0),
                        r.up.set(0, -1, 0),
                        r.lookAt(1, 0, 0),
                        i.up.set(0, 0, 1),
                        i.lookAt(0, 1, 0),
                        a.up.set(0, 0, -1),
                        a.lookAt(0, -1, 0),
                        s.up.set(0, -1, 0),
                        s.lookAt(0, 0, 1),
                        o.up.set(0, -1, 0),
                        o.lookAt(0, 0, -1)
                    }
                    for (const e of t)
                        this.add(e),
                        e.updateMatrixWorld()
                }
                update(e, t) {
                    null === this.parent && this.updateMatrixWorld();
                    const {renderTarget: n, activeMipmapLevel: r} = this;
                    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem,
                    this.updateCoordinateSystem());
                    const [i,a,s,o,l,c] = this.children
                      , u = e.getRenderTarget()
                      , d = e.getActiveCubeFace()
                      , h = e.getActiveMipmapLevel()
                      , p = e.xr.enabled;
                    e.xr.enabled = !1;
                    const f = n.texture.generateMipmaps;
                    n.texture.generateMipmaps = !1,
                    e.setRenderTarget(n, 0, r),
                    e.render(t, i),
                    e.setRenderTarget(n, 1, r),
                    e.render(t, a),
                    e.setRenderTarget(n, 2, r),
                    e.render(t, s),
                    e.setRenderTarget(n, 3, r),
                    e.render(t, o),
                    e.setRenderTarget(n, 4, r),
                    e.render(t, l),
                    n.texture.generateMipmaps = f,
                    e.setRenderTarget(n, 5, r),
                    e.render(t, c),
                    e.setRenderTarget(u, d, h),
                    e.xr.enabled = p,
                    n.texture.needsPMREMUpdate = !0
                }
            }
            class Mc extends to {
                constructor(e, t, n, r, i, a, s, o, l, c) {
                    super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : Ta, n, r, i, a, s, o, l, c),
                    this.isCubeTexture = !0,
                    this.flipY = !1
                }
                get images() {
                    return this.image
                }
                set images(e) {
                    this.image = e
                }
            }
            class Tc extends io {
                constructor(e=1, t={}) {
                    super(e, e, t),
                    this.isWebGLCubeRenderTarget = !0;
                    const n = {
                        width: e,
                        height: e,
                        depth: 1
                    }
                      , r = [n, n, n, n, n, n];
                    this.texture = new Mc(r,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),
                    this.texture.isRenderTargetTexture = !0,
                    this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps,
                    this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : ka
                }
                fromEquirectangularTexture(e, t) {
                    this.texture.type = t.type,
                    this.texture.colorSpace = t.colorSpace,
                    this.texture.generateMipmaps = t.generateMipmaps,
                    this.texture.minFilter = t.minFilter,
                    this.texture.magFilter = t.magFilter;
                    const n = {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                        fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
                    }
                      , r = new hc(5,5,5)
                      , i = new vc({
                        name: "CubemapFromEquirect",
                        uniforms: pc(n.uniforms),
                        vertexShader: n.vertexShader,
                        fragmentShader: n.fragmentShader,
                        side: pa,
                        blending: 0
                    });
                    i.uniforms.tEquirect.value = t;
                    const a = new uc(r,i)
                      , s = t.minFilter;
                    t.minFilter === za && (t.minFilter = ka);
                    return new wc(1,10,this).update(e, a),
                    t.minFilter = s,
                    a.geometry.dispose(),
                    a.material.dispose(),
                    this
                }
                clear(e, t, n, r) {
                    const i = e.getRenderTarget();
                    for (let i = 0; i < 6; i++)
                        e.setRenderTarget(this, i),
                        e.clear(t, n, r);
                    e.setRenderTarget(i)
                }
            }
            const Ac = new lo
              , Cc = new lo
              , Pc = new Ns;
            class Rc {
                constructor(e=new lo(1,0,0), t=0) {
                    this.isPlane = !0,
                    this.normal = e,
                    this.constant = t
                }
                set(e, t) {
                    return this.normal.copy(e),
                    this.constant = t,
                    this
                }
                setComponents(e, t, n, r) {
                    return this.normal.set(e, t, n),
                    this.constant = r,
                    this
                }
                setFromNormalAndCoplanarPoint(e, t) {
                    return this.normal.copy(e),
                    this.constant = -t.dot(this.normal),
                    this
                }
                setFromCoplanarPoints(e, t, n) {
                    const r = Ac.subVectors(n, t).cross(Cc.subVectors(e, t)).normalize();
                    return this.setFromNormalAndCoplanarPoint(r, e),
                    this
                }
                copy(e) {
                    return this.normal.copy(e.normal),
                    this.constant = e.constant,
                    this
                }
                normalize() {
                    const e = 1 / this.normal.length();
                    return this.normal.multiplyScalar(e),
                    this.constant *= e,
                    this
                }
                negate() {
                    return this.constant *= -1,
                    this.normal.negate(),
                    this
                }
                distanceToPoint(e) {
                    return this.normal.dot(e) + this.constant
                }
                distanceToSphere(e) {
                    return this.distanceToPoint(e.center) - e.radius
                }
                projectPoint(e, t) {
                    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
                }
                intersectLine(e, t) {
                    const n = e.delta(Ac)
                      , r = this.normal.dot(n);
                    if (0 === r)
                        return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
                    const i = -(e.start.dot(this.normal) + this.constant) / r;
                    return i < 0 || i > 1 ? null : t.copy(e.start).addScaledVector(n, i)
                }
                intersectsLine(e) {
                    const t = this.distanceToPoint(e.start)
                      , n = this.distanceToPoint(e.end);
                    return t < 0 && n > 0 || n < 0 && t > 0
                }
                intersectsBox(e) {
                    return e.intersectsPlane(this)
                }
                intersectsSphere(e) {
                    return e.intersectsPlane(this)
                }
                coplanarPoint(e) {
                    return e.copy(this.normal).multiplyScalar(-this.constant)
                }
                applyMatrix4(e, t) {
                    const n = t || Pc.getNormalMatrix(e)
                      , r = this.coplanarPoint(Ac).applyMatrix4(e)
                      , i = this.normal.applyMatrix3(n).normalize();
                    return this.constant = -r.dot(i),
                    this
                }
                translate(e) {
                    return this.constant -= e.dot(this.normal),
                    this
                }
                equals(e) {
                    return e.normal.equals(this.normal) && e.constant === this.constant
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            const Lc = new Ro
              , Oc = new lo;
            class Dc {
                constructor(e=new Rc, t=new Rc, n=new Rc, r=new Rc, i=new Rc, a=new Rc) {
                    this.planes = [e, t, n, r, i, a]
                }
                set(e, t, n, r, i, a) {
                    const s = this.planes;
                    return s[0].copy(e),
                    s[1].copy(t),
                    s[2].copy(n),
                    s[3].copy(r),
                    s[4].copy(i),
                    s[5].copy(a),
                    this
                }
                copy(e) {
                    const t = this.planes;
                    for (let n = 0; n < 6; n++)
                        t[n].copy(e.planes[n]);
                    return this
                }
                setFromProjectionMatrix(e, t=2e3) {
                    const n = this.planes
                      , r = e.elements
                      , i = r[0]
                      , a = r[1]
                      , s = r[2]
                      , o = r[3]
                      , l = r[4]
                      , c = r[5]
                      , u = r[6]
                      , d = r[7]
                      , h = r[8]
                      , p = r[9]
                      , f = r[10]
                      , m = r[11]
                      , g = r[12]
                      , v = r[13]
                      , _ = r[14]
                      , y = r[15];
                    if (n[0].setComponents(o - i, d - l, m - h, y - g).normalize(),
                    n[1].setComponents(o + i, d + l, m + h, y + g).normalize(),
                    n[2].setComponents(o + a, d + c, m + p, y + v).normalize(),
                    n[3].setComponents(o - a, d - c, m - p, y - v).normalize(),
                    n[4].setComponents(o - s, d - u, m - f, y - _).normalize(),
                    t === xs)
                        n[5].setComponents(o + s, d + u, m + f, y + _).normalize();
                    else {
                        if (t !== bs)
                            throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
                        n[5].setComponents(s, u, f, _).normalize()
                    }
                    return this
                }
                intersectsObject(e) {
                    if (void 0 !== e.boundingSphere)
                        null === e.boundingSphere && e.computeBoundingSphere(),
                        Lc.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
                    else {
                        const t = e.geometry;
                        null === t.boundingSphere && t.computeBoundingSphere(),
                        Lc.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
                    }
                    return this.intersectsSphere(Lc)
                }
                intersectsSprite(e) {
                    return Lc.center.set(0, 0, 0),
                    Lc.radius = .7071067811865476,
                    Lc.applyMatrix4(e.matrixWorld),
                    this.intersectsSphere(Lc)
                }
                intersectsSphere(e) {
                    const t = this.planes
                      , n = e.center
                      , r = -e.radius;
                    for (let e = 0; e < 6; e++) {
                        if (t[e].distanceToPoint(n) < r)
                            return !1
                    }
                    return !0
                }
                intersectsBox(e) {
                    const t = this.planes;
                    for (let n = 0; n < 6; n++) {
                        const r = t[n];
                        if (Oc.x = r.normal.x > 0 ? e.max.x : e.min.x,
                        Oc.y = r.normal.y > 0 ? e.max.y : e.min.y,
                        Oc.z = r.normal.z > 0 ? e.max.z : e.min.z,
                        r.distanceToPoint(Oc) < 0)
                            return !1
                    }
                    return !0
                }
                containsPoint(e) {
                    const t = this.planes;
                    for (let n = 0; n < 6; n++)
                        if (t[n].distanceToPoint(e) < 0)
                            return !1;
                    return !0
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            function Ic() {
                let e = null
                  , t = !1
                  , n = null
                  , r = null;
                function i(t, a) {
                    n(t, a),
                    r = e.requestAnimationFrame(i)
                }
                return {
                    start: function() {
                        !0 !== t && null !== n && (r = e.requestAnimationFrame(i),
                        t = !0)
                    },
                    stop: function() {
                        e.cancelAnimationFrame(r),
                        t = !1
                    },
                    setAnimationLoop: function(e) {
                        n = e
                    },
                    setContext: function(t) {
                        e = t
                    }
                }
            }
            function Nc(e, t) {
                const n = t.isWebGL2
                  , r = new WeakMap;
                return {
                    get: function(e) {
                        return e.isInterleavedBufferAttribute && (e = e.data),
                        r.get(e)
                    },
                    remove: function(t) {
                        t.isInterleavedBufferAttribute && (t = t.data);
                        const n = r.get(t);
                        n && (e.deleteBuffer(n.buffer),
                        r.delete(t))
                    },
                    update: function(t, i) {
                        if (t.isGLBufferAttribute) {
                            const e = r.get(t);
                            return void ((!e || e.version < t.version) && r.set(t, {
                                buffer: t.buffer,
                                type: t.type,
                                bytesPerElement: t.elementSize,
                                version: t.version
                            }))
                        }
                        t.isInterleavedBufferAttribute && (t = t.data);
                        const a = r.get(t);
                        if (void 0 === a)
                            r.set(t, function(t, r) {
                                const i = t.array
                                  , a = t.usage
                                  , s = i.byteLength
                                  , o = e.createBuffer();
                                let l;
                                if (e.bindBuffer(r, o),
                                e.bufferData(r, i, a),
                                t.onUploadCallback(),
                                i instanceof Float32Array)
                                    l = e.FLOAT;
                                else if (i instanceof Uint16Array)
                                    if (t.isFloat16BufferAttribute) {
                                        if (!n)
                                            throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
                                        l = e.HALF_FLOAT
                                    } else
                                        l = e.UNSIGNED_SHORT;
                                else if (i instanceof Int16Array)
                                    l = e.SHORT;
                                else if (i instanceof Uint32Array)
                                    l = e.UNSIGNED_INT;
                                else if (i instanceof Int32Array)
                                    l = e.INT;
                                else if (i instanceof Int8Array)
                                    l = e.BYTE;
                                else if (i instanceof Uint8Array)
                                    l = e.UNSIGNED_BYTE;
                                else {
                                    if (!(i instanceof Uint8ClampedArray))
                                        throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + i);
                                    l = e.UNSIGNED_BYTE
                                }
                                return {
                                    buffer: o,
                                    type: l,
                                    bytesPerElement: i.BYTES_PER_ELEMENT,
                                    version: t.version,
                                    size: s
                                }
                            }(t, i));
                        else if (a.version < t.version) {
                            if (a.size !== t.array.byteLength)
                                throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                            !function(t, r, i) {
                                const a = r.array
                                  , s = r._updateRange
                                  , o = r.updateRanges;
                                if (e.bindBuffer(i, t),
                                -1 === s.count && 0 === o.length && e.bufferSubData(i, 0, a),
                                0 !== o.length) {
                                    for (let t = 0, r = o.length; t < r; t++) {
                                        const r = o[t];
                                        n ? e.bufferSubData(i, r.start * a.BYTES_PER_ELEMENT, a, r.start, r.count) : e.bufferSubData(i, r.start * a.BYTES_PER_ELEMENT, a.subarray(r.start, r.start + r.count))
                                    }
                                    r.clearUpdateRanges()
                                }
                                -1 !== s.count && (n ? e.bufferSubData(i, s.offset * a.BYTES_PER_ELEMENT, a, s.offset, s.count) : e.bufferSubData(i, s.offset * a.BYTES_PER_ELEMENT, a.subarray(s.offset, s.offset + s.count)),
                                s.count = -1),
                                r.onUploadCallback()
                            }(a.buffer, t, i),
                            a.version = t.version
                        }
                    }
                }
            }
            class Uc extends Xl {
                constructor(e=1, t=1, n=1, r=1) {
                    super(),
                    this.type = "PlaneGeometry",
                    this.parameters = {
                        width: e,
                        height: t,
                        widthSegments: n,
                        heightSegments: r
                    };
                    const i = e / 2
                      , a = t / 2
                      , s = Math.floor(n)
                      , o = Math.floor(r)
                      , l = s + 1
                      , c = o + 1
                      , u = e / s
                      , d = t / o
                      , h = []
                      , p = []
                      , f = []
                      , m = [];
                    for (let e = 0; e < c; e++) {
                        const t = e * d - a;
                        for (let n = 0; n < l; n++) {
                            const r = n * u - i;
                            p.push(r, -t, 0),
                            f.push(0, 0, 1),
                            m.push(n / s),
                            m.push(1 - e / o)
                        }
                    }
                    for (let e = 0; e < o; e++)
                        for (let t = 0; t < s; t++) {
                            const n = t + l * e
                              , r = t + l * (e + 1)
                              , i = t + 1 + l * (e + 1)
                              , a = t + 1 + l * e;
                            h.push(n, r, a),
                            h.push(r, i, a)
                        }
                    this.setIndex(h),
                    this.setAttribute("position", new Fl(p,3)),
                    this.setAttribute("normal", new Fl(f,3)),
                    this.setAttribute("uv", new Fl(m,2))
                }
                copy(e) {
                    return super.copy(e),
                    this.parameters = Object.assign({}, e.parameters),
                    this
                }
                static fromJSON(e) {
                    return new Uc(e.width,e.height,e.widthSegments,e.heightSegments)
                }
            }
            const kc = {
                alphahash_fragment: "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
                alphahash_pars_fragment: "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
                alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
                alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                alphatest_fragment: "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif",
                alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
                aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
                aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                batching_pars_vertex: "#ifdef USE_BATCHING\n\tattribute float batchId;\n\tuniform highp sampler2D batchingTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
                batching_vertex: "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( batchId );\n#endif",
                begin_vertex: "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
                beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                bsdfs: "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
                iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
                bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif",
                clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
                color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
                color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
                common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
                cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
                emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                colorspace_pars_fragment: "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn sRGBTransferOETF( value );\n}",
                envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
                envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
                fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
                fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
                lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
                lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
                lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
                lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
                lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
                lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
                lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
                lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                lights_fragment_begin: "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
                lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
                logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
                map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                morphinstance_vertex: "#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[MORPHTARGETS_COUNT];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif",
                morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
                morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
                morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t#endif\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\t#ifndef USE_INSTANCING_MORPH\n\t\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\t#endif\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
                morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
                normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
                normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
                normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
                clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
                clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
                clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
                iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
                opaque_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
                packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
                premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
                shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
                skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tfloat startCompression = 0.8 - 0.04;\n\tfloat desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min(color.r, min(color.g, color.b));\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max(color.r, max(color.g, color.b));\n\tif (peak < startCompression) return color;\n\tfloat d = 1. - startCompression;\n\tfloat newPeak = 1. - d * d / (peak + d - startCompression);\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);\n\treturn mix(color, vec3(1, 1, 1), g);\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
                transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
                uv_pars_fragment: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
                uv_pars_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
                uv_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
                worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                depth_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
                distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                meshbasic_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
                meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
                meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                shadow_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
                sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"
            }
              , Fc = {
                common: {
                    diffuse: {
                        value: new Cl(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    mapTransform: {
                        value: new Ns
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaMapTransform: {
                        value: new Ns
                    },
                    alphaTest: {
                        value: 0
                    }
                },
                specularmap: {
                    specularMap: {
                        value: null
                    },
                    specularMapTransform: {
                        value: new Ns
                    }
                },
                envmap: {
                    envMap: {
                        value: null
                    },
                    envMapRotation: {
                        value: new Ns
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    reflectivity: {
                        value: 1
                    },
                    ior: {
                        value: 1.5
                    },
                    refractionRatio: {
                        value: .98
                    }
                },
                aomap: {
                    aoMap: {
                        value: null
                    },
                    aoMapIntensity: {
                        value: 1
                    },
                    aoMapTransform: {
                        value: new Ns
                    }
                },
                lightmap: {
                    lightMap: {
                        value: null
                    },
                    lightMapIntensity: {
                        value: 1
                    },
                    lightMapTransform: {
                        value: new Ns
                    }
                },
                bumpmap: {
                    bumpMap: {
                        value: null
                    },
                    bumpMapTransform: {
                        value: new Ns
                    },
                    bumpScale: {
                        value: 1
                    }
                },
                normalmap: {
                    normalMap: {
                        value: null
                    },
                    normalMapTransform: {
                        value: new Ns
                    },
                    normalScale: {
                        value: new Is(1,1)
                    }
                },
                displacementmap: {
                    displacementMap: {
                        value: null
                    },
                    displacementMapTransform: {
                        value: new Ns
                    },
                    displacementScale: {
                        value: 1
                    },
                    displacementBias: {
                        value: 0
                    }
                },
                emissivemap: {
                    emissiveMap: {
                        value: null
                    },
                    emissiveMapTransform: {
                        value: new Ns
                    }
                },
                metalnessmap: {
                    metalnessMap: {
                        value: null
                    },
                    metalnessMapTransform: {
                        value: new Ns
                    }
                },
                roughnessmap: {
                    roughnessMap: {
                        value: null
                    },
                    roughnessMapTransform: {
                        value: new Ns
                    }
                },
                gradientmap: {
                    gradientMap: {
                        value: null
                    }
                },
                fog: {
                    fogDensity: {
                        value: 25e-5
                    },
                    fogNear: {
                        value: 1
                    },
                    fogFar: {
                        value: 2e3
                    },
                    fogColor: {
                        value: new Cl(16777215)
                    }
                },
                lights: {
                    ambientLightColor: {
                        value: []
                    },
                    lightProbe: {
                        value: []
                    },
                    directionalLights: {
                        value: [],
                        properties: {
                            direction: {},
                            color: {}
                        }
                    },
                    directionalLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    directionalShadowMap: {
                        value: []
                    },
                    directionalShadowMatrix: {
                        value: []
                    },
                    spotLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            direction: {},
                            distance: {},
                            coneCos: {},
                            penumbraCos: {},
                            decay: {}
                        }
                    },
                    spotLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    spotLightMap: {
                        value: []
                    },
                    spotShadowMap: {
                        value: []
                    },
                    spotLightMatrix: {
                        value: []
                    },
                    pointLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            decay: {},
                            distance: {}
                        }
                    },
                    pointLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {},
                            shadowCameraNear: {},
                            shadowCameraFar: {}
                        }
                    },
                    pointShadowMap: {
                        value: []
                    },
                    pointShadowMatrix: {
                        value: []
                    },
                    hemisphereLights: {
                        value: [],
                        properties: {
                            direction: {},
                            skyColor: {},
                            groundColor: {}
                        }
                    },
                    rectAreaLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            width: {},
                            height: {}
                        }
                    },
                    ltc_1: {
                        value: null
                    },
                    ltc_2: {
                        value: null
                    }
                },
                points: {
                    diffuse: {
                        value: new Cl(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    size: {
                        value: 1
                    },
                    scale: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaMapTransform: {
                        value: new Ns
                    },
                    alphaTest: {
                        value: 0
                    },
                    uvTransform: {
                        value: new Ns
                    }
                },
                sprite: {
                    diffuse: {
                        value: new Cl(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    center: {
                        value: new Is(.5,.5)
                    },
                    rotation: {
                        value: 0
                    },
                    map: {
                        value: null
                    },
                    mapTransform: {
                        value: new Ns
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaMapTransform: {
                        value: new Ns
                    },
                    alphaTest: {
                        value: 0
                    }
                }
            }
              , zc = {
                basic: {
                    uniforms: fc([Fc.common, Fc.specularmap, Fc.envmap, Fc.aomap, Fc.lightmap, Fc.fog]),
                    vertexShader: kc.meshbasic_vert,
                    fragmentShader: kc.meshbasic_frag
                },
                lambert: {
                    uniforms: fc([Fc.common, Fc.specularmap, Fc.envmap, Fc.aomap, Fc.lightmap, Fc.emissivemap, Fc.bumpmap, Fc.normalmap, Fc.displacementmap, Fc.fog, Fc.lights, {
                        emissive: {
                            value: new Cl(0)
                        }
                    }]),
                    vertexShader: kc.meshlambert_vert,
                    fragmentShader: kc.meshlambert_frag
                },
                phong: {
                    uniforms: fc([Fc.common, Fc.specularmap, Fc.envmap, Fc.aomap, Fc.lightmap, Fc.emissivemap, Fc.bumpmap, Fc.normalmap, Fc.displacementmap, Fc.fog, Fc.lights, {
                        emissive: {
                            value: new Cl(0)
                        },
                        specular: {
                            value: new Cl(1118481)
                        },
                        shininess: {
                            value: 30
                        }
                    }]),
                    vertexShader: kc.meshphong_vert,
                    fragmentShader: kc.meshphong_frag
                },
                standard: {
                    uniforms: fc([Fc.common, Fc.envmap, Fc.aomap, Fc.lightmap, Fc.emissivemap, Fc.bumpmap, Fc.normalmap, Fc.displacementmap, Fc.roughnessmap, Fc.metalnessmap, Fc.fog, Fc.lights, {
                        emissive: {
                            value: new Cl(0)
                        },
                        roughness: {
                            value: 1
                        },
                        metalness: {
                            value: 0
                        },
                        envMapIntensity: {
                            value: 1
                        }
                    }]),
                    vertexShader: kc.meshphysical_vert,
                    fragmentShader: kc.meshphysical_frag
                },
                toon: {
                    uniforms: fc([Fc.common, Fc.aomap, Fc.lightmap, Fc.emissivemap, Fc.bumpmap, Fc.normalmap, Fc.displacementmap, Fc.gradientmap, Fc.fog, Fc.lights, {
                        emissive: {
                            value: new Cl(0)
                        }
                    }]),
                    vertexShader: kc.meshtoon_vert,
                    fragmentShader: kc.meshtoon_frag
                },
                matcap: {
                    uniforms: fc([Fc.common, Fc.bumpmap, Fc.normalmap, Fc.displacementmap, Fc.fog, {
                        matcap: {
                            value: null
                        }
                    }]),
                    vertexShader: kc.meshmatcap_vert,
                    fragmentShader: kc.meshmatcap_frag
                },
                points: {
                    uniforms: fc([Fc.points, Fc.fog]),
                    vertexShader: kc.points_vert,
                    fragmentShader: kc.points_frag
                },
                dashed: {
                    uniforms: fc([Fc.common, Fc.fog, {
                        scale: {
                            value: 1
                        },
                        dashSize: {
                            value: 1
                        },
                        totalSize: {
                            value: 2
                        }
                    }]),
                    vertexShader: kc.linedashed_vert,
                    fragmentShader: kc.linedashed_frag
                },
                depth: {
                    uniforms: fc([Fc.common, Fc.displacementmap]),
                    vertexShader: kc.depth_vert,
                    fragmentShader: kc.depth_frag
                },
                normal: {
                    uniforms: fc([Fc.common, Fc.bumpmap, Fc.normalmap, Fc.displacementmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: kc.meshnormal_vert,
                    fragmentShader: kc.meshnormal_frag
                },
                sprite: {
                    uniforms: fc([Fc.sprite, Fc.fog]),
                    vertexShader: kc.sprite_vert,
                    fragmentShader: kc.sprite_frag
                },
                background: {
                    uniforms: {
                        uvTransform: {
                            value: new Ns
                        },
                        t2D: {
                            value: null
                        },
                        backgroundIntensity: {
                            value: 1
                        }
                    },
                    vertexShader: kc.background_vert,
                    fragmentShader: kc.background_frag
                },
                backgroundCube: {
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        backgroundBlurriness: {
                            value: 0
                        },
                        backgroundIntensity: {
                            value: 1
                        },
                        backgroundRotation: {
                            value: new Ns
                        }
                    },
                    vertexShader: kc.backgroundCube_vert,
                    fragmentShader: kc.backgroundCube_frag
                },
                cube: {
                    uniforms: {
                        tCube: {
                            value: null
                        },
                        tFlip: {
                            value: -1
                        },
                        opacity: {
                            value: 1
                        }
                    },
                    vertexShader: kc.cube_vert,
                    fragmentShader: kc.cube_frag
                },
                equirect: {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: kc.equirect_vert,
                    fragmentShader: kc.equirect_frag
                },
                distanceRGBA: {
                    uniforms: fc([Fc.common, Fc.displacementmap, {
                        referencePosition: {
                            value: new lo
                        },
                        nearDistance: {
                            value: 1
                        },
                        farDistance: {
                            value: 1e3
                        }
                    }]),
                    vertexShader: kc.distanceRGBA_vert,
                    fragmentShader: kc.distanceRGBA_frag
                },
                shadow: {
                    uniforms: fc([Fc.lights, Fc.fog, {
                        color: {
                            value: new Cl(0)
                        },
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: kc.shadow_vert,
                    fragmentShader: kc.shadow_frag
                }
            };
            zc.physical = {
                uniforms: fc([zc.standard.uniforms, {
                    clearcoat: {
                        value: 0
                    },
                    clearcoatMap: {
                        value: null
                    },
                    clearcoatMapTransform: {
                        value: new Ns
                    },
                    clearcoatNormalMap: {
                        value: null
                    },
                    clearcoatNormalMapTransform: {
                        value: new Ns
                    },
                    clearcoatNormalScale: {
                        value: new Is(1,1)
                    },
                    clearcoatRoughness: {
                        value: 0
                    },
                    clearcoatRoughnessMap: {
                        value: null
                    },
                    clearcoatRoughnessMapTransform: {
                        value: new Ns
                    },
                    iridescence: {
                        value: 0
                    },
                    iridescenceMap: {
                        value: null
                    },
                    iridescenceMapTransform: {
                        value: new Ns
                    },
                    iridescenceIOR: {
                        value: 1.3
                    },
                    iridescenceThicknessMinimum: {
                        value: 100
                    },
                    iridescenceThicknessMaximum: {
                        value: 400
                    },
                    iridescenceThicknessMap: {
                        value: null
                    },
                    iridescenceThicknessMapTransform: {
                        value: new Ns
                    },
                    sheen: {
                        value: 0
                    },
                    sheenColor: {
                        value: new Cl(0)
                    },
                    sheenColorMap: {
                        value: null
                    },
                    sheenColorMapTransform: {
                        value: new Ns
                    },
                    sheenRoughness: {
                        value: 1
                    },
                    sheenRoughnessMap: {
                        value: null
                    },
                    sheenRoughnessMapTransform: {
                        value: new Ns
                    },
                    transmission: {
                        value: 0
                    },
                    transmissionMap: {
                        value: null
                    },
                    transmissionMapTransform: {
                        value: new Ns
                    },
                    transmissionSamplerSize: {
                        value: new Is
                    },
                    transmissionSamplerMap: {
                        value: null
                    },
                    thickness: {
                        value: 0
                    },
                    thicknessMap: {
                        value: null
                    },
                    thicknessMapTransform: {
                        value: new Ns
                    },
                    attenuationDistance: {
                        value: 0
                    },
                    attenuationColor: {
                        value: new Cl(0)
                    },
                    specularColor: {
                        value: new Cl(1,1,1)
                    },
                    specularColorMap: {
                        value: null
                    },
                    specularColorMapTransform: {
                        value: new Ns
                    },
                    specularIntensity: {
                        value: 1
                    },
                    specularIntensityMap: {
                        value: null
                    },
                    specularIntensityMapTransform: {
                        value: new Ns
                    },
                    anisotropyVector: {
                        value: new Is
                    },
                    anisotropyMap: {
                        value: null
                    },
                    anisotropyMapTransform: {
                        value: new Ns
                    }
                }]),
                vertexShader: kc.meshphysical_vert,
                fragmentShader: kc.meshphysical_frag
            };
            const Bc = {
                r: 0,
                b: 0,
                g: 0
            }
              , Hc = new $o
              , Gc = new zo;
            function Vc(e, t, n, r, i, a, s) {
                const o = new Cl(0);
                let l, c, u = !0 === a ? 0 : 1, d = null, h = 0, p = null;
                function f(t, n) {
                    t.getRGB(Bc, mc(e)),
                    r.buffers.color.setClear(Bc.r, Bc.g, Bc.b, n, s)
                }
                return {
                    getClearColor: function() {
                        return o
                    },
                    setClearColor: function(e, t=1) {
                        o.set(e),
                        u = t,
                        f(o, u)
                    },
                    getClearAlpha: function() {
                        return u
                    },
                    setClearAlpha: function(e) {
                        u = e,
                        f(o, u)
                    },
                    render: function(a, m) {
                        let g = !1
                          , v = !0 === m.isScene ? m.background : null;
                        if (v && v.isTexture) {
                            v = (m.backgroundBlurriness > 0 ? n : t).get(v)
                        }
                        null === v ? f(o, u) : v && v.isColor && (f(v, 1),
                        g = !0);
                        const _ = e.xr.getEnvironmentBlendMode();
                        "additive" === _ ? r.buffers.color.setClear(0, 0, 0, 1, s) : "alpha-blend" === _ && r.buffers.color.setClear(0, 0, 0, 0, s),
                        (e.autoClear || g) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
                        v && (v.isCubeTexture || v.mapping === Ra) ? (void 0 === c && (c = new uc(new hc(1,1,1),new vc({
                            name: "BackgroundCubeMaterial",
                            uniforms: pc(zc.backgroundCube.uniforms),
                            vertexShader: zc.backgroundCube.vertexShader,
                            fragmentShader: zc.backgroundCube.fragmentShader,
                            side: pa,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        })),
                        c.geometry.deleteAttribute("normal"),
                        c.geometry.deleteAttribute("uv"),
                        c.onBeforeRender = function(e, t, n) {
                            this.matrixWorld.copyPosition(n.matrixWorld)
                        }
                        ,
                        Object.defineProperty(c.material, "envMap", {
                            get: function() {
                                return this.uniforms.envMap.value
                            }
                        }),
                        i.update(c)),
                        Hc.copy(m.backgroundRotation),
                        Hc.x *= -1,
                        Hc.y *= -1,
                        Hc.z *= -1,
                        v.isCubeTexture && !1 === v.isRenderTargetTexture && (Hc.y *= -1,
                        Hc.z *= -1),
                        c.material.uniforms.envMap.value = v,
                        c.material.uniforms.flipEnvMap.value = v.isCubeTexture && !1 === v.isRenderTargetTexture ? -1 : 1,
                        c.material.uniforms.backgroundBlurriness.value = m.backgroundBlurriness,
                        c.material.uniforms.backgroundIntensity.value = m.backgroundIntensity,
                        c.material.uniforms.backgroundRotation.value.setFromMatrix4(Gc.makeRotationFromEuler(Hc)),
                        c.material.toneMapped = Xs.getTransfer(v.colorSpace) !== ps,
                        d === v && h === v.version && p === e.toneMapping || (c.material.needsUpdate = !0,
                        d = v,
                        h = v.version,
                        p = e.toneMapping),
                        c.layers.enableAll(),
                        a.unshift(c, c.geometry, c.material, 0, 0, null)) : v && v.isTexture && (void 0 === l && (l = new uc(new Uc(2,2),new vc({
                            name: "BackgroundMaterial",
                            uniforms: pc(zc.background.uniforms),
                            vertexShader: zc.background.vertexShader,
                            fragmentShader: zc.background.fragmentShader,
                            side: ha,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        })),
                        l.geometry.deleteAttribute("normal"),
                        Object.defineProperty(l.material, "map", {
                            get: function() {
                                return this.uniforms.t2D.value
                            }
                        }),
                        i.update(l)),
                        l.material.uniforms.t2D.value = v,
                        l.material.uniforms.backgroundIntensity.value = m.backgroundIntensity,
                        l.material.toneMapped = Xs.getTransfer(v.colorSpace) !== ps,
                        !0 === v.matrixAutoUpdate && v.updateMatrix(),
                        l.material.uniforms.uvTransform.value.copy(v.matrix),
                        d === v && h === v.version && p === e.toneMapping || (l.material.needsUpdate = !0,
                        d = v,
                        h = v.version,
                        p = e.toneMapping),
                        l.layers.enableAll(),
                        a.unshift(l, l.geometry, l.material, 0, 0, null))
                    }
                }
            }
            function Wc(e, t, n, r) {
                const i = e.getParameter(e.MAX_VERTEX_ATTRIBS)
                  , a = r.isWebGL2 ? null : t.get("OES_vertex_array_object")
                  , s = r.isWebGL2 || null !== a
                  , o = {}
                  , l = p(null);
                let c = l
                  , u = !1;
                function d(t) {
                    return r.isWebGL2 ? e.bindVertexArray(t) : a.bindVertexArrayOES(t)
                }
                function h(t) {
                    return r.isWebGL2 ? e.deleteVertexArray(t) : a.deleteVertexArrayOES(t)
                }
                function p(e) {
                    const t = []
                      , n = []
                      , r = [];
                    for (let e = 0; e < i; e++)
                        t[e] = 0,
                        n[e] = 0,
                        r[e] = 0;
                    return {
                        geometry: null,
                        program: null,
                        wireframe: !1,
                        newAttributes: t,
                        enabledAttributes: n,
                        attributeDivisors: r,
                        object: e,
                        attributes: {},
                        index: null
                    }
                }
                function f() {
                    const e = c.newAttributes;
                    for (let t = 0, n = e.length; t < n; t++)
                        e[t] = 0
                }
                function m(e) {
                    g(e, 0)
                }
                function g(n, i) {
                    const a = c.newAttributes
                      , s = c.enabledAttributes
                      , o = c.attributeDivisors;
                    if (a[n] = 1,
                    0 === s[n] && (e.enableVertexAttribArray(n),
                    s[n] = 1),
                    o[n] !== i) {
                        (r.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, i),
                        o[n] = i
                    }
                }
                function v() {
                    const t = c.newAttributes
                      , n = c.enabledAttributes;
                    for (let r = 0, i = n.length; r < i; r++)
                        n[r] !== t[r] && (e.disableVertexAttribArray(r),
                        n[r] = 0)
                }
                function _(t, n, r, i, a, s, o) {
                    !0 === o ? e.vertexAttribIPointer(t, n, r, a, s) : e.vertexAttribPointer(t, n, r, i, a, s)
                }
                function y() {
                    x(),
                    u = !0,
                    c !== l && (c = l,
                    d(c.object))
                }
                function x() {
                    l.geometry = null,
                    l.program = null,
                    l.wireframe = !1
                }
                return {
                    setup: function(i, l, h, y, x) {
                        let b = !1;
                        if (s) {
                            const t = function(t, n, i) {
                                const s = !0 === i.wireframe;
                                let l = o[t.id];
                                void 0 === l && (l = {},
                                o[t.id] = l);
                                let c = l[n.id];
                                void 0 === c && (c = {},
                                l[n.id] = c);
                                let u = c[s];
                                void 0 === u && (u = p(r.isWebGL2 ? e.createVertexArray() : a.createVertexArrayOES()),
                                c[s] = u);
                                return u
                            }(y, h, l);
                            c !== t && (c = t,
                            d(c.object)),
                            b = function(e, t, n, r) {
                                const i = c.attributes
                                  , a = t.attributes;
                                let s = 0;
                                const o = n.getAttributes();
                                for (const t in o) {
                                    if (o[t].location >= 0) {
                                        const n = i[t];
                                        let r = a[t];
                                        if (void 0 === r && ("instanceMatrix" === t && e.instanceMatrix && (r = e.instanceMatrix),
                                        "instanceColor" === t && e.instanceColor && (r = e.instanceColor)),
                                        void 0 === n)
                                            return !0;
                                        if (n.attribute !== r)
                                            return !0;
                                        if (r && n.data !== r.data)
                                            return !0;
                                        s++
                                    }
                                }
                                return c.attributesNum !== s || c.index !== r
                            }(i, y, h, x),
                            b && function(e, t, n, r) {
                                const i = {}
                                  , a = t.attributes;
                                let s = 0;
                                const o = n.getAttributes();
                                for (const t in o) {
                                    if (o[t].location >= 0) {
                                        let n = a[t];
                                        void 0 === n && ("instanceMatrix" === t && e.instanceMatrix && (n = e.instanceMatrix),
                                        "instanceColor" === t && e.instanceColor && (n = e.instanceColor));
                                        const r = {};
                                        r.attribute = n,
                                        n && n.data && (r.data = n.data),
                                        i[t] = r,
                                        s++
                                    }
                                }
                                c.attributes = i,
                                c.attributesNum = s,
                                c.index = r
                            }(i, y, h, x)
                        } else {
                            const e = !0 === l.wireframe;
                            c.geometry === y.id && c.program === h.id && c.wireframe === e || (c.geometry = y.id,
                            c.program = h.id,
                            c.wireframe = e,
                            b = !0)
                        }
                        null !== x && n.update(x, e.ELEMENT_ARRAY_BUFFER),
                        (b || u) && (u = !1,
                        function(i, a, s, o) {
                            if (!1 === r.isWebGL2 && (i.isInstancedMesh || o.isInstancedBufferGeometry) && null === t.get("ANGLE_instanced_arrays"))
                                return;
                            f();
                            const l = o.attributes
                              , c = s.getAttributes()
                              , u = a.defaultAttributeValues;
                            for (const t in c) {
                                const a = c[t];
                                if (a.location >= 0) {
                                    let s = l[t];
                                    if (void 0 === s && ("instanceMatrix" === t && i.instanceMatrix && (s = i.instanceMatrix),
                                    "instanceColor" === t && i.instanceColor && (s = i.instanceColor)),
                                    void 0 !== s) {
                                        const t = s.normalized
                                          , l = s.itemSize
                                          , c = n.get(s);
                                        if (void 0 === c)
                                            continue;
                                        const u = c.buffer
                                          , d = c.type
                                          , h = c.bytesPerElement
                                          , p = !0 === r.isWebGL2 && (d === e.INT || d === e.UNSIGNED_INT || s.gpuType === Ga);
                                        if (s.isInterleavedBufferAttribute) {
                                            const n = s.data
                                              , r = n.stride
                                              , c = s.offset;
                                            if (n.isInstancedInterleavedBuffer) {
                                                for (let e = 0; e < a.locationSize; e++)
                                                    g(a.location + e, n.meshPerAttribute);
                                                !0 !== i.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = n.meshPerAttribute * n.count)
                                            } else
                                                for (let e = 0; e < a.locationSize; e++)
                                                    m(a.location + e);
                                            e.bindBuffer(e.ARRAY_BUFFER, u);
                                            for (let e = 0; e < a.locationSize; e++)
                                                _(a.location + e, l / a.locationSize, d, t, r * h, (c + l / a.locationSize * e) * h, p)
                                        } else {
                                            if (s.isInstancedBufferAttribute) {
                                                for (let e = 0; e < a.locationSize; e++)
                                                    g(a.location + e, s.meshPerAttribute);
                                                !0 !== i.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = s.meshPerAttribute * s.count)
                                            } else
                                                for (let e = 0; e < a.locationSize; e++)
                                                    m(a.location + e);
                                            e.bindBuffer(e.ARRAY_BUFFER, u);
                                            for (let e = 0; e < a.locationSize; e++)
                                                _(a.location + e, l / a.locationSize, d, t, l * h, l / a.locationSize * e * h, p)
                                        }
                                    } else if (void 0 !== u) {
                                        const n = u[t];
                                        if (void 0 !== n)
                                            switch (n.length) {
                                            case 2:
                                                e.vertexAttrib2fv(a.location, n);
                                                break;
                                            case 3:
                                                e.vertexAttrib3fv(a.location, n);
                                                break;
                                            case 4:
                                                e.vertexAttrib4fv(a.location, n);
                                                break;
                                            default:
                                                e.vertexAttrib1fv(a.location, n)
                                            }
                                    }
                                }
                            }
                            v()
                        }(i, l, h, y),
                        null !== x && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, n.get(x).buffer))
                    },
                    reset: y,
                    resetDefaultState: x,
                    dispose: function() {
                        y();
                        for (const e in o) {
                            const t = o[e];
                            for (const e in t) {
                                const n = t[e];
                                for (const e in n)
                                    h(n[e].object),
                                    delete n[e];
                                delete t[e]
                            }
                            delete o[e]
                        }
                    },
                    releaseStatesOfGeometry: function(e) {
                        if (void 0 === o[e.id])
                            return;
                        const t = o[e.id];
                        for (const e in t) {
                            const n = t[e];
                            for (const e in n)
                                h(n[e].object),
                                delete n[e];
                            delete t[e]
                        }
                        delete o[e.id]
                    },
                    releaseStatesOfProgram: function(e) {
                        for (const t in o) {
                            const n = o[t];
                            if (void 0 === n[e.id])
                                continue;
                            const r = n[e.id];
                            for (const e in r)
                                h(r[e].object),
                                delete r[e];
                            delete n[e.id]
                        }
                    },
                    initAttributes: f,
                    enableAttribute: m,
                    disableUnusedAttributes: v
                }
            }
            function jc(e, t, n, r) {
                const i = r.isWebGL2;
                let a;
                this.setMode = function(e) {
                    a = e
                }
                ,
                this.render = function(t, r) {
                    e.drawArrays(a, t, r),
                    n.update(r, a, 1)
                }
                ,
                this.renderInstances = function(r, s, o) {
                    if (0 === o)
                        return;
                    let l, c;
                    if (i)
                        l = e,
                        c = "drawArraysInstanced";
                    else if (l = t.get("ANGLE_instanced_arrays"),
                    c = "drawArraysInstancedANGLE",
                    null === l)
                        return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    l[c](a, r, s, o),
                    n.update(s, a, o)
                }
                ,
                this.renderMultiDraw = function(e, r, i) {
                    if (0 === i)
                        return;
                    const s = t.get("WEBGL_multi_draw");
                    if (null === s)
                        for (let t = 0; t < i; t++)
                            this.render(e[t], r[t]);
                    else {
                        s.multiDrawArraysWEBGL(a, e, 0, r, 0, i);
                        let t = 0;
                        for (let e = 0; e < i; e++)
                            t += r[e];
                        n.update(t, a, 1)
                    }
                }
            }
            function Xc(e, t, n) {
                let r;
                function i(t) {
                    if ("highp" === t) {
                        if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0)
                            return "highp";
                        t = "mediump"
                    }
                    return "mediump" === t && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
                }
                const a = "undefined" != typeof WebGL2RenderingContext && "WebGL2RenderingContext" === e.constructor.name;
                let s = void 0 !== n.precision ? n.precision : "highp";
                const o = i(s);
                o !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", o, "instead."),
                s = o);
                const l = a || t.has("WEBGL_draw_buffers")
                  , c = !0 === n.logarithmicDepthBuffer
                  , u = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)
                  , d = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
                  , h = e.getParameter(e.MAX_TEXTURE_SIZE)
                  , p = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE)
                  , f = e.getParameter(e.MAX_VERTEX_ATTRIBS)
                  , m = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS)
                  , g = e.getParameter(e.MAX_VARYING_VECTORS)
                  , v = e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS)
                  , _ = d > 0
                  , y = a || t.has("OES_texture_float");
                return {
                    isWebGL2: a,
                    drawBuffers: l,
                    getMaxAnisotropy: function() {
                        if (void 0 !== r)
                            return r;
                        if (!0 === t.has("EXT_texture_filter_anisotropic")) {
                            const n = t.get("EXT_texture_filter_anisotropic");
                            r = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                        } else
                            r = 0;
                        return r
                    },
                    getMaxPrecision: i,
                    precision: s,
                    logarithmicDepthBuffer: c,
                    maxTextures: u,
                    maxVertexTextures: d,
                    maxTextureSize: h,
                    maxCubemapSize: p,
                    maxAttributes: f,
                    maxVertexUniforms: m,
                    maxVaryings: g,
                    maxFragmentUniforms: v,
                    vertexTextures: _,
                    floatFragmentTextures: y,
                    floatVertexTextures: _ && y,
                    maxSamples: a ? e.getParameter(e.MAX_SAMPLES) : 0
                }
            }
            function qc(e) {
                const t = this;
                let n = null
                  , r = 0
                  , i = !1
                  , a = !1;
                const s = new Rc
                  , o = new Ns
                  , l = {
                    value: null,
                    needsUpdate: !1
                };
                function c(e, n, r, i) {
                    const a = null !== e ? e.length : 0;
                    let c = null;
                    if (0 !== a) {
                        if (c = l.value,
                        !0 !== i || null === c) {
                            const t = r + 4 * a
                              , i = n.matrixWorldInverse;
                            o.getNormalMatrix(i),
                            (null === c || c.length < t) && (c = new Float32Array(t));
                            for (let t = 0, n = r; t !== a; ++t,
                            n += 4)
                                s.copy(e[t]).applyMatrix4(i, o),
                                s.normal.toArray(c, n),
                                c[n + 3] = s.constant
                        }
                        l.value = c,
                        l.needsUpdate = !0
                    }
                    return t.numPlanes = a,
                    t.numIntersection = 0,
                    c
                }
                this.uniform = l,
                this.numPlanes = 0,
                this.numIntersection = 0,
                this.init = function(e, t) {
                    const n = 0 !== e.length || t || 0 !== r || i;
                    return i = t,
                    r = e.length,
                    n
                }
                ,
                this.beginShadows = function() {
                    a = !0,
                    c(null)
                }
                ,
                this.endShadows = function() {
                    a = !1
                }
                ,
                this.setGlobalState = function(e, t) {
                    n = c(e, t, 0)
                }
                ,
                this.setState = function(s, o, u) {
                    const d = s.clippingPlanes
                      , h = s.clipIntersection
                      , p = s.clipShadows
                      , f = e.get(s);
                    if (!i || null === d || 0 === d.length || a && !p)
                        a ? c(null) : function() {
                            l.value !== n && (l.value = n,
                            l.needsUpdate = r > 0);
                            t.numPlanes = r,
                            t.numIntersection = 0
                        }();
                    else {
                        const e = a ? 0 : r
                          , t = 4 * e;
                        let i = f.clippingState || null;
                        l.value = i,
                        i = c(d, o, t, u);
                        for (let e = 0; e !== t; ++e)
                            i[e] = n[e];
                        f.clippingState = i,
                        this.numIntersection = h ? this.numPlanes : 0,
                        this.numPlanes += e
                    }
                }
            }
            function Yc(e) {
                let t = new WeakMap;
                function n(e, t) {
                    return t === Ca ? e.mapping = Ta : t === Pa && (e.mapping = Aa),
                    e
                }
                function r(e) {
                    const n = e.target;
                    n.removeEventListener("dispose", r);
                    const i = t.get(n);
                    void 0 !== i && (t.delete(n),
                    i.dispose())
                }
                return {
                    get: function(i) {
                        if (i && i.isTexture) {
                            const a = i.mapping;
                            if (a === Ca || a === Pa) {
                                if (t.has(i)) {
                                    return n(t.get(i).texture, i.mapping)
                                }
                                {
                                    const a = i.image;
                                    if (a && a.height > 0) {
                                        const s = new Tc(a.height);
                                        return s.fromEquirectangularTexture(e, i),
                                        t.set(i, s),
                                        i.addEventListener("dispose", r),
                                        n(s.texture, i.mapping)
                                    }
                                    return null
                                }
                            }
                        }
                        return i
                    },
                    dispose: function() {
                        t = new WeakMap
                    }
                }
            }
            class $c extends _c {
                constructor(e=-1, t=1, n=1, r=-1, i=.1, a=2e3) {
                    super(),
                    this.isOrthographicCamera = !0,
                    this.type = "OrthographicCamera",
                    this.zoom = 1,
                    this.view = null,
                    this.left = e,
                    this.right = t,
                    this.top = n,
                    this.bottom = r,
                    this.near = i,
                    this.far = a,
                    this.updateProjectionMatrix()
                }
                copy(e, t) {
                    return super.copy(e, t),
                    this.left = e.left,
                    this.right = e.right,
                    this.top = e.top,
                    this.bottom = e.bottom,
                    this.near = e.near,
                    this.far = e.far,
                    this.zoom = e.zoom,
                    this.view = null === e.view ? null : Object.assign({}, e.view),
                    this
                }
                setViewOffset(e, t, n, r, i, a) {
                    null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }),
                    this.view.enabled = !0,
                    this.view.fullWidth = e,
                    this.view.fullHeight = t,
                    this.view.offsetX = n,
                    this.view.offsetY = r,
                    this.view.width = i,
                    this.view.height = a,
                    this.updateProjectionMatrix()
                }
                clearViewOffset() {
                    null !== this.view && (this.view.enabled = !1),
                    this.updateProjectionMatrix()
                }
                updateProjectionMatrix() {
                    const e = (this.right - this.left) / (2 * this.zoom)
                      , t = (this.top - this.bottom) / (2 * this.zoom)
                      , n = (this.right + this.left) / 2
                      , r = (this.top + this.bottom) / 2;
                    let i = n - e
                      , a = n + e
                      , s = r + t
                      , o = r - t;
                    if (null !== this.view && this.view.enabled) {
                        const e = (this.right - this.left) / this.view.fullWidth / this.zoom
                          , t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                        i += e * this.view.offsetX,
                        a = i + e * this.view.width,
                        s -= t * this.view.offsetY,
                        o = s - t * this.view.height
                    }
                    this.projectionMatrix.makeOrthographic(i, a, s, o, this.near, this.far, this.coordinateSystem),
                    this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return t.object.zoom = this.zoom,
                    t.object.left = this.left,
                    t.object.right = this.right,
                    t.object.top = this.top,
                    t.object.bottom = this.bottom,
                    t.object.near = this.near,
                    t.object.far = this.far,
                    null !== this.view && (t.object.view = Object.assign({}, this.view)),
                    t
                }
            }
            const Kc = [.125, .215, .35, .446, .526, .582]
              , Zc = 20
              , Jc = new $c
              , Qc = new Cl;
            let eu = null
              , tu = 0
              , nu = 0;
            const ru = (1 + Math.sqrt(5)) / 2
              , iu = 1 / ru
              , au = [new lo(1,1,1), new lo(-1,1,1), new lo(1,1,-1), new lo(-1,1,-1), new lo(0,ru,iu), new lo(0,ru,-iu), new lo(iu,0,ru), new lo(-iu,0,ru), new lo(ru,iu,0), new lo(-ru,iu,0)];
            class su {
                constructor(e) {
                    this._renderer = e,
                    this._pingPongRenderTarget = null,
                    this._lodMax = 0,
                    this._cubeSize = 0,
                    this._lodPlanes = [],
                    this._sizeLods = [],
                    this._sigmas = [],
                    this._blurMaterial = null,
                    this._cubemapMaterial = null,
                    this._equirectMaterial = null,
                    this._compileMaterial(this._blurMaterial)
                }
                fromScene(e, t=0, n=.1, r=100) {
                    eu = this._renderer.getRenderTarget(),
                    tu = this._renderer.getActiveCubeFace(),
                    nu = this._renderer.getActiveMipmapLevel(),
                    this._setSize(256);
                    const i = this._allocateTargets();
                    return i.depthBuffer = !0,
                    this._sceneToCubeUV(e, n, r, i),
                    t > 0 && this._blur(i, 0, 0, t),
                    this._applyPMREM(i),
                    this._cleanup(i),
                    i
                }
                fromEquirectangular(e, t=null) {
                    return this._fromTexture(e, t)
                }
                fromCubemap(e, t=null) {
                    return this._fromTexture(e, t)
                }
                compileCubemapShader() {
                    null === this._cubemapMaterial && (this._cubemapMaterial = uu(),
                    this._compileMaterial(this._cubemapMaterial))
                }
                compileEquirectangularShader() {
                    null === this._equirectMaterial && (this._equirectMaterial = cu(),
                    this._compileMaterial(this._equirectMaterial))
                }
                dispose() {
                    this._dispose(),
                    null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
                    null !== this._equirectMaterial && this._equirectMaterial.dispose()
                }
                _setSize(e) {
                    this._lodMax = Math.floor(Math.log2(e)),
                    this._cubeSize = Math.pow(2, this._lodMax)
                }
                _dispose() {
                    null !== this._blurMaterial && this._blurMaterial.dispose(),
                    null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
                    for (let e = 0; e < this._lodPlanes.length; e++)
                        this._lodPlanes[e].dispose()
                }
                _cleanup(e) {
                    this._renderer.setRenderTarget(eu, tu, nu),
                    e.scissorTest = !1,
                    lu(e, 0, 0, e.width, e.height)
                }
                _fromTexture(e, t) {
                    e.mapping === Ta || e.mapping === Aa ? this._setSize(0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
                    eu = this._renderer.getRenderTarget(),
                    tu = this._renderer.getActiveCubeFace(),
                    nu = this._renderer.getActiveMipmapLevel();
                    const n = t || this._allocateTargets();
                    return this._textureToCubeUV(e, n),
                    this._applyPMREM(n),
                    this._cleanup(n),
                    n
                }
                _allocateTargets() {
                    const e = 3 * Math.max(this._cubeSize, 112)
                      , t = 4 * this._cubeSize
                      , n = {
                        magFilter: ka,
                        minFilter: ka,
                        generateMipmaps: !1,
                        type: ja,
                        format: qa,
                        colorSpace: cs,
                        depthBuffer: !1
                    }
                      , r = ou(e, t, n);
                    if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
                        null !== this._pingPongRenderTarget && this._dispose(),
                        this._pingPongRenderTarget = ou(e, t, n);
                        const {_lodMax: r} = this;
                        ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = function(e) {
                            const t = []
                              , n = []
                              , r = [];
                            let i = e;
                            const a = e - 4 + 1 + Kc.length;
                            for (let s = 0; s < a; s++) {
                                const a = Math.pow(2, i);
                                n.push(a);
                                let o = 1 / a;
                                s > e - 4 ? o = Kc[s - e + 4 - 1] : 0 === s && (o = 0),
                                r.push(o);
                                const l = 1 / (a - 2)
                                  , c = -l
                                  , u = 1 + l
                                  , d = [c, c, u, c, u, u, c, c, u, u, c, u]
                                  , h = 6
                                  , p = 6
                                  , f = 3
                                  , m = 2
                                  , g = 1
                                  , v = new Float32Array(f * p * h)
                                  , _ = new Float32Array(m * p * h)
                                  , y = new Float32Array(g * p * h);
                                for (let e = 0; e < h; e++) {
                                    const t = e % 3 * 2 / 3 - 1
                                      , n = e > 2 ? 0 : -1
                                      , r = [t, n, 0, t + 2 / 3, n, 0, t + 2 / 3, n + 1, 0, t, n, 0, t + 2 / 3, n + 1, 0, t, n + 1, 0];
                                    v.set(r, f * p * e),
                                    _.set(d, m * p * e);
                                    const i = [e, e, e, e, e, e];
                                    y.set(i, g * p * e)
                                }
                                const x = new Xl;
                                x.setAttribute("position", new Nl(v,f)),
                                x.setAttribute("uv", new Nl(_,m)),
                                x.setAttribute("faceIndex", new Nl(y,g)),
                                t.push(x),
                                i > 4 && i--
                            }
                            return {
                                lodPlanes: t,
                                sizeLods: n,
                                sigmas: r
                            }
                        }(r)),
                        this._blurMaterial = function(e, t, n) {
                            const r = new Float32Array(Zc)
                              , i = new lo(0,1,0)
                              , a = new vc({
                                name: "SphericalGaussianBlur",
                                defines: {
                                    n: Zc,
                                    CUBEUV_TEXEL_WIDTH: 1 / t,
                                    CUBEUV_TEXEL_HEIGHT: 1 / n,
                                    CUBEUV_MAX_MIP: `${e}.0`
                                },
                                uniforms: {
                                    envMap: {
                                        value: null
                                    },
                                    samples: {
                                        value: 1
                                    },
                                    weights: {
                                        value: r
                                    },
                                    latitudinal: {
                                        value: !1
                                    },
                                    dTheta: {
                                        value: 0
                                    },
                                    mipInt: {
                                        value: 0
                                    },
                                    poleAxis: {
                                        value: i
                                    }
                                },
                                vertexShader: du(),
                                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                                blending: 0,
                                depthTest: !1,
                                depthWrite: !1
                            });
                            return a
                        }(r, e, t)
                    }
                    return r
                }
                _compileMaterial(e) {
                    const t = new uc(this._lodPlanes[0],e);
                    this._renderer.compile(t, Jc)
                }
                _sceneToCubeUV(e, t, n, r) {
                    const i = new Ec(90,1,t,n)
                      , a = [1, -1, 1, 1, 1, 1]
                      , s = [1, 1, 1, -1, -1, -1]
                      , o = this._renderer
                      , l = o.autoClear
                      , c = o.toneMapping;
                    o.getClearColor(Qc),
                    o.toneMapping = _a,
                    o.autoClear = !1;
                    const u = new Ol({
                        name: "PMREM.Background",
                        side: pa,
                        depthWrite: !1,
                        depthTest: !1
                    })
                      , d = new uc(new hc,u);
                    let h = !1;
                    const p = e.background;
                    p ? p.isColor && (u.color.copy(p),
                    e.background = null,
                    h = !0) : (u.color.copy(Qc),
                    h = !0);
                    for (let t = 0; t < 6; t++) {
                        const n = t % 3;
                        0 === n ? (i.up.set(0, a[t], 0),
                        i.lookAt(s[t], 0, 0)) : 1 === n ? (i.up.set(0, 0, a[t]),
                        i.lookAt(0, s[t], 0)) : (i.up.set(0, a[t], 0),
                        i.lookAt(0, 0, s[t]));
                        const l = this._cubeSize;
                        lu(r, n * l, t > 2 ? l : 0, l, l),
                        o.setRenderTarget(r),
                        h && o.render(d, i),
                        o.render(e, i)
                    }
                    d.geometry.dispose(),
                    d.material.dispose(),
                    o.toneMapping = c,
                    o.autoClear = l,
                    e.background = p
                }
                _textureToCubeUV(e, t) {
                    const n = this._renderer
                      , r = e.mapping === Ta || e.mapping === Aa;
                    r ? (null === this._cubemapMaterial && (this._cubemapMaterial = uu()),
                    this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = cu());
                    const i = r ? this._cubemapMaterial : this._equirectMaterial
                      , a = new uc(this._lodPlanes[0],i);
                    i.uniforms.envMap.value = e;
                    const s = this._cubeSize;
                    lu(t, 0, 0, 3 * s, 2 * s),
                    n.setRenderTarget(t),
                    n.render(a, Jc)
                }
                _applyPMREM(e) {
                    const t = this._renderer
                      , n = t.autoClear;
                    t.autoClear = !1;
                    for (let t = 1; t < this._lodPlanes.length; t++) {
                        const n = Math.sqrt(this._sigmas[t] * this._sigmas[t] - this._sigmas[t - 1] * this._sigmas[t - 1])
                          , r = au[(t - 1) % au.length];
                        this._blur(e, t - 1, t, n, r)
                    }
                    t.autoClear = n
                }
                _blur(e, t, n, r, i) {
                    const a = this._pingPongRenderTarget;
                    this._halfBlur(e, a, t, n, r, "latitudinal", i),
                    this._halfBlur(a, e, n, n, r, "longitudinal", i)
                }
                _halfBlur(e, t, n, r, i, a, s) {
                    const o = this._renderer
                      , l = this._blurMaterial;
                    "latitudinal" !== a && "longitudinal" !== a && console.error("blur direction must be either latitudinal or longitudinal!");
                    const c = new uc(this._lodPlanes[r],l)
                      , u = l.uniforms
                      , d = this._sizeLods[n] - 1
                      , h = isFinite(i) ? Math.PI / (2 * d) : 2 * Math.PI / 39
                      , p = i / h
                      , f = isFinite(i) ? 1 + Math.floor(3 * p) : Zc;
                    f > Zc && console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
                    const m = [];
                    let g = 0;
                    for (let e = 0; e < Zc; ++e) {
                        const t = e / p
                          , n = Math.exp(-t * t / 2);
                        m.push(n),
                        0 === e ? g += n : e < f && (g += 2 * n)
                    }
                    for (let e = 0; e < m.length; e++)
                        m[e] = m[e] / g;
                    u.envMap.value = e.texture,
                    u.samples.value = f,
                    u.weights.value = m,
                    u.latitudinal.value = "latitudinal" === a,
                    s && (u.poleAxis.value = s);
                    const {_lodMax: v} = this;
                    u.dTheta.value = h,
                    u.mipInt.value = v - n;
                    const _ = this._sizeLods[r];
                    lu(t, 3 * _ * (r > v - 4 ? r - v + 4 : 0), 4 * (this._cubeSize - _), 3 * _, 2 * _),
                    o.setRenderTarget(t),
                    o.render(c, Jc)
                }
            }
            function ou(e, t, n) {
                const r = new io(e,t,n);
                return r.texture.mapping = Ra,
                r.texture.name = "PMREM.cubeUv",
                r.scissorTest = !0,
                r
            }
            function lu(e, t, n, r, i) {
                e.viewport.set(t, n, r, i),
                e.scissor.set(t, n, r, i)
            }
            function cu() {
                return new vc({
                    name: "EquirectangularToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        }
                    },
                    vertexShader: du(),
                    fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1
                })
            }
            function uu() {
                return new vc({
                    name: "CubemapToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        }
                    },
                    vertexShader: du(),
                    fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1
                })
            }
            function du() {
                return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
            }
            function hu(e) {
                let t = new WeakMap
                  , n = null;
                function r(e) {
                    const n = e.target;
                    n.removeEventListener("dispose", r);
                    const i = t.get(n);
                    void 0 !== i && (t.delete(n),
                    i.dispose())
                }
                return {
                    get: function(i) {
                        if (i && i.isTexture) {
                            const a = i.mapping
                              , s = a === Ca || a === Pa
                              , o = a === Ta || a === Aa;
                            if (s || o) {
                                if (i.isRenderTargetTexture && !0 === i.needsPMREMUpdate) {
                                    i.needsPMREMUpdate = !1;
                                    let r = t.get(i);
                                    return null === n && (n = new su(e)),
                                    r = s ? n.fromEquirectangular(i, r) : n.fromCubemap(i, r),
                                    t.set(i, r),
                                    r.texture
                                }
                                if (t.has(i))
                                    return t.get(i).texture;
                                {
                                    const a = i.image;
                                    if (s && a && a.height > 0 || o && a && function(e) {
                                        let t = 0;
                                        const n = 6;
                                        for (let r = 0; r < n; r++)
                                            void 0 !== e[r] && t++;
                                        return t === n
                                    }(a)) {
                                        null === n && (n = new su(e));
                                        const a = s ? n.fromEquirectangular(i) : n.fromCubemap(i);
                                        return t.set(i, a),
                                        i.addEventListener("dispose", r),
                                        a.texture
                                    }
                                    return null
                                }
                            }
                        }
                        return i
                    },
                    dispose: function() {
                        t = new WeakMap,
                        null !== n && (n.dispose(),
                        n = null)
                    }
                }
            }
            function pu(e) {
                const t = {};
                function n(n) {
                    if (void 0 !== t[n])
                        return t[n];
                    let r;
                    switch (n) {
                    case "WEBGL_depth_texture":
                        r = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case "EXT_texture_filter_anisotropic":
                        r = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        r = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        r = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default:
                        r = e.getExtension(n)
                    }
                    return t[n] = r,
                    r
                }
                return {
                    has: function(e) {
                        return null !== n(e)
                    },
                    init: function(e) {
                        e.isWebGL2 ? (n("EXT_color_buffer_float"),
                        n("WEBGL_clip_cull_distance")) : (n("WEBGL_depth_texture"),
                        n("OES_texture_float"),
                        n("OES_texture_half_float"),
                        n("OES_texture_half_float_linear"),
                        n("OES_standard_derivatives"),
                        n("OES_element_index_uint"),
                        n("OES_vertex_array_object"),
                        n("ANGLE_instanced_arrays")),
                        n("OES_texture_float_linear"),
                        n("EXT_color_buffer_half_float"),
                        n("WEBGL_multisampled_render_to_texture")
                    },
                    get: function(e) {
                        const t = n(e);
                        return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."),
                        t
                    }
                }
            }
            function fu(e, t, n, r) {
                const i = {}
                  , a = new WeakMap;
                function s(e) {
                    const o = e.target;
                    null !== o.index && t.remove(o.index);
                    for (const e in o.attributes)
                        t.remove(o.attributes[e]);
                    for (const e in o.morphAttributes) {
                        const n = o.morphAttributes[e];
                        for (let e = 0, r = n.length; e < r; e++)
                            t.remove(n[e])
                    }
                    o.removeEventListener("dispose", s),
                    delete i[o.id];
                    const l = a.get(o);
                    l && (t.remove(l),
                    a.delete(o)),
                    r.releaseStatesOfGeometry(o),
                    !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
                    n.memory.geometries--
                }
                function o(e) {
                    const n = []
                      , r = e.index
                      , i = e.attributes.position;
                    let s = 0;
                    if (null !== r) {
                        const e = r.array;
                        s = r.version;
                        for (let t = 0, r = e.length; t < r; t += 3) {
                            const r = e[t + 0]
                              , i = e[t + 1]
                              , a = e[t + 2];
                            n.push(r, i, i, a, a, r)
                        }
                    } else {
                        if (void 0 === i)
                            return;
                        {
                            const e = i.array;
                            s = i.version;
                            for (let t = 0, r = e.length / 3 - 1; t < r; t += 3) {
                                const e = t + 0
                                  , r = t + 1
                                  , i = t + 2;
                                n.push(e, r, r, i, i, e)
                            }
                        }
                    }
                    const o = new (ks(n) ? kl : Ul)(n,1);
                    o.version = s;
                    const l = a.get(e);
                    l && t.remove(l),
                    a.set(e, o)
                }
                return {
                    get: function(e, t) {
                        return !0 === i[t.id] || (t.addEventListener("dispose", s),
                        i[t.id] = !0,
                        n.memory.geometries++),
                        t
                    },
                    update: function(n) {
                        const r = n.attributes;
                        for (const n in r)
                            t.update(r[n], e.ARRAY_BUFFER);
                        const i = n.morphAttributes;
                        for (const n in i) {
                            const r = i[n];
                            for (let n = 0, i = r.length; n < i; n++)
                                t.update(r[n], e.ARRAY_BUFFER)
                        }
                    },
                    getWireframeAttribute: function(e) {
                        const t = a.get(e);
                        if (t) {
                            const n = e.index;
                            null !== n && t.version < n.version && o(e)
                        } else
                            o(e);
                        return a.get(e)
                    }
                }
            }
            function mu(e, t, n, r) {
                const i = r.isWebGL2;
                let a, s, o;
                this.setMode = function(e) {
                    a = e
                }
                ,
                this.setIndex = function(e) {
                    s = e.type,
                    o = e.bytesPerElement
                }
                ,
                this.render = function(t, r) {
                    e.drawElements(a, r, s, t * o),
                    n.update(r, a, 1)
                }
                ,
                this.renderInstances = function(r, l, c) {
                    if (0 === c)
                        return;
                    let u, d;
                    if (i)
                        u = e,
                        d = "drawElementsInstanced";
                    else if (u = t.get("ANGLE_instanced_arrays"),
                    d = "drawElementsInstancedANGLE",
                    null === u)
                        return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    u[d](a, l, s, r * o, c),
                    n.update(l, a, c)
                }
                ,
                this.renderMultiDraw = function(e, r, i) {
                    if (0 === i)
                        return;
                    const l = t.get("WEBGL_multi_draw");
                    if (null === l)
                        for (let t = 0; t < i; t++)
                            this.render(e[t] / o, r[t]);
                    else {
                        l.multiDrawElementsWEBGL(a, r, 0, s, e, 0, i);
                        let t = 0;
                        for (let e = 0; e < i; e++)
                            t += r[e];
                        n.update(t, a, 1)
                    }
                }
            }
            function gu(e) {
                const t = {
                    frame: 0,
                    calls: 0,
                    triangles: 0,
                    points: 0,
                    lines: 0
                };
                return {
                    memory: {
                        geometries: 0,
                        textures: 0
                    },
                    render: t,
                    programs: null,
                    autoReset: !0,
                    reset: function() {
                        t.calls = 0,
                        t.triangles = 0,
                        t.points = 0,
                        t.lines = 0
                    },
                    update: function(n, r, i) {
                        switch (t.calls++,
                        r) {
                        case e.TRIANGLES:
                            t.triangles += i * (n / 3);
                            break;
                        case e.LINES:
                            t.lines += i * (n / 2);
                            break;
                        case e.LINE_STRIP:
                            t.lines += i * (n - 1);
                            break;
                        case e.LINE_LOOP:
                            t.lines += i * n;
                            break;
                        case e.POINTS:
                            t.points += i * n;
                            break;
                        default:
                            console.error("THREE.WebGLInfo: Unknown draw mode:", r)
                        }
                    }
                }
            }
            function vu(e, t) {
                return e[0] - t[0]
            }
            function _u(e, t) {
                return Math.abs(t[1]) - Math.abs(e[1])
            }
            function yu(e, t, n) {
                const r = {}
                  , i = new Float32Array(8)
                  , a = new WeakMap
                  , s = new no
                  , o = [];
                for (let e = 0; e < 8; e++)
                    o[e] = [e, 0];
                return {
                    update: function(l, c, u) {
                        const d = l.morphTargetInfluences;
                        if (!0 === t.isWebGL2) {
                            const h = c.morphAttributes.position || c.morphAttributes.normal || c.morphAttributes.color
                              , p = void 0 !== h ? h.length : 0;
                            let f = a.get(c);
                            if (void 0 === f || f.count !== p) {
                                void 0 !== f && f.texture.dispose();
                                const m = void 0 !== c.morphAttributes.position
                                  , g = void 0 !== c.morphAttributes.normal
                                  , v = void 0 !== c.morphAttributes.color
                                  , _ = c.morphAttributes.position || []
                                  , y = c.morphAttributes.normal || []
                                  , x = c.morphAttributes.color || [];
                                let b = 0;
                                !0 === m && (b = 1),
                                !0 === g && (b = 2),
                                !0 === v && (b = 3);
                                let E = c.attributes.position.count * b
                                  , S = 1;
                                E > t.maxTextureSize && (S = Math.ceil(E / t.maxTextureSize),
                                E = t.maxTextureSize);
                                const w = new Float32Array(E * S * 4 * p)
                                  , M = new ao(w,E,S,p);
                                M.type = Wa,
                                M.needsUpdate = !0;
                                const T = 4 * b;
                                for (let C = 0; C < p; C++) {
                                    const P = _[C]
                                      , R = y[C]
                                      , L = x[C]
                                      , O = E * S * 4 * C;
                                    for (let D = 0; D < P.count; D++) {
                                        const I = D * T;
                                        !0 === m && (s.fromBufferAttribute(P, D),
                                        w[O + I + 0] = s.x,
                                        w[O + I + 1] = s.y,
                                        w[O + I + 2] = s.z,
                                        w[O + I + 3] = 0),
                                        !0 === g && (s.fromBufferAttribute(R, D),
                                        w[O + I + 4] = s.x,
                                        w[O + I + 5] = s.y,
                                        w[O + I + 6] = s.z,
                                        w[O + I + 7] = 0),
                                        !0 === v && (s.fromBufferAttribute(L, D),
                                        w[O + I + 8] = s.x,
                                        w[O + I + 9] = s.y,
                                        w[O + I + 10] = s.z,
                                        w[O + I + 11] = 4 === L.itemSize ? s.w : 1)
                                    }
                                }
                                function A() {
                                    M.dispose(),
                                    a.delete(c),
                                    c.removeEventListener("dispose", A)
                                }
                                f = {
                                    count: p,
                                    texture: M,
                                    size: new Is(E,S)
                                },
                                a.set(c, f),
                                c.addEventListener("dispose", A)
                            }
                            if (!0 === l.isInstancedMesh && null !== l.morphTexture)
                                u.getUniforms().setValue(e, "morphTexture", l.morphTexture, n);
                            else {
                                let N = 0;
                                for (let k = 0; k < d.length; k++)
                                    N += d[k];
                                const U = c.morphTargetsRelative ? 1 : 1 - N;
                                u.getUniforms().setValue(e, "morphTargetBaseInfluence", U),
                                u.getUniforms().setValue(e, "morphTargetInfluences", d)
                            }
                            u.getUniforms().setValue(e, "morphTargetsTexture", f.texture, n),
                            u.getUniforms().setValue(e, "morphTargetsTextureSize", f.size)
                        } else {
                            const F = void 0 === d ? 0 : d.length;
                            let z = r[c.id];
                            if (void 0 === z || z.length !== F) {
                                z = [];
                                for (let W = 0; W < F; W++)
                                    z[W] = [W, 0];
                                r[c.id] = z
                            }
                            for (let j = 0; j < F; j++) {
                                const X = z[j];
                                X[0] = j,
                                X[1] = d[j]
                            }
                            z.sort(_u);
                            for (let q = 0; q < 8; q++)
                                q < F && z[q][1] ? (o[q][0] = z[q][0],
                                o[q][1] = z[q][1]) : (o[q][0] = Number.MAX_SAFE_INTEGER,
                                o[q][1] = 0);
                            o.sort(vu);
                            const B = c.morphAttributes.position
                              , H = c.morphAttributes.normal;
                            let G = 0;
                            for (let Y = 0; Y < 8; Y++) {
                                const $ = o[Y]
                                  , K = $[0]
                                  , Z = $[1];
                                K !== Number.MAX_SAFE_INTEGER && Z ? (B && c.getAttribute("morphTarget" + Y) !== B[K] && c.setAttribute("morphTarget" + Y, B[K]),
                                H && c.getAttribute("morphNormal" + Y) !== H[K] && c.setAttribute("morphNormal" + Y, H[K]),
                                i[Y] = Z,
                                G += Z) : (B && !0 === c.hasAttribute("morphTarget" + Y) && c.deleteAttribute("morphTarget" + Y),
                                H && !0 === c.hasAttribute("morphNormal" + Y) && c.deleteAttribute("morphNormal" + Y),
                                i[Y] = 0)
                            }
                            const V = c.morphTargetsRelative ? 1 : 1 - G;
                            u.getUniforms().setValue(e, "morphTargetBaseInfluence", V),
                            u.getUniforms().setValue(e, "morphTargetInfluences", i)
                        }
                    }
                }
            }
            function xu(e, t, n, r) {
                let i = new WeakMap;
                function a(e) {
                    const t = e.target;
                    t.removeEventListener("dispose", a),
                    n.remove(t.instanceMatrix),
                    null !== t.instanceColor && n.remove(t.instanceColor)
                }
                return {
                    update: function(s) {
                        const o = r.render.frame
                          , l = s.geometry
                          , c = t.get(s, l);
                        if (i.get(c) !== o && (t.update(c),
                        i.set(c, o)),
                        s.isInstancedMesh && (!1 === s.hasEventListener("dispose", a) && s.addEventListener("dispose", a),
                        i.get(s) !== o && (n.update(s.instanceMatrix, e.ARRAY_BUFFER),
                        null !== s.instanceColor && n.update(s.instanceColor, e.ARRAY_BUFFER),
                        i.set(s, o))),
                        s.isSkinnedMesh) {
                            const e = s.skeleton;
                            i.get(e) !== o && (e.update(),
                            i.set(e, o))
                        }
                        return c
                    },
                    dispose: function() {
                        i = new WeakMap
                    }
                }
            }
            class bu extends to {
                constructor(e, t, n, r, i, a, s, o, l, c) {
                    if ((c = void 0 !== c ? c : Ya) !== Ya && c !== $a)
                        throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                    void 0 === n && c === Ya && (n = Va),
                    void 0 === n && c === $a && (n = Xa),
                    super(null, r, i, a, s, o, c, n, l),
                    this.isDepthTexture = !0,
                    this.image = {
                        width: e,
                        height: t
                    },
                    this.magFilter = void 0 !== s ? s : Ia,
                    this.minFilter = void 0 !== o ? o : Ia,
                    this.flipY = !1,
                    this.generateMipmaps = !1,
                    this.compareFunction = null
                }
                copy(e) {
                    return super.copy(e),
                    this.compareFunction = e.compareFunction,
                    this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return null !== this.compareFunction && (t.compareFunction = this.compareFunction),
                    t
                }
            }
            const Eu = new to
              , Su = new bu(1,1);
            Su.compareFunction = 515;
            const wu = new ao
              , Mu = new so
              , Tu = new Mc
              , Au = []
              , Cu = []
              , Pu = new Float32Array(16)
              , Ru = new Float32Array(9)
              , Lu = new Float32Array(4);
            function Ou(e, t, n) {
                const r = e[0];
                if (r <= 0 || r > 0)
                    return e;
                const i = t * n;
                let a = Au[i];
                if (void 0 === a && (a = new Float32Array(i),
                Au[i] = a),
                0 !== t) {
                    r.toArray(a, 0);
                    for (let r = 1, i = 0; r !== t; ++r)
                        i += n,
                        e[r].toArray(a, i)
                }
                return a
            }
            function Du(e, t) {
                if (e.length !== t.length)
                    return !1;
                for (let n = 0, r = e.length; n < r; n++)
                    if (e[n] !== t[n])
                        return !1;
                return !0
            }
            function Iu(e, t) {
                for (let n = 0, r = t.length; n < r; n++)
                    e[n] = t[n]
            }
            function Nu(e, t) {
                let n = Cu[t];
                void 0 === n && (n = new Int32Array(t),
                Cu[t] = n);
                for (let r = 0; r !== t; ++r)
                    n[r] = e.allocateTextureUnit();
                return n
            }
            function Uu(e, t) {
                const n = this.cache;
                n[0] !== t && (e.uniform1f(this.addr, t),
                n[0] = t)
            }
            function ku(e, t) {
                const n = this.cache;
                if (void 0 !== t.x)
                    n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y),
                    n[0] = t.x,
                    n[1] = t.y);
                else {
                    if (Du(n, t))
                        return;
                    e.uniform2fv(this.addr, t),
                    Iu(n, t)
                }
            }
            function Fu(e, t) {
                const n = this.cache;
                if (void 0 !== t.x)
                    n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z),
                    n[0] = t.x,
                    n[1] = t.y,
                    n[2] = t.z);
                else if (void 0 !== t.r)
                    n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b),
                    n[0] = t.r,
                    n[1] = t.g,
                    n[2] = t.b);
                else {
                    if (Du(n, t))
                        return;
                    e.uniform3fv(this.addr, t),
                    Iu(n, t)
                }
            }
            function zu(e, t) {
                const n = this.cache;
                if (void 0 !== t.x)
                    n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
                    n[0] = t.x,
                    n[1] = t.y,
                    n[2] = t.z,
                    n[3] = t.w);
                else {
                    if (Du(n, t))
                        return;
                    e.uniform4fv(this.addr, t),
                    Iu(n, t)
                }
            }
            function Bu(e, t) {
                const n = this.cache
                  , r = t.elements;
                if (void 0 === r) {
                    if (Du(n, t))
                        return;
                    e.uniformMatrix2fv(this.addr, !1, t),
                    Iu(n, t)
                } else {
                    if (Du(n, r))
                        return;
                    Lu.set(r),
                    e.uniformMatrix2fv(this.addr, !1, Lu),
                    Iu(n, r)
                }
            }
            function Hu(e, t) {
                const n = this.cache
                  , r = t.elements;
                if (void 0 === r) {
                    if (Du(n, t))
                        return;
                    e.uniformMatrix3fv(this.addr, !1, t),
                    Iu(n, t)
                } else {
                    if (Du(n, r))
                        return;
                    Ru.set(r),
                    e.uniformMatrix3fv(this.addr, !1, Ru),
                    Iu(n, r)
                }
            }
            function Gu(e, t) {
                const n = this.cache
                  , r = t.elements;
                if (void 0 === r) {
                    if (Du(n, t))
                        return;
                    e.uniformMatrix4fv(this.addr, !1, t),
                    Iu(n, t)
                } else {
                    if (Du(n, r))
                        return;
                    Pu.set(r),
                    e.uniformMatrix4fv(this.addr, !1, Pu),
                    Iu(n, r)
                }
            }
            function Vu(e, t) {
                const n = this.cache;
                n[0] !== t && (e.uniform1i(this.addr, t),
                n[0] = t)
            }
            function Wu(e, t) {
                const n = this.cache;
                if (void 0 !== t.x)
                    n[0] === t.x && n[1] === t.y || (e.uniform2i(this.addr, t.x, t.y),
                    n[0] = t.x,
                    n[1] = t.y);
                else {
                    if (Du(n, t))
                        return;
                    e.uniform2iv(this.addr, t),
                    Iu(n, t)
                }
            }
            function ju(e, t) {
                const n = this.cache;
                if (void 0 !== t.x)
                    n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3i(this.addr, t.x, t.y, t.z),
                    n[0] = t.x,
                    n[1] = t.y,
                    n[2] = t.z);
                else {
                    if (Du(n, t))
                        return;
                    e.uniform3iv(this.addr, t),
                    Iu(n, t)
                }
            }
            function Xu(e, t) {
                const n = this.cache;
                if (void 0 !== t.x)
                    n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4i(this.addr, t.x, t.y, t.z, t.w),
                    n[0] = t.x,
                    n[1] = t.y,
                    n[2] = t.z,
                    n[3] = t.w);
                else {
                    if (Du(n, t))
                        return;
                    e.uniform4iv(this.addr, t),
                    Iu(n, t)
                }
            }
            function qu(e, t) {
                const n = this.cache;
                n[0] !== t && (e.uniform1ui(this.addr, t),
                n[0] = t)
            }
            function Yu(e, t) {
                const n = this.cache;
                if (void 0 !== t.x)
                    n[0] === t.x && n[1] === t.y || (e.uniform2ui(this.addr, t.x, t.y),
                    n[0] = t.x,
                    n[1] = t.y);
                else {
                    if (Du(n, t))
                        return;
                    e.uniform2uiv(this.addr, t),
                    Iu(n, t)
                }
            }
            function $u(e, t) {
                const n = this.cache;
                if (void 0 !== t.x)
                    n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3ui(this.addr, t.x, t.y, t.z),
                    n[0] = t.x,
                    n[1] = t.y,
                    n[2] = t.z);
                else {
                    if (Du(n, t))
                        return;
                    e.uniform3uiv(this.addr, t),
                    Iu(n, t)
                }
            }
            function Ku(e, t) {
                const n = this.cache;
                if (void 0 !== t.x)
                    n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w),
                    n[0] = t.x,
                    n[1] = t.y,
                    n[2] = t.z,
                    n[3] = t.w);
                else {
                    if (Du(n, t))
                        return;
                    e.uniform4uiv(this.addr, t),
                    Iu(n, t)
                }
            }
            function Zu(e, t, n) {
                const r = this.cache
                  , i = n.allocateTextureUnit();
                r[0] !== i && (e.uniform1i(this.addr, i),
                r[0] = i);
                const a = this.type === e.SAMPLER_2D_SHADOW ? Su : Eu;
                n.setTexture2D(t || a, i)
            }
            function Ju(e, t, n) {
                const r = this.cache
                  , i = n.allocateTextureUnit();
                r[0] !== i && (e.uniform1i(this.addr, i),
                r[0] = i),
                n.setTexture3D(t || Mu, i)
            }
            function Qu(e, t, n) {
                const r = this.cache
                  , i = n.allocateTextureUnit();
                r[0] !== i && (e.uniform1i(this.addr, i),
                r[0] = i),
                n.setTextureCube(t || Tu, i)
            }
            function ed(e, t, n) {
                const r = this.cache
                  , i = n.allocateTextureUnit();
                r[0] !== i && (e.uniform1i(this.addr, i),
                r[0] = i),
                n.setTexture2DArray(t || wu, i)
            }
            function td(e, t) {
                e.uniform1fv(this.addr, t)
            }
            function nd(e, t) {
                const n = Ou(t, this.size, 2);
                e.uniform2fv(this.addr, n)
            }
            function rd(e, t) {
                const n = Ou(t, this.size, 3);
                e.uniform3fv(this.addr, n)
            }
            function id(e, t) {
                const n = Ou(t, this.size, 4);
                e.uniform4fv(this.addr, n)
            }
            function ad(e, t) {
                const n = Ou(t, this.size, 4);
                e.uniformMatrix2fv(this.addr, !1, n)
            }
            function sd(e, t) {
                const n = Ou(t, this.size, 9);
                e.uniformMatrix3fv(this.addr, !1, n)
            }
            function od(e, t) {
                const n = Ou(t, this.size, 16);
                e.uniformMatrix4fv(this.addr, !1, n)
            }
            function ld(e, t) {
                e.uniform1iv(this.addr, t)
            }
            function cd(e, t) {
                e.uniform2iv(this.addr, t)
            }
            function ud(e, t) {
                e.uniform3iv(this.addr, t)
            }
            function dd(e, t) {
                e.uniform4iv(this.addr, t)
            }
            function hd(e, t) {
                e.uniform1uiv(this.addr, t)
            }
            function pd(e, t) {
                e.uniform2uiv(this.addr, t)
            }
            function fd(e, t) {
                e.uniform3uiv(this.addr, t)
            }
            function md(e, t) {
                e.uniform4uiv(this.addr, t)
            }
            function gd(e, t, n) {
                const r = this.cache
                  , i = t.length
                  , a = Nu(n, i);
                Du(r, a) || (e.uniform1iv(this.addr, a),
                Iu(r, a));
                for (let e = 0; e !== i; ++e)
                    n.setTexture2D(t[e] || Eu, a[e])
            }
            function vd(e, t, n) {
                const r = this.cache
                  , i = t.length
                  , a = Nu(n, i);
                Du(r, a) || (e.uniform1iv(this.addr, a),
                Iu(r, a));
                for (let e = 0; e !== i; ++e)
                    n.setTexture3D(t[e] || Mu, a[e])
            }
            function _d(e, t, n) {
                const r = this.cache
                  , i = t.length
                  , a = Nu(n, i);
                Du(r, a) || (e.uniform1iv(this.addr, a),
                Iu(r, a));
                for (let e = 0; e !== i; ++e)
                    n.setTextureCube(t[e] || Tu, a[e])
            }
            function yd(e, t, n) {
                const r = this.cache
                  , i = t.length
                  , a = Nu(n, i);
                Du(r, a) || (e.uniform1iv(this.addr, a),
                Iu(r, a));
                for (let e = 0; e !== i; ++e)
                    n.setTexture2DArray(t[e] || wu, a[e])
            }
            class xd {
                constructor(e, t, n) {
                    this.id = e,
                    this.addr = n,
                    this.cache = [],
                    this.type = t.type,
                    this.setValue = function(e) {
                        switch (e) {
                        case 5126:
                            return Uu;
                        case 35664:
                            return ku;
                        case 35665:
                            return Fu;
                        case 35666:
                            return zu;
                        case 35674:
                            return Bu;
                        case 35675:
                            return Hu;
                        case 35676:
                            return Gu;
                        case 5124:
                        case 35670:
                            return Vu;
                        case 35667:
                        case 35671:
                            return Wu;
                        case 35668:
                        case 35672:
                            return ju;
                        case 35669:
                        case 35673:
                            return Xu;
                        case 5125:
                            return qu;
                        case 36294:
                            return Yu;
                        case 36295:
                            return $u;
                        case 36296:
                            return Ku;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return Zu;
                        case 35679:
                        case 36299:
                        case 36307:
                            return Ju;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return Qu;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return ed
                        }
                    }(t.type)
                }
            }
            class bd {
                constructor(e, t, n) {
                    this.id = e,
                    this.addr = n,
                    this.cache = [],
                    this.type = t.type,
                    this.size = t.size,
                    this.setValue = function(e) {
                        switch (e) {
                        case 5126:
                            return td;
                        case 35664:
                            return nd;
                        case 35665:
                            return rd;
                        case 35666:
                            return id;
                        case 35674:
                            return ad;
                        case 35675:
                            return sd;
                        case 35676:
                            return od;
                        case 5124:
                        case 35670:
                            return ld;
                        case 35667:
                        case 35671:
                            return cd;
                        case 35668:
                        case 35672:
                            return ud;
                        case 35669:
                        case 35673:
                            return dd;
                        case 5125:
                            return hd;
                        case 36294:
                            return pd;
                        case 36295:
                            return fd;
                        case 36296:
                            return md;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return gd;
                        case 35679:
                        case 36299:
                        case 36307:
                            return vd;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return _d;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return yd
                        }
                    }(t.type)
                }
            }
            class Ed {
                constructor(e) {
                    this.id = e,
                    this.seq = [],
                    this.map = {}
                }
                setValue(e, t, n) {
                    const r = this.seq;
                    for (let i = 0, a = r.length; i !== a; ++i) {
                        const a = r[i];
                        a.setValue(e, t[a.id], n)
                    }
                }
            }
            const Sd = /(\w+)(\])?(\[|\.)?/g;
            function wd(e, t) {
                e.seq.push(t),
                e.map[t.id] = t
            }
            function Md(e, t, n) {
                const r = e.name
                  , i = r.length;
                for (Sd.lastIndex = 0; ; ) {
                    const a = Sd.exec(r)
                      , s = Sd.lastIndex;
                    let o = a[1];
                    const l = "]" === a[2]
                      , c = a[3];
                    if (l && (o |= 0),
                    void 0 === c || "[" === c && s + 2 === i) {
                        wd(n, void 0 === c ? new xd(o,e,t) : new bd(o,e,t));
                        break
                    }
                    {
                        let e = n.map[o];
                        void 0 === e && (e = new Ed(o),
                        wd(n, e)),
                        n = e
                    }
                }
            }
            class Td {
                constructor(e, t) {
                    this.seq = [],
                    this.map = {};
                    const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
                    for (let r = 0; r < n; ++r) {
                        const n = e.getActiveUniform(t, r);
                        Md(n, e.getUniformLocation(t, n.name), this)
                    }
                }
                setValue(e, t, n, r) {
                    const i = this.map[t];
                    void 0 !== i && i.setValue(e, n, r)
                }
                setOptional(e, t, n) {
                    const r = t[n];
                    void 0 !== r && this.setValue(e, n, r)
                }
                static upload(e, t, n, r) {
                    for (let i = 0, a = t.length; i !== a; ++i) {
                        const a = t[i]
                          , s = n[a.id];
                        !1 !== s.needsUpdate && a.setValue(e, s.value, r)
                    }
                }
                static seqWithValue(e, t) {
                    const n = [];
                    for (let r = 0, i = e.length; r !== i; ++r) {
                        const i = e[r];
                        i.id in t && n.push(i)
                    }
                    return n
                }
            }
            function Ad(e, t, n) {
                const r = e.createShader(t);
                return e.shaderSource(r, n),
                e.compileShader(r),
                r
            }
            const Cd = 37297;
            let Pd = 0;
            function Rd(e, t, n) {
                const r = e.getShaderParameter(t, e.COMPILE_STATUS)
                  , i = e.getShaderInfoLog(t).trim();
                if (r && "" === i)
                    return "";
                const a = /ERROR: 0:(\d+)/.exec(i);
                if (a) {
                    const r = parseInt(a[1]);
                    return n.toUpperCase() + "\n\n" + i + "\n\n" + function(e, t) {
                        const n = e.split("\n")
                          , r = []
                          , i = Math.max(t - 6, 0)
                          , a = Math.min(t + 6, n.length);
                        for (let e = i; e < a; e++) {
                            const i = e + 1;
                            r.push(`${i === t ? ">" : " "} ${i}: ${n[e]}`)
                        }
                        return r.join("\n")
                    }(e.getShaderSource(t), r)
                }
                return i
            }
            function Ld(e, t) {
                const n = function(e) {
                    const t = Xs.getPrimaries(Xs.workingColorSpace)
                      , n = Xs.getPrimaries(e);
                    let r;
                    switch (t === n ? r = "" : t === ms && n === fs ? r = "LinearDisplayP3ToLinearSRGB" : t === fs && n === ms && (r = "LinearSRGBToLinearDisplayP3"),
                    e) {
                    case cs:
                    case ds:
                        return [r, "LinearTransferOETF"];
                    case ls:
                    case us:
                        return [r, "sRGBTransferOETF"];
                    default:
                        return console.warn("THREE.WebGLProgram: Unsupported color space:", e),
                        [r, "LinearTransferOETF"]
                    }
                }(t);
                return `vec4 ${e}( vec4 value ) { return ${n[0]}( ${n[1]}( value ) ); }`
            }
            function Od(e, t) {
                let n;
                switch (t) {
                case ya:
                    n = "Linear";
                    break;
                case xa:
                    n = "Reinhard";
                    break;
                case ba:
                    n = "OptimizedCineon";
                    break;
                case Ea:
                    n = "ACESFilmic";
                    break;
                case wa:
                    n = "AgX";
                    break;
                case Ma:
                    n = "Neutral";
                    break;
                case Sa:
                    n = "Custom";
                    break;
                default:
                    console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
                    n = "Linear"
                }
                return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
            }
            function Dd(e) {
                return "" !== e
            }
            function Id(e, t) {
                const n = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
                return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
            }
            function Nd(e, t) {
                return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
            }
            const Ud = /^[ \t]*#include +<([\w\d./]+)>/gm;
            function kd(e) {
                return e.replace(Ud, zd)
            }
            const Fd = new Map([["encodings_fragment", "colorspace_fragment"], ["encodings_pars_fragment", "colorspace_pars_fragment"], ["output_fragment", "opaque_fragment"]]);
            function zd(e, t) {
                let n = kc[t];
                if (void 0 === n) {
                    const e = Fd.get(t);
                    if (void 0 === e)
                        throw new Error("Can not resolve #include <" + t + ">");
                    n = kc[e],
                    console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', t, e)
                }
                return kd(n)
            }
            const Bd = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
            function Hd(e) {
                return e.replace(Bd, Gd)
            }
            function Gd(e, t, n, r) {
                let i = "";
                for (let e = parseInt(t); e < parseInt(n); e++)
                    i += r.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e);
                return i
            }
            function Vd(e) {
                let t = `precision ${e.precision} float;\n\tprecision ${e.precision} int;\n\tprecision ${e.precision} sampler2D;\n\tprecision ${e.precision} samplerCube;\n\t`;
                return e.isWebGL2 && (t += `precision ${e.precision} sampler3D;\n\t\tprecision ${e.precision} sampler2DArray;\n\t\tprecision ${e.precision} sampler2DShadow;\n\t\tprecision ${e.precision} samplerCubeShadow;\n\t\tprecision ${e.precision} sampler2DArrayShadow;\n\t\tprecision ${e.precision} isampler2D;\n\t\tprecision ${e.precision} isampler3D;\n\t\tprecision ${e.precision} isamplerCube;\n\t\tprecision ${e.precision} isampler2DArray;\n\t\tprecision ${e.precision} usampler2D;\n\t\tprecision ${e.precision} usampler3D;\n\t\tprecision ${e.precision} usamplerCube;\n\t\tprecision ${e.precision} usampler2DArray;\n\t\t`),
                "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"),
                t
            }
            function Wd(e, t, n, r) {
                const i = e.getContext()
                  , a = n.defines;
                let s = n.vertexShader
                  , o = n.fragmentShader;
                const l = function(e) {
                    let t = "SHADOWMAP_TYPE_BASIC";
                    return e.shadowMapType === ca ? t = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === ua ? t = "SHADOWMAP_TYPE_PCF_SOFT" : e.shadowMapType === da && (t = "SHADOWMAP_TYPE_VSM"),
                    t
                }(n)
                  , c = function(e) {
                    let t = "ENVMAP_TYPE_CUBE";
                    if (e.envMap)
                        switch (e.envMapMode) {
                        case Ta:
                        case Aa:
                            t = "ENVMAP_TYPE_CUBE";
                            break;
                        case Ra:
                            t = "ENVMAP_TYPE_CUBE_UV"
                        }
                    return t
                }(n)
                  , u = function(e) {
                    let t = "ENVMAP_MODE_REFLECTION";
                    e.envMap && e.envMapMode === Aa && (t = "ENVMAP_MODE_REFRACTION");
                    return t
                }(n)
                  , d = function(e) {
                    let t = "ENVMAP_BLENDING_NONE";
                    if (e.envMap)
                        switch (e.combine) {
                        case ma:
                            t = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case ga:
                            t = "ENVMAP_BLENDING_MIX";
                            break;
                        case va:
                            t = "ENVMAP_BLENDING_ADD"
                        }
                    return t
                }(n)
                  , h = function(e) {
                    const t = e.envMapCubeUVHeight;
                    if (null === t)
                        return null;
                    const n = Math.log2(t) - 2
                      , r = 1 / t;
                    return {
                        texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                        texelHeight: r,
                        maxMip: n
                    }
                }(n)
                  , p = n.isWebGL2 ? "" : function(e) {
                    return [e.extensionDerivatives || e.envMapCubeUVHeight || e.bumpMap || e.normalMapTangentSpace || e.clearcoatNormalMap || e.flatShading || e.alphaToCoverage || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap || e.transmission) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Dd).join("\n")
                }(n)
                  , f = function(e) {
                    return [e.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", e.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(Dd).join("\n")
                }(n)
                  , m = function(e) {
                    const t = [];
                    for (const n in e) {
                        const r = e[n];
                        !1 !== r && t.push("#define " + n + " " + r)
                    }
                    return t.join("\n")
                }(a)
                  , g = i.createProgram();
                let v, _, y = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
                n.isRawShaderMaterial ? (v = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m].filter(Dd).join("\n"),
                v.length > 0 && (v += "\n"),
                _ = [p, "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m].filter(Dd).join("\n"),
                _.length > 0 && (_ += "\n")) : (v = [Vd(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m, n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", n.batching ? "#define USE_BATCHING" : "", n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "\tuniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "\tattribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "\tattribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "\tattribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Dd).join("\n"),
                _ = [p, Vd(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + d : "", h ? "#define CUBEUV_TEXEL_WIDTH " + h.texelWidth : "", h ? "#define CUBEUV_TEXEL_HEIGHT " + h.texelHeight : "", h ? "#define CUBEUV_MAX_MIP " + h.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== _a ? "#define TONE_MAPPING" : "", n.toneMapping !== _a ? kc.tonemapping_pars_fragment : "", n.toneMapping !== _a ? Od("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", kc.colorspace_pars_fragment, Ld("linearToOutputTexel", n.outputColorSpace), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Dd).join("\n")),
                s = kd(s),
                s = Id(s, n),
                s = Nd(s, n),
                o = kd(o),
                o = Id(o, n),
                o = Nd(o, n),
                s = Hd(s),
                o = Hd(o),
                n.isWebGL2 && !0 !== n.isRawShaderMaterial && (y = "#version 300 es\n",
                v = [f, "precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + v,
                _ = ["precision mediump sampler2DArray;", "#define varying in", n.glslVersion === _s ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === _s ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + _);
                const x = y + v + s
                  , b = y + _ + o
                  , E = Ad(i, i.VERTEX_SHADER, x)
                  , S = Ad(i, i.FRAGMENT_SHADER, b);
                function w(t) {
                    if (e.debug.checkShaderErrors) {
                        const n = i.getProgramInfoLog(g).trim()
                          , r = i.getShaderInfoLog(E).trim()
                          , a = i.getShaderInfoLog(S).trim();
                        let s = !0
                          , o = !0;
                        if (!1 === i.getProgramParameter(g, i.LINK_STATUS))
                            if (s = !1,
                            "function" == typeof e.debug.onShaderError)
                                e.debug.onShaderError(i, g, E, S);
                            else {
                                const e = Rd(i, E, "vertex")
                                  , r = Rd(i, S, "fragment");
                                console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(g, i.VALIDATE_STATUS) + "\n\nMaterial Name: " + t.name + "\nMaterial Type: " + t.type + "\n\nProgram Info Log: " + n + "\n" + e + "\n" + r)
                            }
                        else
                            "" !== n ? console.warn("THREE.WebGLProgram: Program Info Log:", n) : "" !== r && "" !== a || (o = !1);
                        o && (t.diagnostics = {
                            runnable: s,
                            programLog: n,
                            vertexShader: {
                                log: r,
                                prefix: v
                            },
                            fragmentShader: {
                                log: a,
                                prefix: _
                            }
                        })
                    }
                    i.deleteShader(E),
                    i.deleteShader(S),
                    M = new Td(i,g),
                    T = function(e, t) {
                        const n = {}
                          , r = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
                        for (let i = 0; i < r; i++) {
                            const r = e.getActiveAttrib(t, i)
                              , a = r.name;
                            let s = 1;
                            r.type === e.FLOAT_MAT2 && (s = 2),
                            r.type === e.FLOAT_MAT3 && (s = 3),
                            r.type === e.FLOAT_MAT4 && (s = 4),
                            n[a] = {
                                type: r.type,
                                location: e.getAttribLocation(t, a),
                                locationSize: s
                            }
                        }
                        return n
                    }(i, g)
                }
                let M, T;
                i.attachShader(g, E),
                i.attachShader(g, S),
                void 0 !== n.index0AttributeName ? i.bindAttribLocation(g, 0, n.index0AttributeName) : !0 === n.morphTargets && i.bindAttribLocation(g, 0, "position"),
                i.linkProgram(g),
                this.getUniforms = function() {
                    return void 0 === M && w(this),
                    M
                }
                ,
                this.getAttributes = function() {
                    return void 0 === T && w(this),
                    T
                }
                ;
                let A = !1 === n.rendererExtensionParallelShaderCompile;
                return this.isReady = function() {
                    return !1 === A && (A = i.getProgramParameter(g, Cd)),
                    A
                }
                ,
                this.destroy = function() {
                    r.releaseStatesOfProgram(this),
                    i.deleteProgram(g),
                    this.program = void 0
                }
                ,
                this.type = n.shaderType,
                this.name = n.shaderName,
                this.id = Pd++,
                this.cacheKey = t,
                this.usedTimes = 1,
                this.program = g,
                this.vertexShader = E,
                this.fragmentShader = S,
                this
            }
            let jd = 0;
            class Xd {
                constructor() {
                    this.shaderCache = new Map,
                    this.materialCache = new Map
                }
                update(e) {
                    const t = e.vertexShader
                      , n = e.fragmentShader
                      , r = this._getShaderStage(t)
                      , i = this._getShaderStage(n)
                      , a = this._getShaderCacheForMaterial(e);
                    return !1 === a.has(r) && (a.add(r),
                    r.usedTimes++),
                    !1 === a.has(i) && (a.add(i),
                    i.usedTimes++),
                    this
                }
                remove(e) {
                    const t = this.materialCache.get(e);
                    for (const e of t)
                        e.usedTimes--,
                        0 === e.usedTimes && this.shaderCache.delete(e.code);
                    return this.materialCache.delete(e),
                    this
                }
                getVertexShaderID(e) {
                    return this._getShaderStage(e.vertexShader).id
                }
                getFragmentShaderID(e) {
                    return this._getShaderStage(e.fragmentShader).id
                }
                dispose() {
                    this.shaderCache.clear(),
                    this.materialCache.clear()
                }
                _getShaderCacheForMaterial(e) {
                    const t = this.materialCache;
                    let n = t.get(e);
                    return void 0 === n && (n = new Set,
                    t.set(e, n)),
                    n
                }
                _getShaderStage(e) {
                    const t = this.shaderCache;
                    let n = t.get(e);
                    return void 0 === n && (n = new qd(e),
                    t.set(e, n)),
                    n
                }
            }
            class qd {
                constructor(e) {
                    this.id = jd++,
                    this.code = e,
                    this.usedTimes = 0
                }
            }
            function Yd(e, t, n, r, i, a, s) {
                const o = new Ko
                  , l = new Xd
                  , c = new Set
                  , u = []
                  , d = i.isWebGL2
                  , h = i.logarithmicDepthBuffer
                  , p = i.vertexTextures;
                let f = i.precision;
                const m = {
                    MeshDepthMaterial: "depth",
                    MeshDistanceMaterial: "distanceRGBA",
                    MeshNormalMaterial: "normal",
                    MeshBasicMaterial: "basic",
                    MeshLambertMaterial: "lambert",
                    MeshPhongMaterial: "phong",
                    MeshToonMaterial: "toon",
                    MeshStandardMaterial: "physical",
                    MeshPhysicalMaterial: "physical",
                    MeshMatcapMaterial: "matcap",
                    LineBasicMaterial: "basic",
                    LineDashedMaterial: "dashed",
                    PointsMaterial: "points",
                    ShadowMaterial: "shadow",
                    SpriteMaterial: "sprite"
                };
                function g(e) {
                    return c.add(e),
                    0 === e ? "uv" : `uv${e}`
                }
                return {
                    getParameters: function(a, o, u, v, _) {
                        const y = v.fog
                          , x = _.geometry
                          , b = a.isMeshStandardMaterial ? v.environment : null
                          , E = (a.isMeshStandardMaterial ? n : t).get(a.envMap || b)
                          , S = E && E.mapping === Ra ? E.image.height : null
                          , w = m[a.type];
                        null !== a.precision && (f = i.getMaxPrecision(a.precision),
                        f !== a.precision && console.warn("THREE.WebGLProgram.getParameters:", a.precision, "not supported, using", f, "instead."));
                        const M = x.morphAttributes.position || x.morphAttributes.normal || x.morphAttributes.color
                          , T = void 0 !== M ? M.length : 0;
                        let A, C, P, R, L = 0;
                        if (void 0 !== x.morphAttributes.position && (L = 1),
                        void 0 !== x.morphAttributes.normal && (L = 2),
                        void 0 !== x.morphAttributes.color && (L = 3),
                        w) {
                            const e = zc[w];
                            A = e.vertexShader,
                            C = e.fragmentShader
                        } else
                            A = a.vertexShader,
                            C = a.fragmentShader,
                            l.update(a),
                            P = l.getVertexShaderID(a),
                            R = l.getFragmentShaderID(a);
                        const O = e.getRenderTarget()
                          , D = !0 === _.isInstancedMesh
                          , I = !0 === _.isBatchedMesh
                          , N = !!a.map
                          , U = !!a.matcap
                          , k = !!E
                          , F = !!a.aoMap
                          , z = !!a.lightMap
                          , B = !!a.bumpMap
                          , H = !!a.normalMap
                          , G = !!a.displacementMap
                          , V = !!a.emissiveMap
                          , W = !!a.metalnessMap
                          , j = !!a.roughnessMap
                          , X = a.anisotropy > 0
                          , q = a.clearcoat > 0
                          , Y = a.iridescence > 0
                          , $ = a.sheen > 0
                          , K = a.transmission > 0
                          , Z = X && !!a.anisotropyMap
                          , J = q && !!a.clearcoatMap
                          , Q = q && !!a.clearcoatNormalMap
                          , ee = q && !!a.clearcoatRoughnessMap
                          , te = Y && !!a.iridescenceMap
                          , ne = Y && !!a.iridescenceThicknessMap
                          , re = $ && !!a.sheenColorMap
                          , ie = $ && !!a.sheenRoughnessMap
                          , ae = !!a.specularMap
                          , se = !!a.specularColorMap
                          , oe = !!a.specularIntensityMap
                          , le = K && !!a.transmissionMap
                          , ce = K && !!a.thicknessMap
                          , ue = !!a.gradientMap
                          , de = !!a.alphaMap
                          , he = a.alphaTest > 0
                          , pe = !!a.alphaHash
                          , fe = !!a.extensions;
                        let me = _a;
                        a.toneMapped && (null !== O && !0 !== O.isXRRenderTarget || (me = e.toneMapping));
                        const ge = {
                            isWebGL2: d,
                            shaderID: w,
                            shaderType: a.type,
                            shaderName: a.name,
                            vertexShader: A,
                            fragmentShader: C,
                            defines: a.defines,
                            customVertexShaderID: P,
                            customFragmentShaderID: R,
                            isRawShaderMaterial: !0 === a.isRawShaderMaterial,
                            glslVersion: a.glslVersion,
                            precision: f,
                            batching: I,
                            instancing: D,
                            instancingColor: D && null !== _.instanceColor,
                            instancingMorph: D && null !== _.morphTexture,
                            supportsVertexTextures: p,
                            outputColorSpace: null === O ? e.outputColorSpace : !0 === O.isXRRenderTarget ? O.texture.colorSpace : cs,
                            alphaToCoverage: !!a.alphaToCoverage,
                            map: N,
                            matcap: U,
                            envMap: k,
                            envMapMode: k && E.mapping,
                            envMapCubeUVHeight: S,
                            aoMap: F,
                            lightMap: z,
                            bumpMap: B,
                            normalMap: H,
                            displacementMap: p && G,
                            emissiveMap: V,
                            normalMapObjectSpace: H && 1 === a.normalMapType,
                            normalMapTangentSpace: H && 0 === a.normalMapType,
                            metalnessMap: W,
                            roughnessMap: j,
                            anisotropy: X,
                            anisotropyMap: Z,
                            clearcoat: q,
                            clearcoatMap: J,
                            clearcoatNormalMap: Q,
                            clearcoatRoughnessMap: ee,
                            iridescence: Y,
                            iridescenceMap: te,
                            iridescenceThicknessMap: ne,
                            sheen: $,
                            sheenColorMap: re,
                            sheenRoughnessMap: ie,
                            specularMap: ae,
                            specularColorMap: se,
                            specularIntensityMap: oe,
                            transmission: K,
                            transmissionMap: le,
                            thicknessMap: ce,
                            gradientMap: ue,
                            opaque: !1 === a.transparent && 1 === a.blending && !1 === a.alphaToCoverage,
                            alphaMap: de,
                            alphaTest: he,
                            alphaHash: pe,
                            combine: a.combine,
                            mapUv: N && g(a.map.channel),
                            aoMapUv: F && g(a.aoMap.channel),
                            lightMapUv: z && g(a.lightMap.channel),
                            bumpMapUv: B && g(a.bumpMap.channel),
                            normalMapUv: H && g(a.normalMap.channel),
                            displacementMapUv: G && g(a.displacementMap.channel),
                            emissiveMapUv: V && g(a.emissiveMap.channel),
                            metalnessMapUv: W && g(a.metalnessMap.channel),
                            roughnessMapUv: j && g(a.roughnessMap.channel),
                            anisotropyMapUv: Z && g(a.anisotropyMap.channel),
                            clearcoatMapUv: J && g(a.clearcoatMap.channel),
                            clearcoatNormalMapUv: Q && g(a.clearcoatNormalMap.channel),
                            clearcoatRoughnessMapUv: ee && g(a.clearcoatRoughnessMap.channel),
                            iridescenceMapUv: te && g(a.iridescenceMap.channel),
                            iridescenceThicknessMapUv: ne && g(a.iridescenceThicknessMap.channel),
                            sheenColorMapUv: re && g(a.sheenColorMap.channel),
                            sheenRoughnessMapUv: ie && g(a.sheenRoughnessMap.channel),
                            specularMapUv: ae && g(a.specularMap.channel),
                            specularColorMapUv: se && g(a.specularColorMap.channel),
                            specularIntensityMapUv: oe && g(a.specularIntensityMap.channel),
                            transmissionMapUv: le && g(a.transmissionMap.channel),
                            thicknessMapUv: ce && g(a.thicknessMap.channel),
                            alphaMapUv: de && g(a.alphaMap.channel),
                            vertexTangents: !!x.attributes.tangent && (H || X),
                            vertexColors: a.vertexColors,
                            vertexAlphas: !0 === a.vertexColors && !!x.attributes.color && 4 === x.attributes.color.itemSize,
                            pointsUvs: !0 === _.isPoints && !!x.attributes.uv && (N || de),
                            fog: !!y,
                            useFog: !0 === a.fog,
                            fogExp2: !!y && y.isFogExp2,
                            flatShading: !0 === a.flatShading,
                            sizeAttenuation: !0 === a.sizeAttenuation,
                            logarithmicDepthBuffer: h,
                            skinning: !0 === _.isSkinnedMesh,
                            morphTargets: void 0 !== x.morphAttributes.position,
                            morphNormals: void 0 !== x.morphAttributes.normal,
                            morphColors: void 0 !== x.morphAttributes.color,
                            morphTargetsCount: T,
                            morphTextureStride: L,
                            numDirLights: o.directional.length,
                            numPointLights: o.point.length,
                            numSpotLights: o.spot.length,
                            numSpotLightMaps: o.spotLightMap.length,
                            numRectAreaLights: o.rectArea.length,
                            numHemiLights: o.hemi.length,
                            numDirLightShadows: o.directionalShadowMap.length,
                            numPointLightShadows: o.pointShadowMap.length,
                            numSpotLightShadows: o.spotShadowMap.length,
                            numSpotLightShadowsWithMaps: o.numSpotLightShadowsWithMaps,
                            numLightProbes: o.numLightProbes,
                            numClippingPlanes: s.numPlanes,
                            numClipIntersection: s.numIntersection,
                            dithering: a.dithering,
                            shadowMapEnabled: e.shadowMap.enabled && u.length > 0,
                            shadowMapType: e.shadowMap.type,
                            toneMapping: me,
                            useLegacyLights: e._useLegacyLights,
                            decodeVideoTexture: N && !0 === a.map.isVideoTexture && Xs.getTransfer(a.map.colorSpace) === ps,
                            premultipliedAlpha: a.premultipliedAlpha,
                            doubleSided: 2 === a.side,
                            flipSided: a.side === pa,
                            useDepthPacking: a.depthPacking >= 0,
                            depthPacking: a.depthPacking || 0,
                            index0AttributeName: a.index0AttributeName,
                            extensionDerivatives: fe && !0 === a.extensions.derivatives,
                            extensionFragDepth: fe && !0 === a.extensions.fragDepth,
                            extensionDrawBuffers: fe && !0 === a.extensions.drawBuffers,
                            extensionShaderTextureLOD: fe && !0 === a.extensions.shaderTextureLOD,
                            extensionClipCullDistance: fe && !0 === a.extensions.clipCullDistance && r.has("WEBGL_clip_cull_distance"),
                            extensionMultiDraw: fe && !0 === a.extensions.multiDraw && r.has("WEBGL_multi_draw"),
                            rendererExtensionFragDepth: d || r.has("EXT_frag_depth"),
                            rendererExtensionDrawBuffers: d || r.has("WEBGL_draw_buffers"),
                            rendererExtensionShaderTextureLod: d || r.has("EXT_shader_texture_lod"),
                            rendererExtensionParallelShaderCompile: r.has("KHR_parallel_shader_compile"),
                            customProgramCacheKey: a.customProgramCacheKey()
                        };
                        return ge.vertexUv1s = c.has(1),
                        ge.vertexUv2s = c.has(2),
                        ge.vertexUv3s = c.has(3),
                        c.clear(),
                        ge
                    },
                    getProgramCacheKey: function(t) {
                        const n = [];
                        if (t.shaderID ? n.push(t.shaderID) : (n.push(t.customVertexShaderID),
                        n.push(t.customFragmentShaderID)),
                        void 0 !== t.defines)
                            for (const e in t.defines)
                                n.push(e),
                                n.push(t.defines[e]);
                        return !1 === t.isRawShaderMaterial && (!function(e, t) {
                            e.push(t.precision),
                            e.push(t.outputColorSpace),
                            e.push(t.envMapMode),
                            e.push(t.envMapCubeUVHeight),
                            e.push(t.mapUv),
                            e.push(t.alphaMapUv),
                            e.push(t.lightMapUv),
                            e.push(t.aoMapUv),
                            e.push(t.bumpMapUv),
                            e.push(t.normalMapUv),
                            e.push(t.displacementMapUv),
                            e.push(t.emissiveMapUv),
                            e.push(t.metalnessMapUv),
                            e.push(t.roughnessMapUv),
                            e.push(t.anisotropyMapUv),
                            e.push(t.clearcoatMapUv),
                            e.push(t.clearcoatNormalMapUv),
                            e.push(t.clearcoatRoughnessMapUv),
                            e.push(t.iridescenceMapUv),
                            e.push(t.iridescenceThicknessMapUv),
                            e.push(t.sheenColorMapUv),
                            e.push(t.sheenRoughnessMapUv),
                            e.push(t.specularMapUv),
                            e.push(t.specularColorMapUv),
                            e.push(t.specularIntensityMapUv),
                            e.push(t.transmissionMapUv),
                            e.push(t.thicknessMapUv),
                            e.push(t.combine),
                            e.push(t.fogExp2),
                            e.push(t.sizeAttenuation),
                            e.push(t.morphTargetsCount),
                            e.push(t.morphAttributeCount),
                            e.push(t.numDirLights),
                            e.push(t.numPointLights),
                            e.push(t.numSpotLights),
                            e.push(t.numSpotLightMaps),
                            e.push(t.numHemiLights),
                            e.push(t.numRectAreaLights),
                            e.push(t.numDirLightShadows),
                            e.push(t.numPointLightShadows),
                            e.push(t.numSpotLightShadows),
                            e.push(t.numSpotLightShadowsWithMaps),
                            e.push(t.numLightProbes),
                            e.push(t.shadowMapType),
                            e.push(t.toneMapping),
                            e.push(t.numClippingPlanes),
                            e.push(t.numClipIntersection),
                            e.push(t.depthPacking)
                        }(n, t),
                        function(e, t) {
                            o.disableAll(),
                            t.isWebGL2 && o.enable(0);
                            t.supportsVertexTextures && o.enable(1);
                            t.instancing && o.enable(2);
                            t.instancingColor && o.enable(3);
                            t.instancingMorph && o.enable(4);
                            t.matcap && o.enable(5);
                            t.envMap && o.enable(6);
                            t.normalMapObjectSpace && o.enable(7);
                            t.normalMapTangentSpace && o.enable(8);
                            t.clearcoat && o.enable(9);
                            t.iridescence && o.enable(10);
                            t.alphaTest && o.enable(11);
                            t.vertexColors && o.enable(12);
                            t.vertexAlphas && o.enable(13);
                            t.vertexUv1s && o.enable(14);
                            t.vertexUv2s && o.enable(15);
                            t.vertexUv3s && o.enable(16);
                            t.vertexTangents && o.enable(17);
                            t.anisotropy && o.enable(18);
                            t.alphaHash && o.enable(19);
                            t.batching && o.enable(20);
                            e.push(o.mask),
                            o.disableAll(),
                            t.fog && o.enable(0);
                            t.useFog && o.enable(1);
                            t.flatShading && o.enable(2);
                            t.logarithmicDepthBuffer && o.enable(3);
                            t.skinning && o.enable(4);
                            t.morphTargets && o.enable(5);
                            t.morphNormals && o.enable(6);
                            t.morphColors && o.enable(7);
                            t.premultipliedAlpha && o.enable(8);
                            t.shadowMapEnabled && o.enable(9);
                            t.useLegacyLights && o.enable(10);
                            t.doubleSided && o.enable(11);
                            t.flipSided && o.enable(12);
                            t.useDepthPacking && o.enable(13);
                            t.dithering && o.enable(14);
                            t.transmission && o.enable(15);
                            t.sheen && o.enable(16);
                            t.opaque && o.enable(17);
                            t.pointsUvs && o.enable(18);
                            t.decodeVideoTexture && o.enable(19);
                            t.alphaToCoverage && o.enable(20);
                            e.push(o.mask)
                        }(n, t),
                        n.push(e.outputColorSpace)),
                        n.push(t.customProgramCacheKey),
                        n.join()
                    },
                    getUniforms: function(e) {
                        const t = m[e.type];
                        let n;
                        if (t) {
                            const e = zc[t];
                            n = gc.clone(e.uniforms)
                        } else
                            n = e.uniforms;
                        return n
                    },
                    acquireProgram: function(t, n) {
                        let r;
                        for (let e = 0, t = u.length; e < t; e++) {
                            const t = u[e];
                            if (t.cacheKey === n) {
                                r = t,
                                ++r.usedTimes;
                                break
                            }
                        }
                        return void 0 === r && (r = new Wd(e,n,t,a),
                        u.push(r)),
                        r
                    },
                    releaseProgram: function(e) {
                        if (0 == --e.usedTimes) {
                            const t = u.indexOf(e);
                            u[t] = u[u.length - 1],
                            u.pop(),
                            e.destroy()
                        }
                    },
                    releaseShaderCache: function(e) {
                        l.remove(e)
                    },
                    programs: u,
                    dispose: function() {
                        l.dispose()
                    }
                }
            }
            function $d() {
                let e = new WeakMap;
                return {
                    get: function(t) {
                        let n = e.get(t);
                        return void 0 === n && (n = {},
                        e.set(t, n)),
                        n
                    },
                    remove: function(t) {
                        e.delete(t)
                    },
                    update: function(t, n, r) {
                        e.get(t)[n] = r
                    },
                    dispose: function() {
                        e = new WeakMap
                    }
                }
            }
            function Kd(e, t) {
                return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
            }
            function Zd(e, t) {
                return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
            }
            function Jd() {
                const e = [];
                let t = 0;
                const n = []
                  , r = []
                  , i = [];
                function a(n, r, i, a, s, o) {
                    let l = e[t];
                    return void 0 === l ? (l = {
                        id: n.id,
                        object: n,
                        geometry: r,
                        material: i,
                        groupOrder: a,
                        renderOrder: n.renderOrder,
                        z: s,
                        group: o
                    },
                    e[t] = l) : (l.id = n.id,
                    l.object = n,
                    l.geometry = r,
                    l.material = i,
                    l.groupOrder = a,
                    l.renderOrder = n.renderOrder,
                    l.z = s,
                    l.group = o),
                    t++,
                    l
                }
                return {
                    opaque: n,
                    transmissive: r,
                    transparent: i,
                    init: function() {
                        t = 0,
                        n.length = 0,
                        r.length = 0,
                        i.length = 0
                    },
                    push: function(e, t, s, o, l, c) {
                        const u = a(e, t, s, o, l, c);
                        s.transmission > 0 ? r.push(u) : !0 === s.transparent ? i.push(u) : n.push(u)
                    },
                    unshift: function(e, t, s, o, l, c) {
                        const u = a(e, t, s, o, l, c);
                        s.transmission > 0 ? r.unshift(u) : !0 === s.transparent ? i.unshift(u) : n.unshift(u)
                    },
                    finish: function() {
                        for (let n = t, r = e.length; n < r; n++) {
                            const t = e[n];
                            if (null === t.id)
                                break;
                            t.id = null,
                            t.object = null,
                            t.geometry = null,
                            t.material = null,
                            t.group = null
                        }
                    },
                    sort: function(e, t) {
                        n.length > 1 && n.sort(e || Kd),
                        r.length > 1 && r.sort(t || Zd),
                        i.length > 1 && i.sort(t || Zd)
                    }
                }
            }
            function Qd() {
                let e = new WeakMap;
                return {
                    get: function(t, n) {
                        const r = e.get(t);
                        let i;
                        return void 0 === r ? (i = new Jd,
                        e.set(t, [i])) : n >= r.length ? (i = new Jd,
                        r.push(i)) : i = r[n],
                        i
                    },
                    dispose: function() {
                        e = new WeakMap
                    }
                }
            }
            function eh() {
                const e = {};
                return {
                    get: function(t) {
                        if (void 0 !== e[t.id])
                            return e[t.id];
                        let n;
                        switch (t.type) {
                        case "DirectionalLight":
                            n = {
                                direction: new lo,
                                color: new Cl
                            };
                            break;
                        case "SpotLight":
                            n = {
                                position: new lo,
                                direction: new lo,
                                color: new Cl,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0
                            };
                            break;
                        case "PointLight":
                            n = {
                                position: new lo,
                                color: new Cl,
                                distance: 0,
                                decay: 0
                            };
                            break;
                        case "HemisphereLight":
                            n = {
                                direction: new lo,
                                skyColor: new Cl,
                                groundColor: new Cl
                            };
                            break;
                        case "RectAreaLight":
                            n = {
                                color: new Cl,
                                position: new lo,
                                halfWidth: new lo,
                                halfHeight: new lo
                            }
                        }
                        return e[t.id] = n,
                        n
                    }
                }
            }
            let th = 0;
            function nh(e, t) {
                return (t.castShadow ? 2 : 0) - (e.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (e.map ? 1 : 0)
            }
            function rh(e, t) {
                const n = new eh
                  , r = function() {
                    const e = {};
                    return {
                        get: function(t) {
                            if (void 0 !== e[t.id])
                                return e[t.id];
                            let n;
                            switch (t.type) {
                            case "DirectionalLight":
                            case "SpotLight":
                                n = {
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new Is
                                };
                                break;
                            case "PointLight":
                                n = {
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new Is,
                                    shadowCameraNear: 1,
                                    shadowCameraFar: 1e3
                                }
                            }
                            return e[t.id] = n,
                            n
                        }
                    }
                }()
                  , i = {
                    version: 0,
                    hash: {
                        directionalLength: -1,
                        pointLength: -1,
                        spotLength: -1,
                        rectAreaLength: -1,
                        hemiLength: -1,
                        numDirectionalShadows: -1,
                        numPointShadows: -1,
                        numSpotShadows: -1,
                        numSpotMaps: -1,
                        numLightProbes: -1
                    },
                    ambient: [0, 0, 0],
                    probe: [],
                    directional: [],
                    directionalShadow: [],
                    directionalShadowMap: [],
                    directionalShadowMatrix: [],
                    spot: [],
                    spotLightMap: [],
                    spotShadow: [],
                    spotShadowMap: [],
                    spotLightMatrix: [],
                    rectArea: [],
                    rectAreaLTC1: null,
                    rectAreaLTC2: null,
                    point: [],
                    pointShadow: [],
                    pointShadowMap: [],
                    pointShadowMatrix: [],
                    hemi: [],
                    numSpotLightShadowsWithMaps: 0,
                    numLightProbes: 0
                };
                for (let e = 0; e < 9; e++)
                    i.probe.push(new lo);
                const a = new lo
                  , s = new zo
                  , o = new zo;
                return {
                    setup: function(a, s) {
                        let o = 0
                          , l = 0
                          , c = 0;
                        for (let e = 0; e < 9; e++)
                            i.probe[e].set(0, 0, 0);
                        let u = 0
                          , d = 0
                          , h = 0
                          , p = 0
                          , f = 0
                          , m = 0
                          , g = 0
                          , v = 0
                          , _ = 0
                          , y = 0
                          , x = 0;
                        a.sort(nh);
                        const b = !0 === s ? Math.PI : 1;
                        for (let e = 0, t = a.length; e < t; e++) {
                            const t = a[e]
                              , s = t.color
                              , E = t.intensity
                              , S = t.distance
                              , w = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
                            if (t.isAmbientLight)
                                o += s.r * E * b,
                                l += s.g * E * b,
                                c += s.b * E * b;
                            else if (t.isLightProbe) {
                                for (let e = 0; e < 9; e++)
                                    i.probe[e].addScaledVector(t.sh.coefficients[e], E);
                                x++
                            } else if (t.isDirectionalLight) {
                                const e = n.get(t);
                                if (e.color.copy(t.color).multiplyScalar(t.intensity * b),
                                t.castShadow) {
                                    const e = t.shadow
                                      , n = r.get(t);
                                    n.shadowBias = e.bias,
                                    n.shadowNormalBias = e.normalBias,
                                    n.shadowRadius = e.radius,
                                    n.shadowMapSize = e.mapSize,
                                    i.directionalShadow[u] = n,
                                    i.directionalShadowMap[u] = w,
                                    i.directionalShadowMatrix[u] = t.shadow.matrix,
                                    m++
                                }
                                i.directional[u] = e,
                                u++
                            } else if (t.isSpotLight) {
                                const e = n.get(t);
                                e.position.setFromMatrixPosition(t.matrixWorld),
                                e.color.copy(s).multiplyScalar(E * b),
                                e.distance = S,
                                e.coneCos = Math.cos(t.angle),
                                e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra)),
                                e.decay = t.decay,
                                i.spot[h] = e;
                                const a = t.shadow;
                                if (t.map && (i.spotLightMap[_] = t.map,
                                _++,
                                a.updateMatrices(t),
                                t.castShadow && y++),
                                i.spotLightMatrix[h] = a.matrix,
                                t.castShadow) {
                                    const e = r.get(t);
                                    e.shadowBias = a.bias,
                                    e.shadowNormalBias = a.normalBias,
                                    e.shadowRadius = a.radius,
                                    e.shadowMapSize = a.mapSize,
                                    i.spotShadow[h] = e,
                                    i.spotShadowMap[h] = w,
                                    v++
                                }
                                h++
                            } else if (t.isRectAreaLight) {
                                const e = n.get(t);
                                e.color.copy(s).multiplyScalar(E),
                                e.halfWidth.set(.5 * t.width, 0, 0),
                                e.halfHeight.set(0, .5 * t.height, 0),
                                i.rectArea[p] = e,
                                p++
                            } else if (t.isPointLight) {
                                const e = n.get(t);
                                if (e.color.copy(t.color).multiplyScalar(t.intensity * b),
                                e.distance = t.distance,
                                e.decay = t.decay,
                                t.castShadow) {
                                    const e = t.shadow
                                      , n = r.get(t);
                                    n.shadowBias = e.bias,
                                    n.shadowNormalBias = e.normalBias,
                                    n.shadowRadius = e.radius,
                                    n.shadowMapSize = e.mapSize,
                                    n.shadowCameraNear = e.camera.near,
                                    n.shadowCameraFar = e.camera.far,
                                    i.pointShadow[d] = n,
                                    i.pointShadowMap[d] = w,
                                    i.pointShadowMatrix[d] = t.shadow.matrix,
                                    g++
                                }
                                i.point[d] = e,
                                d++
                            } else if (t.isHemisphereLight) {
                                const e = n.get(t);
                                e.skyColor.copy(t.color).multiplyScalar(E * b),
                                e.groundColor.copy(t.groundColor).multiplyScalar(E * b),
                                i.hemi[f] = e,
                                f++
                            }
                        }
                        p > 0 && (t.isWebGL2 ? !0 === e.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = Fc.LTC_FLOAT_1,
                        i.rectAreaLTC2 = Fc.LTC_FLOAT_2) : (i.rectAreaLTC1 = Fc.LTC_HALF_1,
                        i.rectAreaLTC2 = Fc.LTC_HALF_2) : !0 === e.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = Fc.LTC_FLOAT_1,
                        i.rectAreaLTC2 = Fc.LTC_FLOAT_2) : !0 === e.has("OES_texture_half_float_linear") ? (i.rectAreaLTC1 = Fc.LTC_HALF_1,
                        i.rectAreaLTC2 = Fc.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
                        i.ambient[0] = o,
                        i.ambient[1] = l,
                        i.ambient[2] = c;
                        const E = i.hash;
                        E.directionalLength === u && E.pointLength === d && E.spotLength === h && E.rectAreaLength === p && E.hemiLength === f && E.numDirectionalShadows === m && E.numPointShadows === g && E.numSpotShadows === v && E.numSpotMaps === _ && E.numLightProbes === x || (i.directional.length = u,
                        i.spot.length = h,
                        i.rectArea.length = p,
                        i.point.length = d,
                        i.hemi.length = f,
                        i.directionalShadow.length = m,
                        i.directionalShadowMap.length = m,
                        i.pointShadow.length = g,
                        i.pointShadowMap.length = g,
                        i.spotShadow.length = v,
                        i.spotShadowMap.length = v,
                        i.directionalShadowMatrix.length = m,
                        i.pointShadowMatrix.length = g,
                        i.spotLightMatrix.length = v + _ - y,
                        i.spotLightMap.length = _,
                        i.numSpotLightShadowsWithMaps = y,
                        i.numLightProbes = x,
                        E.directionalLength = u,
                        E.pointLength = d,
                        E.spotLength = h,
                        E.rectAreaLength = p,
                        E.hemiLength = f,
                        E.numDirectionalShadows = m,
                        E.numPointShadows = g,
                        E.numSpotShadows = v,
                        E.numSpotMaps = _,
                        E.numLightProbes = x,
                        i.version = th++)
                    },
                    setupView: function(e, t) {
                        let n = 0
                          , r = 0
                          , l = 0
                          , c = 0
                          , u = 0;
                        const d = t.matrixWorldInverse;
                        for (let t = 0, h = e.length; t < h; t++) {
                            const h = e[t];
                            if (h.isDirectionalLight) {
                                const e = i.directional[n];
                                e.direction.setFromMatrixPosition(h.matrixWorld),
                                a.setFromMatrixPosition(h.target.matrixWorld),
                                e.direction.sub(a),
                                e.direction.transformDirection(d),
                                n++
                            } else if (h.isSpotLight) {
                                const e = i.spot[l];
                                e.position.setFromMatrixPosition(h.matrixWorld),
                                e.position.applyMatrix4(d),
                                e.direction.setFromMatrixPosition(h.matrixWorld),
                                a.setFromMatrixPosition(h.target.matrixWorld),
                                e.direction.sub(a),
                                e.direction.transformDirection(d),
                                l++
                            } else if (h.isRectAreaLight) {
                                const e = i.rectArea[c];
                                e.position.setFromMatrixPosition(h.matrixWorld),
                                e.position.applyMatrix4(d),
                                o.identity(),
                                s.copy(h.matrixWorld),
                                s.premultiply(d),
                                o.extractRotation(s),
                                e.halfWidth.set(.5 * h.width, 0, 0),
                                e.halfHeight.set(0, .5 * h.height, 0),
                                e.halfWidth.applyMatrix4(o),
                                e.halfHeight.applyMatrix4(o),
                                c++
                            } else if (h.isPointLight) {
                                const e = i.point[r];
                                e.position.setFromMatrixPosition(h.matrixWorld),
                                e.position.applyMatrix4(d),
                                r++
                            } else if (h.isHemisphereLight) {
                                const e = i.hemi[u];
                                e.direction.setFromMatrixPosition(h.matrixWorld),
                                e.direction.transformDirection(d),
                                u++
                            }
                        }
                    },
                    state: i
                }
            }
            function ih(e, t) {
                const n = new rh(e,t)
                  , r = []
                  , i = [];
                return {
                    init: function() {
                        r.length = 0,
                        i.length = 0
                    },
                    state: {
                        lightsArray: r,
                        shadowsArray: i,
                        lights: n
                    },
                    setupLights: function(e) {
                        n.setup(r, e)
                    },
                    setupLightsView: function(e) {
                        n.setupView(r, e)
                    },
                    pushLight: function(e) {
                        r.push(e)
                    },
                    pushShadow: function(e) {
                        i.push(e)
                    }
                }
            }
            function ah(e, t) {
                let n = new WeakMap;
                return {
                    get: function(r, i=0) {
                        const a = n.get(r);
                        let s;
                        return void 0 === a ? (s = new ih(e,t),
                        n.set(r, [s])) : i >= a.length ? (s = new ih(e,t),
                        a.push(s)) : s = a[i],
                        s
                    },
                    dispose: function() {
                        n = new WeakMap
                    }
                }
            }
            class sh extends Ll {
                constructor(e) {
                    super(),
                    this.isMeshDepthMaterial = !0,
                    this.type = "MeshDepthMaterial",
                    this.depthPacking = 3200,
                    this.map = null,
                    this.alphaMap = null,
                    this.displacementMap = null,
                    this.displacementScale = 1,
                    this.displacementBias = 0,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.setValues(e)
                }
                copy(e) {
                    return super.copy(e),
                    this.depthPacking = e.depthPacking,
                    this.map = e.map,
                    this.alphaMap = e.alphaMap,
                    this.displacementMap = e.displacementMap,
                    this.displacementScale = e.displacementScale,
                    this.displacementBias = e.displacementBias,
                    this.wireframe = e.wireframe,
                    this.wireframeLinewidth = e.wireframeLinewidth,
                    this
                }
            }
            class oh extends Ll {
                constructor(e) {
                    super(),
                    this.isMeshDistanceMaterial = !0,
                    this.type = "MeshDistanceMaterial",
                    this.map = null,
                    this.alphaMap = null,
                    this.displacementMap = null,
                    this.displacementScale = 1,
                    this.displacementBias = 0,
                    this.setValues(e)
                }
                copy(e) {
                    return super.copy(e),
                    this.map = e.map,
                    this.alphaMap = e.alphaMap,
                    this.displacementMap = e.displacementMap,
                    this.displacementScale = e.displacementScale,
                    this.displacementBias = e.displacementBias,
                    this
                }
            }
            function lh(e, t, n) {
                let r = new Dc;
                const i = new Is
                  , a = new Is
                  , s = new no
                  , o = new sh({
                    depthPacking: 3201
                })
                  , l = new oh
                  , c = {}
                  , u = n.maxTextureSize
                  , d = {
                    [ha]: pa,
                    [pa]: ha,
                    2: 2
                }
                  , h = new vc({
                    defines: {
                        VSM_SAMPLES: 8
                    },
                    uniforms: {
                        shadow_pass: {
                            value: null
                        },
                        resolution: {
                            value: new Is
                        },
                        radius: {
                            value: 4
                        }
                    },
                    vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                    fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
                })
                  , p = h.clone();
                p.defines.HORIZONTAL_PASS = 1;
                const f = new Xl;
                f.setAttribute("position", new Nl(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
                const m = new uc(f,h)
                  , g = this;
                this.enabled = !1,
                this.autoUpdate = !0,
                this.needsUpdate = !1,
                this.type = ca;
                let v = this.type;
                function _(n, r) {
                    const a = t.update(m);
                    h.defines.VSM_SAMPLES !== n.blurSamples && (h.defines.VSM_SAMPLES = n.blurSamples,
                    p.defines.VSM_SAMPLES = n.blurSamples,
                    h.needsUpdate = !0,
                    p.needsUpdate = !0),
                    null === n.mapPass && (n.mapPass = new io(i.x,i.y)),
                    h.uniforms.shadow_pass.value = n.map.texture,
                    h.uniforms.resolution.value = n.mapSize,
                    h.uniforms.radius.value = n.radius,
                    e.setRenderTarget(n.mapPass),
                    e.clear(),
                    e.renderBufferDirect(r, null, a, h, m, null),
                    p.uniforms.shadow_pass.value = n.mapPass.texture,
                    p.uniforms.resolution.value = n.mapSize,
                    p.uniforms.radius.value = n.radius,
                    e.setRenderTarget(n.map),
                    e.clear(),
                    e.renderBufferDirect(r, null, a, p, m, null)
                }
                function y(t, n, r, i) {
                    let a = null;
                    const s = !0 === r.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
                    if (void 0 !== s)
                        a = s;
                    else if (a = !0 === r.isPointLight ? l : o,
                    e.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0 || n.map && n.alphaTest > 0) {
                        const e = a.uuid
                          , t = n.uuid;
                        let r = c[e];
                        void 0 === r && (r = {},
                        c[e] = r);
                        let i = r[t];
                        void 0 === i && (i = a.clone(),
                        r[t] = i,
                        n.addEventListener("dispose", b)),
                        a = i
                    }
                    if (a.visible = n.visible,
                    a.wireframe = n.wireframe,
                    a.side = i === da ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : d[n.side],
                    a.alphaMap = n.alphaMap,
                    a.alphaTest = n.alphaTest,
                    a.map = n.map,
                    a.clipShadows = n.clipShadows,
                    a.clippingPlanes = n.clippingPlanes,
                    a.clipIntersection = n.clipIntersection,
                    a.displacementMap = n.displacementMap,
                    a.displacementScale = n.displacementScale,
                    a.displacementBias = n.displacementBias,
                    a.wireframeLinewidth = n.wireframeLinewidth,
                    a.linewidth = n.linewidth,
                    !0 === r.isPointLight && !0 === a.isMeshDistanceMaterial) {
                        e.properties.get(a).light = r
                    }
                    return a
                }
                function x(n, i, a, s, o) {
                    if (!1 === n.visible)
                        return;
                    if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && o === da) && (!n.frustumCulled || r.intersectsObject(n))) {
                        n.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, n.matrixWorld);
                        const r = t.update(n)
                          , l = n.material;
                        if (Array.isArray(l)) {
                            const t = r.groups;
                            for (let c = 0, u = t.length; c < u; c++) {
                                const u = t[c]
                                  , d = l[u.materialIndex];
                                if (d && d.visible) {
                                    const t = y(n, d, s, o);
                                    n.onBeforeShadow(e, n, i, a, r, t, u),
                                    e.renderBufferDirect(a, null, r, t, n, u),
                                    n.onAfterShadow(e, n, i, a, r, t, u)
                                }
                            }
                        } else if (l.visible) {
                            const t = y(n, l, s, o);
                            n.onBeforeShadow(e, n, i, a, r, t, null),
                            e.renderBufferDirect(a, null, r, t, n, null),
                            n.onAfterShadow(e, n, i, a, r, t, null)
                        }
                    }
                    const l = n.children;
                    for (let e = 0, t = l.length; e < t; e++)
                        x(l[e], i, a, s, o)
                }
                function b(e) {
                    e.target.removeEventListener("dispose", b);
                    for (const t in c) {
                        const n = c[t]
                          , r = e.target.uuid;
                        if (r in n) {
                            n[r].dispose(),
                            delete n[r]
                        }
                    }
                }
                this.render = function(t, n, o) {
                    if (!1 === g.enabled)
                        return;
                    if (!1 === g.autoUpdate && !1 === g.needsUpdate)
                        return;
                    if (0 === t.length)
                        return;
                    const l = e.getRenderTarget()
                      , c = e.getActiveCubeFace()
                      , d = e.getActiveMipmapLevel()
                      , h = e.state;
                    h.setBlending(0),
                    h.buffers.color.setClear(1, 1, 1, 1),
                    h.buffers.depth.setTest(!0),
                    h.setScissorTest(!1);
                    const p = v !== da && this.type === da
                      , f = v === da && this.type !== da;
                    for (let l = 0, c = t.length; l < c; l++) {
                        const c = t[l]
                          , d = c.shadow;
                        if (void 0 === d) {
                            console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
                            continue
                        }
                        if (!1 === d.autoUpdate && !1 === d.needsUpdate)
                            continue;
                        i.copy(d.mapSize);
                        const m = d.getFrameExtents();
                        if (i.multiply(m),
                        a.copy(d.mapSize),
                        (i.x > u || i.y > u) && (i.x > u && (a.x = Math.floor(u / m.x),
                        i.x = a.x * m.x,
                        d.mapSize.x = a.x),
                        i.y > u && (a.y = Math.floor(u / m.y),
                        i.y = a.y * m.y,
                        d.mapSize.y = a.y)),
                        null === d.map || !0 === p || !0 === f) {
                            const e = this.type !== da ? {
                                minFilter: Ia,
                                magFilter: Ia
                            } : {};
                            null !== d.map && d.map.dispose(),
                            d.map = new io(i.x,i.y,e),
                            d.map.texture.name = c.name + ".shadowMap",
                            d.camera.updateProjectionMatrix()
                        }
                        e.setRenderTarget(d.map),
                        e.clear();
                        const g = d.getViewportCount();
                        for (let e = 0; e < g; e++) {
                            const t = d.getViewport(e);
                            s.set(a.x * t.x, a.y * t.y, a.x * t.z, a.y * t.w),
                            h.viewport(s),
                            d.updateMatrices(c, e),
                            r = d.getFrustum(),
                            x(n, o, d.camera, c, this.type)
                        }
                        !0 !== d.isPointLightShadow && this.type === da && _(d, o),
                        d.needsUpdate = !1
                    }
                    v = this.type,
                    g.needsUpdate = !1,
                    e.setRenderTarget(l, c, d)
                }
            }
            function ch(e, t, n) {
                const r = n.isWebGL2;
                const i = new function() {
                    let t = !1;
                    const n = new no;
                    let r = null;
                    const i = new no(0,0,0,0);
                    return {
                        setMask: function(n) {
                            r === n || t || (e.colorMask(n, n, n, n),
                            r = n)
                        },
                        setLocked: function(e) {
                            t = e
                        },
                        setClear: function(t, r, a, s, o) {
                            !0 === o && (t *= s,
                            r *= s,
                            a *= s),
                            n.set(t, r, a, s),
                            !1 === i.equals(n) && (e.clearColor(t, r, a, s),
                            i.copy(n))
                        },
                        reset: function() {
                            t = !1,
                            r = null,
                            i.set(-1, 0, 0, 0)
                        }
                    }
                }
                  , a = new function() {
                    let t = !1
                      , n = null
                      , r = null
                      , i = null;
                    return {
                        setTest: function(t) {
                            t ? G(e.DEPTH_TEST) : V(e.DEPTH_TEST)
                        },
                        setMask: function(r) {
                            n === r || t || (e.depthMask(r),
                            n = r)
                        },
                        setFunc: function(t) {
                            if (r !== t) {
                                switch (t) {
                                case 0:
                                    e.depthFunc(e.NEVER);
                                    break;
                                case 1:
                                    e.depthFunc(e.ALWAYS);
                                    break;
                                case 2:
                                    e.depthFunc(e.LESS);
                                    break;
                                case 3:
                                default:
                                    e.depthFunc(e.LEQUAL);
                                    break;
                                case 4:
                                    e.depthFunc(e.EQUAL);
                                    break;
                                case 5:
                                    e.depthFunc(e.GEQUAL);
                                    break;
                                case 6:
                                    e.depthFunc(e.GREATER);
                                    break;
                                case 7:
                                    e.depthFunc(e.NOTEQUAL)
                                }
                                r = t
                            }
                        },
                        setLocked: function(e) {
                            t = e
                        },
                        setClear: function(t) {
                            i !== t && (e.clearDepth(t),
                            i = t)
                        },
                        reset: function() {
                            t = !1,
                            n = null,
                            r = null,
                            i = null
                        }
                    }
                }
                  , s = new function() {
                    let t = !1
                      , n = null
                      , r = null
                      , i = null
                      , a = null
                      , s = null
                      , o = null
                      , l = null
                      , c = null;
                    return {
                        setTest: function(n) {
                            t || (n ? G(e.STENCIL_TEST) : V(e.STENCIL_TEST))
                        },
                        setMask: function(r) {
                            n === r || t || (e.stencilMask(r),
                            n = r)
                        },
                        setFunc: function(t, n, s) {
                            r === t && i === n && a === s || (e.stencilFunc(t, n, s),
                            r = t,
                            i = n,
                            a = s)
                        },
                        setOp: function(t, n, r) {
                            s === t && o === n && l === r || (e.stencilOp(t, n, r),
                            s = t,
                            o = n,
                            l = r)
                        },
                        setLocked: function(e) {
                            t = e
                        },
                        setClear: function(t) {
                            c !== t && (e.clearStencil(t),
                            c = t)
                        },
                        reset: function() {
                            t = !1,
                            n = null,
                            r = null,
                            i = null,
                            a = null,
                            s = null,
                            o = null,
                            l = null,
                            c = null
                        }
                    }
                }
                  , o = new WeakMap
                  , l = new WeakMap;
                let c = {}
                  , u = {}
                  , d = new WeakMap
                  , h = []
                  , p = null
                  , f = !1
                  , m = null
                  , g = null
                  , v = null
                  , _ = null
                  , y = null
                  , x = null
                  , b = null
                  , E = new Cl(0,0,0)
                  , S = 0
                  , w = !1
                  , M = null
                  , T = null
                  , A = null
                  , C = null
                  , P = null;
                const R = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
                let L = !1
                  , O = 0;
                const D = e.getParameter(e.VERSION);
                -1 !== D.indexOf("WebGL") ? (O = parseFloat(/^WebGL (\d)/.exec(D)[1]),
                L = O >= 1) : -1 !== D.indexOf("OpenGL ES") && (O = parseFloat(/^OpenGL ES (\d)/.exec(D)[1]),
                L = O >= 2);
                let I = null
                  , N = {};
                const U = e.getParameter(e.SCISSOR_BOX)
                  , k = e.getParameter(e.VIEWPORT)
                  , F = (new no).fromArray(U)
                  , z = (new no).fromArray(k);
                function B(t, n, i, a) {
                    const s = new Uint8Array(4)
                      , o = e.createTexture();
                    e.bindTexture(t, o),
                    e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST),
                    e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST);
                    for (let o = 0; o < i; o++)
                        !r || t !== e.TEXTURE_3D && t !== e.TEXTURE_2D_ARRAY ? e.texImage2D(n + o, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, s) : e.texImage3D(n, 0, e.RGBA, 1, 1, a, 0, e.RGBA, e.UNSIGNED_BYTE, s);
                    return o
                }
                const H = {};
                function G(t) {
                    !0 !== c[t] && (e.enable(t),
                    c[t] = !0)
                }
                function V(t) {
                    !1 !== c[t] && (e.disable(t),
                    c[t] = !1)
                }
                H[e.TEXTURE_2D] = B(e.TEXTURE_2D, e.TEXTURE_2D, 1),
                H[e.TEXTURE_CUBE_MAP] = B(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
                r && (H[e.TEXTURE_2D_ARRAY] = B(e.TEXTURE_2D_ARRAY, e.TEXTURE_2D_ARRAY, 1, 1),
                H[e.TEXTURE_3D] = B(e.TEXTURE_3D, e.TEXTURE_3D, 1, 1)),
                i.setClear(0, 0, 0, 1),
                a.setClear(1),
                s.setClear(0),
                G(e.DEPTH_TEST),
                a.setFunc(3),
                q(!1),
                Y(1),
                G(e.CULL_FACE),
                X(0);
                const W = {
                    [fa]: e.FUNC_ADD,
                    101: e.FUNC_SUBTRACT,
                    102: e.FUNC_REVERSE_SUBTRACT
                };
                if (r)
                    W[103] = e.MIN,
                    W[104] = e.MAX;
                else {
                    const e = t.get("EXT_blend_minmax");
                    null !== e && (W[103] = e.MIN_EXT,
                    W[104] = e.MAX_EXT)
                }
                const j = {
                    200: e.ZERO,
                    201: e.ONE,
                    202: e.SRC_COLOR,
                    204: e.SRC_ALPHA,
                    210: e.SRC_ALPHA_SATURATE,
                    208: e.DST_COLOR,
                    206: e.DST_ALPHA,
                    203: e.ONE_MINUS_SRC_COLOR,
                    205: e.ONE_MINUS_SRC_ALPHA,
                    209: e.ONE_MINUS_DST_COLOR,
                    207: e.ONE_MINUS_DST_ALPHA,
                    211: e.CONSTANT_COLOR,
                    212: e.ONE_MINUS_CONSTANT_COLOR,
                    213: e.CONSTANT_ALPHA,
                    214: e.ONE_MINUS_CONSTANT_ALPHA
                };
                function X(t, n, r, i, a, s, o, l, c, u) {
                    if (0 !== t) {
                        if (!1 === f && (G(e.BLEND),
                        f = !0),
                        5 === t)
                            a = a || n,
                            s = s || r,
                            o = o || i,
                            n === g && a === y || (e.blendEquationSeparate(W[n], W[a]),
                            g = n,
                            y = a),
                            r === v && i === _ && s === x && o === b || (e.blendFuncSeparate(j[r], j[i], j[s], j[o]),
                            v = r,
                            _ = i,
                            x = s,
                            b = o),
                            !1 !== l.equals(E) && c === S || (e.blendColor(l.r, l.g, l.b, c),
                            E.copy(l),
                            S = c),
                            m = t,
                            w = !1;
                        else if (t !== m || u !== w) {
                            if (g === fa && y === fa || (e.blendEquation(e.FUNC_ADD),
                            g = fa,
                            y = fa),
                            u)
                                switch (t) {
                                case 1:
                                    e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                    break;
                                case 2:
                                    e.blendFunc(e.ONE, e.ONE);
                                    break;
                                case 3:
                                    e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                                    break;
                                case 4:
                                    e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", t)
                                }
                            else
                                switch (t) {
                                case 1:
                                    e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                    break;
                                case 2:
                                    e.blendFunc(e.SRC_ALPHA, e.ONE);
                                    break;
                                case 3:
                                    e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                                    break;
                                case 4:
                                    e.blendFunc(e.ZERO, e.SRC_COLOR);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", t)
                                }
                            v = null,
                            _ = null,
                            x = null,
                            b = null,
                            E.set(0, 0, 0),
                            S = 0,
                            m = t,
                            w = u
                        }
                    } else
                        !0 === f && (V(e.BLEND),
                        f = !1)
                }
                function q(t) {
                    M !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW),
                    M = t)
                }
                function Y(t) {
                    0 !== t ? (G(e.CULL_FACE),
                    t !== T && (1 === t ? e.cullFace(e.BACK) : 2 === t ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : V(e.CULL_FACE),
                    T = t
                }
                function $(t, n, r) {
                    t ? (G(e.POLYGON_OFFSET_FILL),
                    C === n && P === r || (e.polygonOffset(n, r),
                    C = n,
                    P = r)) : V(e.POLYGON_OFFSET_FILL)
                }
                return {
                    buffers: {
                        color: i,
                        depth: a,
                        stencil: s
                    },
                    enable: G,
                    disable: V,
                    bindFramebuffer: function(t, n) {
                        return u[t] !== n && (e.bindFramebuffer(t, n),
                        u[t] = n,
                        r && (t === e.DRAW_FRAMEBUFFER && (u[e.FRAMEBUFFER] = n),
                        t === e.FRAMEBUFFER && (u[e.DRAW_FRAMEBUFFER] = n)),
                        !0)
                    },
                    drawBuffers: function(r, i) {
                        let a = h
                          , s = !1;
                        if (r) {
                            a = d.get(i),
                            void 0 === a && (a = [],
                            d.set(i, a));
                            const t = r.textures;
                            if (a.length !== t.length || a[0] !== e.COLOR_ATTACHMENT0) {
                                for (let n = 0, r = t.length; n < r; n++)
                                    a[n] = e.COLOR_ATTACHMENT0 + n;
                                a.length = t.length,
                                s = !0
                            }
                        } else
                            a[0] !== e.BACK && (a[0] = e.BACK,
                            s = !0);
                        if (s)
                            if (n.isWebGL2)
                                e.drawBuffers(a);
                            else {
                                if (!0 !== t.has("WEBGL_draw_buffers"))
                                    throw new Error("THREE.WebGLState: Usage of gl.drawBuffers() require WebGL2 or WEBGL_draw_buffers extension");
                                t.get("WEBGL_draw_buffers").drawBuffersWEBGL(a)
                            }
                    },
                    useProgram: function(t) {
                        return p !== t && (e.useProgram(t),
                        p = t,
                        !0)
                    },
                    setBlending: X,
                    setMaterial: function(t, n) {
                        2 === t.side ? V(e.CULL_FACE) : G(e.CULL_FACE);
                        let r = t.side === pa;
                        n && (r = !r),
                        q(r),
                        1 === t.blending && !1 === t.transparent ? X(0) : X(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.blendColor, t.blendAlpha, t.premultipliedAlpha),
                        a.setFunc(t.depthFunc),
                        a.setTest(t.depthTest),
                        a.setMask(t.depthWrite),
                        i.setMask(t.colorWrite);
                        const o = t.stencilWrite;
                        s.setTest(o),
                        o && (s.setMask(t.stencilWriteMask),
                        s.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
                        s.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
                        $(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),
                        !0 === t.alphaToCoverage ? G(e.SAMPLE_ALPHA_TO_COVERAGE) : V(e.SAMPLE_ALPHA_TO_COVERAGE)
                    },
                    setFlipSided: q,
                    setCullFace: Y,
                    setLineWidth: function(t) {
                        t !== A && (L && e.lineWidth(t),
                        A = t)
                    },
                    setPolygonOffset: $,
                    setScissorTest: function(t) {
                        t ? G(e.SCISSOR_TEST) : V(e.SCISSOR_TEST)
                    },
                    activeTexture: function(t) {
                        void 0 === t && (t = e.TEXTURE0 + R - 1),
                        I !== t && (e.activeTexture(t),
                        I = t)
                    },
                    bindTexture: function(t, n, r) {
                        void 0 === r && (r = null === I ? e.TEXTURE0 + R - 1 : I);
                        let i = N[r];
                        void 0 === i && (i = {
                            type: void 0,
                            texture: void 0
                        },
                        N[r] = i),
                        i.type === t && i.texture === n || (I !== r && (e.activeTexture(r),
                        I = r),
                        e.bindTexture(t, n || H[t]),
                        i.type = t,
                        i.texture = n)
                    },
                    unbindTexture: function() {
                        const t = N[I];
                        void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null),
                        t.type = void 0,
                        t.texture = void 0)
                    },
                    compressedTexImage2D: function() {
                        try {
                            e.compressedTexImage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    compressedTexImage3D: function() {
                        try {
                            e.compressedTexImage3D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texImage2D: function() {
                        try {
                            e.texImage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texImage3D: function() {
                        try {
                            e.texImage3D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    updateUBOMapping: function(t, n) {
                        let r = l.get(n);
                        void 0 === r && (r = new WeakMap,
                        l.set(n, r));
                        let i = r.get(t);
                        void 0 === i && (i = e.getUniformBlockIndex(n, t.name),
                        r.set(t, i))
                    },
                    uniformBlockBinding: function(t, n) {
                        const r = l.get(n).get(t);
                        o.get(n) !== r && (e.uniformBlockBinding(n, r, t.__bindingPointIndex),
                        o.set(n, r))
                    },
                    texStorage2D: function() {
                        try {
                            e.texStorage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texStorage3D: function() {
                        try {
                            e.texStorage3D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texSubImage2D: function() {
                        try {
                            e.texSubImage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texSubImage3D: function() {
                        try {
                            e.texSubImage3D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    compressedTexSubImage2D: function() {
                        try {
                            e.compressedTexSubImage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    compressedTexSubImage3D: function() {
                        try {
                            e.compressedTexSubImage3D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    scissor: function(t) {
                        !1 === F.equals(t) && (e.scissor(t.x, t.y, t.z, t.w),
                        F.copy(t))
                    },
                    viewport: function(t) {
                        !1 === z.equals(t) && (e.viewport(t.x, t.y, t.z, t.w),
                        z.copy(t))
                    },
                    reset: function() {
                        e.disable(e.BLEND),
                        e.disable(e.CULL_FACE),
                        e.disable(e.DEPTH_TEST),
                        e.disable(e.POLYGON_OFFSET_FILL),
                        e.disable(e.SCISSOR_TEST),
                        e.disable(e.STENCIL_TEST),
                        e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),
                        e.blendEquation(e.FUNC_ADD),
                        e.blendFunc(e.ONE, e.ZERO),
                        e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO),
                        e.blendColor(0, 0, 0, 0),
                        e.colorMask(!0, !0, !0, !0),
                        e.clearColor(0, 0, 0, 0),
                        e.depthMask(!0),
                        e.depthFunc(e.LESS),
                        e.clearDepth(1),
                        e.stencilMask(4294967295),
                        e.stencilFunc(e.ALWAYS, 0, 4294967295),
                        e.stencilOp(e.KEEP, e.KEEP, e.KEEP),
                        e.clearStencil(0),
                        e.cullFace(e.BACK),
                        e.frontFace(e.CCW),
                        e.polygonOffset(0, 0),
                        e.activeTexture(e.TEXTURE0),
                        e.bindFramebuffer(e.FRAMEBUFFER, null),
                        !0 === r && (e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
                        e.bindFramebuffer(e.READ_FRAMEBUFFER, null)),
                        e.useProgram(null),
                        e.lineWidth(1),
                        e.scissor(0, 0, e.canvas.width, e.canvas.height),
                        e.viewport(0, 0, e.canvas.width, e.canvas.height),
                        c = {},
                        I = null,
                        N = {},
                        u = {},
                        d = new WeakMap,
                        h = [],
                        p = null,
                        f = !1,
                        m = null,
                        g = null,
                        v = null,
                        _ = null,
                        y = null,
                        x = null,
                        b = null,
                        E = new Cl(0,0,0),
                        S = 0,
                        w = !1,
                        M = null,
                        T = null,
                        A = null,
                        C = null,
                        P = null,
                        F.set(0, 0, e.canvas.width, e.canvas.height),
                        z.set(0, 0, e.canvas.width, e.canvas.height),
                        i.reset(),
                        a.reset(),
                        s.reset()
                    }
                }
            }
            function uh(e, t, n, r, i, a, s) {
                const o = i.isWebGL2
                  , l = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null
                  , c = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent)
                  , u = new Is
                  , d = new WeakMap;
                let h;
                const p = new WeakMap;
                let f = !1;
                try {
                    f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1,1).getContext("2d")
                } catch (e) {}
                function m(e, t) {
                    return f ? new OffscreenCanvas(e,t) : Fs("canvas")
                }
                function g(e, t, n, r) {
                    let i = 1;
                    const a = B(e);
                    if ((a.width > r || a.height > r) && (i = r / Math.max(a.width, a.height)),
                    i < 1 || !0 === t) {
                        if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap || "undefined" != typeof VideoFrame && e instanceof VideoFrame) {
                            const r = t ? Ls : Math.floor
                              , s = r(i * a.width)
                              , o = r(i * a.height);
                            void 0 === h && (h = m(s, o));
                            const l = n ? m(s, o) : h;
                            l.width = s,
                            l.height = o;
                            return l.getContext("2d").drawImage(e, 0, 0, s, o),
                            console.warn("THREE.WebGLRenderer: Texture has been resized from (" + a.width + "x" + a.height + ") to (" + s + "x" + o + ")."),
                            l
                        }
                        return "data"in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + a.width + "x" + a.height + ")."),
                        e
                    }
                    return e
                }
                function v(e) {
                    const t = B(e);
                    return Rs(t.width) && Rs(t.height)
                }
                function _(e, t) {
                    return e.generateMipmaps && t && e.minFilter !== Ia && e.minFilter !== ka
                }
                function y(t) {
                    e.generateMipmap(t)
                }
                function x(n, r, i, a, s=!1) {
                    if (!1 === o)
                        return r;
                    if (null !== n) {
                        if (void 0 !== e[n])
                            return e[n];
                        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                    }
                    let l = r;
                    if (r === e.RED && (i === e.FLOAT && (l = e.R32F),
                    i === e.HALF_FLOAT && (l = e.R16F),
                    i === e.UNSIGNED_BYTE && (l = e.R8)),
                    r === e.RED_INTEGER && (i === e.UNSIGNED_BYTE && (l = e.R8UI),
                    i === e.UNSIGNED_SHORT && (l = e.R16UI),
                    i === e.UNSIGNED_INT && (l = e.R32UI),
                    i === e.BYTE && (l = e.R8I),
                    i === e.SHORT && (l = e.R16I),
                    i === e.INT && (l = e.R32I)),
                    r === e.RG && (i === e.FLOAT && (l = e.RG32F),
                    i === e.HALF_FLOAT && (l = e.RG16F),
                    i === e.UNSIGNED_BYTE && (l = e.RG8)),
                    r === e.RG_INTEGER && (i === e.UNSIGNED_BYTE && (l = e.RG8UI),
                    i === e.UNSIGNED_SHORT && (l = e.RG16UI),
                    i === e.UNSIGNED_INT && (l = e.RG32UI),
                    i === e.BYTE && (l = e.RG8I),
                    i === e.SHORT && (l = e.RG16I),
                    i === e.INT && (l = e.RG32I)),
                    r === e.RGBA) {
                        const t = s ? hs : Xs.getTransfer(a);
                        i === e.FLOAT && (l = e.RGBA32F),
                        i === e.HALF_FLOAT && (l = e.RGBA16F),
                        i === e.UNSIGNED_BYTE && (l = t === ps ? e.SRGB8_ALPHA8 : e.RGBA8),
                        i === e.UNSIGNED_SHORT_4_4_4_4 && (l = e.RGBA4),
                        i === e.UNSIGNED_SHORT_5_5_5_1 && (l = e.RGB5_A1)
                    }
                    return l !== e.R16F && l !== e.R32F && l !== e.RG16F && l !== e.RG32F && l !== e.RGBA16F && l !== e.RGBA32F || t.get("EXT_color_buffer_float"),
                    l
                }
                function b(e, t, n) {
                    return !0 === _(e, n) || e.isFramebufferTexture && e.minFilter !== Ia && e.minFilter !== ka ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1
                }
                function E(t) {
                    return t === Ia || t === Na || t === Ua ? e.NEAREST : e.LINEAR
                }
                function S(e) {
                    const t = e.target;
                    t.removeEventListener("dispose", S),
                    function(e) {
                        const t = r.get(e);
                        if (void 0 === t.__webglInit)
                            return;
                        const n = e.source
                          , i = p.get(n);
                        if (i) {
                            const r = i[t.__cacheKey];
                            r.usedTimes--,
                            0 === r.usedTimes && M(e),
                            0 === Object.keys(i).length && p.delete(n)
                        }
                        r.remove(e)
                    }(t),
                    t.isVideoTexture && d.delete(t)
                }
                function w(t) {
                    const n = t.target;
                    n.removeEventListener("dispose", w),
                    function(t) {
                        const n = r.get(t);
                        t.depthTexture && t.depthTexture.dispose();
                        if (t.isWebGLCubeRenderTarget)
                            for (let t = 0; t < 6; t++) {
                                if (Array.isArray(n.__webglFramebuffer[t]))
                                    for (let r = 0; r < n.__webglFramebuffer[t].length; r++)
                                        e.deleteFramebuffer(n.__webglFramebuffer[t][r]);
                                else
                                    e.deleteFramebuffer(n.__webglFramebuffer[t]);
                                n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer[t])
                            }
                        else {
                            if (Array.isArray(n.__webglFramebuffer))
                                for (let t = 0; t < n.__webglFramebuffer.length; t++)
                                    e.deleteFramebuffer(n.__webglFramebuffer[t]);
                            else
                                e.deleteFramebuffer(n.__webglFramebuffer);
                            if (n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer),
                            n.__webglMultisampledFramebuffer && e.deleteFramebuffer(n.__webglMultisampledFramebuffer),
                            n.__webglColorRenderbuffer)
                                for (let t = 0; t < n.__webglColorRenderbuffer.length; t++)
                                    n.__webglColorRenderbuffer[t] && e.deleteRenderbuffer(n.__webglColorRenderbuffer[t]);
                            n.__webglDepthRenderbuffer && e.deleteRenderbuffer(n.__webglDepthRenderbuffer)
                        }
                        const i = t.textures;
                        for (let t = 0, n = i.length; t < n; t++) {
                            const n = r.get(i[t]);
                            n.__webglTexture && (e.deleteTexture(n.__webglTexture),
                            s.memory.textures--),
                            r.remove(i[t])
                        }
                        r.remove(t)
                    }(n)
                }
                function M(t) {
                    const n = r.get(t);
                    e.deleteTexture(n.__webglTexture);
                    const i = t.source;
                    delete p.get(i)[n.__cacheKey],
                    s.memory.textures--
                }
                let T = 0;
                function A(t, i) {
                    const a = r.get(t);
                    if (t.isVideoTexture && function(e) {
                        const t = s.render.frame;
                        d.get(e) !== t && (d.set(e, t),
                        e.update())
                    }(t),
                    !1 === t.isRenderTargetTexture && t.version > 0 && a.__version !== t.version) {
                        const e = t.image;
                        if (null === e)
                            console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                        else {
                            if (!1 !== e.complete)
                                return void D(a, t, i);
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                        }
                    }
                    n.bindTexture(e.TEXTURE_2D, a.__webglTexture, e.TEXTURE0 + i)
                }
                const C = {
                    [La]: e.REPEAT,
                    [Oa]: e.CLAMP_TO_EDGE,
                    [Da]: e.MIRRORED_REPEAT
                }
                  , P = {
                    [Ia]: e.NEAREST,
                    [Na]: e.NEAREST_MIPMAP_NEAREST,
                    [Ua]: e.NEAREST_MIPMAP_LINEAR,
                    [ka]: e.LINEAR,
                    [Fa]: e.LINEAR_MIPMAP_NEAREST,
                    [za]: e.LINEAR_MIPMAP_LINEAR
                }
                  , R = {
                    512: e.NEVER,
                    519: e.ALWAYS,
                    513: e.LESS,
                    515: e.LEQUAL,
                    514: e.EQUAL,
                    518: e.GEQUAL,
                    516: e.GREATER,
                    517: e.NOTEQUAL
                };
                function L(n, a, s) {
                    if (a.type !== Wa || !1 !== t.has("OES_texture_float_linear") || a.magFilter !== ka && a.magFilter !== Fa && a.magFilter !== Ua && a.magFilter !== za && a.minFilter !== ka && a.minFilter !== Fa && a.minFilter !== Ua && a.minFilter !== za || console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),
                    s ? (e.texParameteri(n, e.TEXTURE_WRAP_S, C[a.wrapS]),
                    e.texParameteri(n, e.TEXTURE_WRAP_T, C[a.wrapT]),
                    n !== e.TEXTURE_3D && n !== e.TEXTURE_2D_ARRAY || e.texParameteri(n, e.TEXTURE_WRAP_R, C[a.wrapR]),
                    e.texParameteri(n, e.TEXTURE_MAG_FILTER, P[a.magFilter]),
                    e.texParameteri(n, e.TEXTURE_MIN_FILTER, P[a.minFilter])) : (e.texParameteri(n, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
                    e.texParameteri(n, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
                    n !== e.TEXTURE_3D && n !== e.TEXTURE_2D_ARRAY || e.texParameteri(n, e.TEXTURE_WRAP_R, e.CLAMP_TO_EDGE),
                    a.wrapS === Oa && a.wrapT === Oa || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
                    e.texParameteri(n, e.TEXTURE_MAG_FILTER, E(a.magFilter)),
                    e.texParameteri(n, e.TEXTURE_MIN_FILTER, E(a.minFilter)),
                    a.minFilter !== Ia && a.minFilter !== ka && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
                    a.compareFunction && (e.texParameteri(n, e.TEXTURE_COMPARE_MODE, e.COMPARE_REF_TO_TEXTURE),
                    e.texParameteri(n, e.TEXTURE_COMPARE_FUNC, R[a.compareFunction])),
                    !0 === t.has("EXT_texture_filter_anisotropic")) {
                        if (a.magFilter === Ia)
                            return;
                        if (a.minFilter !== Ua && a.minFilter !== za)
                            return;
                        if (a.type === Wa && !1 === t.has("OES_texture_float_linear"))
                            return;
                        if (!1 === o && a.type === ja && !1 === t.has("OES_texture_half_float_linear"))
                            return;
                        if (a.anisotropy > 1 || r.get(a).__currentAnisotropy) {
                            const s = t.get("EXT_texture_filter_anisotropic");
                            e.texParameterf(n, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, i.getMaxAnisotropy())),
                            r.get(a).__currentAnisotropy = a.anisotropy
                        }
                    }
                }
                function O(t, n) {
                    let r = !1;
                    void 0 === t.__webglInit && (t.__webglInit = !0,
                    n.addEventListener("dispose", S));
                    const i = n.source;
                    let a = p.get(i);
                    void 0 === a && (a = {},
                    p.set(i, a));
                    const o = function(e) {
                        const t = [];
                        return t.push(e.wrapS),
                        t.push(e.wrapT),
                        t.push(e.wrapR || 0),
                        t.push(e.magFilter),
                        t.push(e.minFilter),
                        t.push(e.anisotropy),
                        t.push(e.internalFormat),
                        t.push(e.format),
                        t.push(e.type),
                        t.push(e.generateMipmaps),
                        t.push(e.premultiplyAlpha),
                        t.push(e.flipY),
                        t.push(e.unpackAlignment),
                        t.push(e.colorSpace),
                        t.join()
                    }(n);
                    if (o !== t.__cacheKey) {
                        void 0 === a[o] && (a[o] = {
                            texture: e.createTexture(),
                            usedTimes: 0
                        },
                        s.memory.textures++,
                        r = !0),
                        a[o].usedTimes++;
                        const i = a[t.__cacheKey];
                        void 0 !== i && (a[t.__cacheKey].usedTimes--,
                        0 === i.usedTimes && M(n)),
                        t.__cacheKey = o,
                        t.__webglTexture = a[o].texture
                    }
                    return r
                }
                function D(t, s, l) {
                    let c = e.TEXTURE_2D;
                    (s.isDataArrayTexture || s.isCompressedArrayTexture) && (c = e.TEXTURE_2D_ARRAY),
                    s.isData3DTexture && (c = e.TEXTURE_3D);
                    const u = O(t, s)
                      , d = s.source;
                    n.bindTexture(c, t.__webglTexture, e.TEXTURE0 + l);
                    const h = r.get(d);
                    if (d.version !== h.__version || !0 === u) {
                        n.activeTexture(e.TEXTURE0 + l);
                        const t = Xs.getPrimaries(Xs.workingColorSpace)
                          , r = s.colorSpace === os ? null : Xs.getPrimaries(s.colorSpace)
                          , p = s.colorSpace === os || t === r ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                        e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, s.flipY),
                        e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s.premultiplyAlpha),
                        e.pixelStorei(e.UNPACK_ALIGNMENT, s.unpackAlignment),
                        e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, p);
                        const f = function(e) {
                            return !o && (e.wrapS !== Oa || e.wrapT !== Oa || e.minFilter !== Ia && e.minFilter !== ka)
                        }(s) && !1 === v(s.image);
                        let m = g(s.image, f, !1, i.maxTextureSize);
                        m = z(s, m);
                        const E = v(m) || o
                          , S = a.convert(s.format, s.colorSpace);
                        let w, M = a.convert(s.type), T = x(s.internalFormat, S, M, s.colorSpace, s.isVideoTexture);
                        L(c, s, E);
                        const A = s.mipmaps
                          , C = o && !0 !== s.isVideoTexture && 36196 !== T
                          , P = void 0 === h.__version || !0 === u
                          , R = d.dataReady
                          , O = b(s, m, E);
                        if (s.isDepthTexture)
                            T = e.DEPTH_COMPONENT,
                            o ? T = s.type === Wa ? e.DEPTH_COMPONENT32F : s.type === Va ? e.DEPTH_COMPONENT24 : s.type === Xa ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT16 : s.type === Wa && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                            s.format === Ya && T === e.DEPTH_COMPONENT && s.type !== Ha && s.type !== Va && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                            s.type = Va,
                            M = a.convert(s.type)),
                            s.format === $a && T === e.DEPTH_COMPONENT && (T = e.DEPTH_STENCIL,
                            s.type !== Xa && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                            s.type = Xa,
                            M = a.convert(s.type))),
                            P && (C ? n.texStorage2D(e.TEXTURE_2D, 1, T, m.width, m.height) : n.texImage2D(e.TEXTURE_2D, 0, T, m.width, m.height, 0, S, M, null));
                        else if (s.isDataTexture)
                            if (A.length > 0 && E) {
                                C && P && n.texStorage2D(e.TEXTURE_2D, O, T, A[0].width, A[0].height);
                                for (let t = 0, r = A.length; t < r; t++)
                                    w = A[t],
                                    C ? R && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, w.width, w.height, S, M, w.data) : n.texImage2D(e.TEXTURE_2D, t, T, w.width, w.height, 0, S, M, w.data);
                                s.generateMipmaps = !1
                            } else
                                C ? (P && n.texStorage2D(e.TEXTURE_2D, O, T, m.width, m.height),
                                R && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, m.width, m.height, S, M, m.data)) : n.texImage2D(e.TEXTURE_2D, 0, T, m.width, m.height, 0, S, M, m.data);
                        else if (s.isCompressedTexture)
                            if (s.isCompressedArrayTexture) {
                                C && P && n.texStorage3D(e.TEXTURE_2D_ARRAY, O, T, A[0].width, A[0].height, m.depth);
                                for (let t = 0, r = A.length; t < r; t++)
                                    w = A[t],
                                    s.format !== qa ? null !== S ? C ? R && n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, w.width, w.height, m.depth, S, w.data, 0, 0) : n.compressedTexImage3D(e.TEXTURE_2D_ARRAY, t, T, w.width, w.height, m.depth, 0, w.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : C ? R && n.texSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, w.width, w.height, m.depth, S, M, w.data) : n.texImage3D(e.TEXTURE_2D_ARRAY, t, T, w.width, w.height, m.depth, 0, S, M, w.data)
                            } else {
                                C && P && n.texStorage2D(e.TEXTURE_2D, O, T, A[0].width, A[0].height);
                                for (let t = 0, r = A.length; t < r; t++)
                                    w = A[t],
                                    s.format !== qa ? null !== S ? C ? R && n.compressedTexSubImage2D(e.TEXTURE_2D, t, 0, 0, w.width, w.height, S, w.data) : n.compressedTexImage2D(e.TEXTURE_2D, t, T, w.width, w.height, 0, w.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : C ? R && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, w.width, w.height, S, M, w.data) : n.texImage2D(e.TEXTURE_2D, t, T, w.width, w.height, 0, S, M, w.data)
                            }
                        else if (s.isDataArrayTexture)
                            C ? (P && n.texStorage3D(e.TEXTURE_2D_ARRAY, O, T, m.width, m.height, m.depth),
                            R && n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, 0, m.width, m.height, m.depth, S, M, m.data)) : n.texImage3D(e.TEXTURE_2D_ARRAY, 0, T, m.width, m.height, m.depth, 0, S, M, m.data);
                        else if (s.isData3DTexture)
                            C ? (P && n.texStorage3D(e.TEXTURE_3D, O, T, m.width, m.height, m.depth),
                            R && n.texSubImage3D(e.TEXTURE_3D, 0, 0, 0, 0, m.width, m.height, m.depth, S, M, m.data)) : n.texImage3D(e.TEXTURE_3D, 0, T, m.width, m.height, m.depth, 0, S, M, m.data);
                        else if (s.isFramebufferTexture) {
                            if (P)
                                if (C)
                                    n.texStorage2D(e.TEXTURE_2D, O, T, m.width, m.height);
                                else {
                                    let t = m.width
                                      , r = m.height;
                                    for (let i = 0; i < O; i++)
                                        n.texImage2D(e.TEXTURE_2D, i, T, t, r, 0, S, M, null),
                                        t >>= 1,
                                        r >>= 1
                                }
                        } else if (A.length > 0 && E) {
                            if (C && P) {
                                const t = B(A[0]);
                                n.texStorage2D(e.TEXTURE_2D, O, T, t.width, t.height)
                            }
                            for (let t = 0, r = A.length; t < r; t++)
                                w = A[t],
                                C ? R && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, S, M, w) : n.texImage2D(e.TEXTURE_2D, t, T, S, M, w);
                            s.generateMipmaps = !1
                        } else if (C) {
                            if (P) {
                                const t = B(m);
                                n.texStorage2D(e.TEXTURE_2D, O, T, t.width, t.height)
                            }
                            R && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, S, M, m)
                        } else
                            n.texImage2D(e.TEXTURE_2D, 0, T, S, M, m);
                        _(s, E) && y(c),
                        h.__version = d.version,
                        s.onUpdate && s.onUpdate(s)
                    }
                    t.__version = s.version
                }
                function I(t, i, s, o, c, u) {
                    const d = a.convert(s.format, s.colorSpace)
                      , h = a.convert(s.type)
                      , p = x(s.internalFormat, d, h, s.colorSpace);
                    if (!r.get(i).__hasExternalTextures) {
                        const t = Math.max(1, i.width >> u)
                          , r = Math.max(1, i.height >> u);
                        c === e.TEXTURE_3D || c === e.TEXTURE_2D_ARRAY ? n.texImage3D(c, u, p, t, r, i.depth, 0, d, h, null) : n.texImage2D(c, u, p, t, r, 0, d, h, null)
                    }
                    n.bindFramebuffer(e.FRAMEBUFFER, t),
                    F(i) ? l.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, o, c, r.get(s).__webglTexture, 0, k(i)) : (c === e.TEXTURE_2D || c >= e.TEXTURE_CUBE_MAP_POSITIVE_X && c <= e.TEXTURE_CUBE_MAP_NEGATIVE_Z) && e.framebufferTexture2D(e.FRAMEBUFFER, o, c, r.get(s).__webglTexture, u),
                    n.bindFramebuffer(e.FRAMEBUFFER, null)
                }
                function N(t, n, r) {
                    if (e.bindRenderbuffer(e.RENDERBUFFER, t),
                    n.depthBuffer && !n.stencilBuffer) {
                        let i = !0 === o ? e.DEPTH_COMPONENT24 : e.DEPTH_COMPONENT16;
                        if (r || F(n)) {
                            const t = n.depthTexture;
                            t && t.isDepthTexture && (t.type === Wa ? i = e.DEPTH_COMPONENT32F : t.type === Va && (i = e.DEPTH_COMPONENT24));
                            const r = k(n);
                            F(n) ? l.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, r, i, n.width, n.height) : e.renderbufferStorageMultisample(e.RENDERBUFFER, r, i, n.width, n.height)
                        } else
                            e.renderbufferStorage(e.RENDERBUFFER, i, n.width, n.height);
                        e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, t)
                    } else if (n.depthBuffer && n.stencilBuffer) {
                        const i = k(n);
                        r && !1 === F(n) ? e.renderbufferStorageMultisample(e.RENDERBUFFER, i, e.DEPTH24_STENCIL8, n.width, n.height) : F(n) ? l.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, i, e.DEPTH24_STENCIL8, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, n.width, n.height),
                        e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, t)
                    } else {
                        const t = n.textures;
                        for (let i = 0; i < t.length; i++) {
                            const s = t[i]
                              , o = a.convert(s.format, s.colorSpace)
                              , c = a.convert(s.type)
                              , u = x(s.internalFormat, o, c, s.colorSpace)
                              , d = k(n);
                            r && !1 === F(n) ? e.renderbufferStorageMultisample(e.RENDERBUFFER, d, u, n.width, n.height) : F(n) ? l.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, d, u, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, u, n.width, n.height)
                        }
                    }
                    e.bindRenderbuffer(e.RENDERBUFFER, null)
                }
                function U(t) {
                    const i = r.get(t)
                      , a = !0 === t.isWebGLCubeRenderTarget;
                    if (t.depthTexture && !i.__autoAllocateDepthBuffer) {
                        if (a)
                            throw new Error("target.depthTexture not supported in Cube render targets");
                        !function(t, i) {
                            if (i && i.isWebGLCubeRenderTarget)
                                throw new Error("Depth Texture with cube render targets is not supported");
                            if (n.bindFramebuffer(e.FRAMEBUFFER, t),
                            !i.depthTexture || !i.depthTexture.isDepthTexture)
                                throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            r.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width,
                            i.depthTexture.image.height = i.height,
                            i.depthTexture.needsUpdate = !0),
                            A(i.depthTexture, 0);
                            const a = r.get(i.depthTexture).__webglTexture
                              , s = k(i);
                            if (i.depthTexture.format === Ya)
                                F(i) ? l.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, a, 0, s) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, a, 0);
                            else {
                                if (i.depthTexture.format !== $a)
                                    throw new Error("Unknown depthTexture format");
                                F(i) ? l.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, a, 0, s) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, a, 0)
                            }
                        }(i.__webglFramebuffer, t)
                    } else if (a) {
                        i.__webglDepthbuffer = [];
                        for (let r = 0; r < 6; r++)
                            n.bindFramebuffer(e.FRAMEBUFFER, i.__webglFramebuffer[r]),
                            i.__webglDepthbuffer[r] = e.createRenderbuffer(),
                            N(i.__webglDepthbuffer[r], t, !1)
                    } else
                        n.bindFramebuffer(e.FRAMEBUFFER, i.__webglFramebuffer),
                        i.__webglDepthbuffer = e.createRenderbuffer(),
                        N(i.__webglDepthbuffer, t, !1);
                    n.bindFramebuffer(e.FRAMEBUFFER, null)
                }
                function k(e) {
                    return Math.min(i.maxSamples, e.samples)
                }
                function F(e) {
                    const n = r.get(e);
                    return o && e.samples > 0 && !0 === t.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture
                }
                function z(e, n) {
                    const r = e.colorSpace
                      , i = e.format
                      , a = e.type;
                    return !0 === e.isCompressedTexture || !0 === e.isVideoTexture || e.format === ys || r !== cs && r !== os && (Xs.getTransfer(r) === ps ? !1 === o ? !0 === t.has("EXT_sRGB") && i === qa ? (e.format = ys,
                    e.minFilter = ka,
                    e.generateMipmaps = !1) : n = Ks.sRGBToLinear(n) : i === qa && a === Ba || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", r)),
                    n
                }
                function B(e) {
                    return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement ? (u.width = e.naturalWidth || e.width,
                    u.height = e.naturalHeight || e.height) : "undefined" != typeof VideoFrame && e instanceof VideoFrame ? (u.width = e.displayWidth,
                    u.height = e.displayHeight) : (u.width = e.width,
                    u.height = e.height),
                    u
                }
                this.allocateTextureUnit = function() {
                    const e = T;
                    return e >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + i.maxTextures),
                    T += 1,
                    e
                }
                ,
                this.resetTextureUnits = function() {
                    T = 0
                }
                ,
                this.setTexture2D = A,
                this.setTexture2DArray = function(t, i) {
                    const a = r.get(t);
                    t.version > 0 && a.__version !== t.version ? D(a, t, i) : n.bindTexture(e.TEXTURE_2D_ARRAY, a.__webglTexture, e.TEXTURE0 + i)
                }
                ,
                this.setTexture3D = function(t, i) {
                    const a = r.get(t);
                    t.version > 0 && a.__version !== t.version ? D(a, t, i) : n.bindTexture(e.TEXTURE_3D, a.__webglTexture, e.TEXTURE0 + i)
                }
                ,
                this.setTextureCube = function(t, s) {
                    const l = r.get(t);
                    t.version > 0 && l.__version !== t.version ? function(t, s, l) {
                        if (6 !== s.image.length)
                            return;
                        const c = O(t, s)
                          , u = s.source;
                        n.bindTexture(e.TEXTURE_CUBE_MAP, t.__webglTexture, e.TEXTURE0 + l);
                        const d = r.get(u);
                        if (u.version !== d.__version || !0 === c) {
                            n.activeTexture(e.TEXTURE0 + l);
                            const t = Xs.getPrimaries(Xs.workingColorSpace)
                              , r = s.colorSpace === os ? null : Xs.getPrimaries(s.colorSpace)
                              , h = s.colorSpace === os || t === r ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                            e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, s.flipY),
                            e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s.premultiplyAlpha),
                            e.pixelStorei(e.UNPACK_ALIGNMENT, s.unpackAlignment),
                            e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, h);
                            const p = s.isCompressedTexture || s.image[0].isCompressedTexture
                              , f = s.image[0] && s.image[0].isDataTexture
                              , m = [];
                            for (let e = 0; e < 6; e++)
                                m[e] = p || f ? f ? s.image[e].image : s.image[e] : g(s.image[e], !1, !0, i.maxCubemapSize),
                                m[e] = z(s, m[e]);
                            const E = m[0]
                              , S = v(E) || o
                              , w = a.convert(s.format, s.colorSpace)
                              , M = a.convert(s.type)
                              , T = x(s.internalFormat, w, M, s.colorSpace)
                              , A = o && !0 !== s.isVideoTexture
                              , C = void 0 === d.__version || !0 === c
                              , P = u.dataReady;
                            let R, O = b(s, E, S);
                            if (L(e.TEXTURE_CUBE_MAP, s, S),
                            p) {
                                A && C && n.texStorage2D(e.TEXTURE_CUBE_MAP, O, T, E.width, E.height);
                                for (let t = 0; t < 6; t++) {
                                    R = m[t].mipmaps;
                                    for (let r = 0; r < R.length; r++) {
                                        const i = R[r];
                                        s.format !== qa ? null !== w ? A ? P && n.compressedTexSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r, 0, 0, i.width, i.height, w, i.data) : n.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r, T, i.width, i.height, 0, i.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : A ? P && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r, 0, 0, i.width, i.height, w, M, i.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r, T, i.width, i.height, 0, w, M, i.data)
                                    }
                                }
                            } else {
                                if (R = s.mipmaps,
                                A && C) {
                                    R.length > 0 && O++;
                                    const t = B(m[0]);
                                    n.texStorage2D(e.TEXTURE_CUBE_MAP, O, T, t.width, t.height)
                                }
                                for (let t = 0; t < 6; t++)
                                    if (f) {
                                        A ? P && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, m[t].width, m[t].height, w, M, m[t].data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, T, m[t].width, m[t].height, 0, w, M, m[t].data);
                                        for (let r = 0; r < R.length; r++) {
                                            const i = R[r].image[t].image;
                                            A ? P && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r + 1, 0, 0, i.width, i.height, w, M, i.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r + 1, T, i.width, i.height, 0, w, M, i.data)
                                        }
                                    } else {
                                        A ? P && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, w, M, m[t]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, T, w, M, m[t]);
                                        for (let r = 0; r < R.length; r++) {
                                            const i = R[r];
                                            A ? P && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r + 1, 0, 0, w, M, i.image[t]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r + 1, T, w, M, i.image[t])
                                        }
                                    }
                            }
                            _(s, S) && y(e.TEXTURE_CUBE_MAP),
                            d.__version = u.version,
                            s.onUpdate && s.onUpdate(s)
                        }
                        t.__version = s.version
                    }(l, t, s) : n.bindTexture(e.TEXTURE_CUBE_MAP, l.__webglTexture, e.TEXTURE0 + s)
                }
                ,
                this.rebindTextures = function(t, n, i) {
                    const a = r.get(t);
                    void 0 !== n && I(a.__webglFramebuffer, t, t.texture, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, 0),
                    void 0 !== i && U(t)
                }
                ,
                this.setupRenderTarget = function(t) {
                    const l = t.texture
                      , c = r.get(t)
                      , u = r.get(l);
                    t.addEventListener("dispose", w);
                    const d = t.textures
                      , h = !0 === t.isWebGLCubeRenderTarget
                      , p = d.length > 1
                      , f = v(t) || o;
                    if (p || (void 0 === u.__webglTexture && (u.__webglTexture = e.createTexture()),
                    u.__version = l.version,
                    s.memory.textures++),
                    h) {
                        c.__webglFramebuffer = [];
                        for (let t = 0; t < 6; t++)
                            if (o && l.mipmaps && l.mipmaps.length > 0) {
                                c.__webglFramebuffer[t] = [];
                                for (let n = 0; n < l.mipmaps.length; n++)
                                    c.__webglFramebuffer[t][n] = e.createFramebuffer()
                            } else
                                c.__webglFramebuffer[t] = e.createFramebuffer()
                    } else {
                        if (o && l.mipmaps && l.mipmaps.length > 0) {
                            c.__webglFramebuffer = [];
                            for (let t = 0; t < l.mipmaps.length; t++)
                                c.__webglFramebuffer[t] = e.createFramebuffer()
                        } else
                            c.__webglFramebuffer = e.createFramebuffer();
                        if (p)
                            if (i.drawBuffers)
                                for (let t = 0, n = d.length; t < n; t++) {
                                    const n = r.get(d[t]);
                                    void 0 === n.__webglTexture && (n.__webglTexture = e.createTexture(),
                                    s.memory.textures++)
                                }
                            else
                                console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                        if (o && t.samples > 0 && !1 === F(t)) {
                            c.__webglMultisampledFramebuffer = e.createFramebuffer(),
                            c.__webglColorRenderbuffer = [],
                            n.bindFramebuffer(e.FRAMEBUFFER, c.__webglMultisampledFramebuffer);
                            for (let n = 0; n < d.length; n++) {
                                const r = d[n];
                                c.__webglColorRenderbuffer[n] = e.createRenderbuffer(),
                                e.bindRenderbuffer(e.RENDERBUFFER, c.__webglColorRenderbuffer[n]);
                                const i = a.convert(r.format, r.colorSpace)
                                  , s = a.convert(r.type)
                                  , o = x(r.internalFormat, i, s, r.colorSpace, !0 === t.isXRRenderTarget)
                                  , l = k(t);
                                e.renderbufferStorageMultisample(e.RENDERBUFFER, l, o, t.width, t.height),
                                e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + n, e.RENDERBUFFER, c.__webglColorRenderbuffer[n])
                            }
                            e.bindRenderbuffer(e.RENDERBUFFER, null),
                            t.depthBuffer && (c.__webglDepthRenderbuffer = e.createRenderbuffer(),
                            N(c.__webglDepthRenderbuffer, t, !0)),
                            n.bindFramebuffer(e.FRAMEBUFFER, null)
                        }
                    }
                    if (h) {
                        n.bindTexture(e.TEXTURE_CUBE_MAP, u.__webglTexture),
                        L(e.TEXTURE_CUBE_MAP, l, f);
                        for (let n = 0; n < 6; n++)
                            if (o && l.mipmaps && l.mipmaps.length > 0)
                                for (let r = 0; r < l.mipmaps.length; r++)
                                    I(c.__webglFramebuffer[n][r], t, l, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n, r);
                            else
                                I(c.__webglFramebuffer[n], t, l, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0);
                        _(l, f) && y(e.TEXTURE_CUBE_MAP),
                        n.unbindTexture()
                    } else if (p) {
                        for (let i = 0, a = d.length; i < a; i++) {
                            const a = d[i]
                              , s = r.get(a);
                            n.bindTexture(e.TEXTURE_2D, s.__webglTexture),
                            L(e.TEXTURE_2D, a, f),
                            I(c.__webglFramebuffer, t, a, e.COLOR_ATTACHMENT0 + i, e.TEXTURE_2D, 0),
                            _(a, f) && y(e.TEXTURE_2D)
                        }
                        n.unbindTexture()
                    } else {
                        let r = e.TEXTURE_2D;
                        if ((t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (o ? r = t.isWebGL3DRenderTarget ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),
                        n.bindTexture(r, u.__webglTexture),
                        L(r, l, f),
                        o && l.mipmaps && l.mipmaps.length > 0)
                            for (let n = 0; n < l.mipmaps.length; n++)
                                I(c.__webglFramebuffer[n], t, l, e.COLOR_ATTACHMENT0, r, n);
                        else
                            I(c.__webglFramebuffer, t, l, e.COLOR_ATTACHMENT0, r, 0);
                        _(l, f) && y(r),
                        n.unbindTexture()
                    }
                    t.depthBuffer && U(t)
                }
                ,
                this.updateRenderTargetMipmap = function(t) {
                    const i = v(t) || o
                      , a = t.textures;
                    for (let s = 0, o = a.length; s < o; s++) {
                        const o = a[s];
                        if (_(o, i)) {
                            const i = t.isWebGLCubeRenderTarget ? e.TEXTURE_CUBE_MAP : e.TEXTURE_2D
                              , a = r.get(o).__webglTexture;
                            n.bindTexture(i, a),
                            y(i),
                            n.unbindTexture()
                        }
                    }
                }
                ,
                this.updateMultisampleRenderTarget = function(t) {
                    if (o && t.samples > 0 && !1 === F(t)) {
                        const i = t.textures
                          , a = t.width
                          , s = t.height;
                        let o = e.COLOR_BUFFER_BIT;
                        const l = []
                          , u = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                          , d = r.get(t)
                          , h = i.length > 1;
                        if (h)
                            for (let t = 0; t < i.length; t++)
                                n.bindFramebuffer(e.FRAMEBUFFER, d.__webglMultisampledFramebuffer),
                                e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, null),
                                n.bindFramebuffer(e.FRAMEBUFFER, d.__webglFramebuffer),
                                e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, null, 0);
                        n.bindFramebuffer(e.READ_FRAMEBUFFER, d.__webglMultisampledFramebuffer),
                        n.bindFramebuffer(e.DRAW_FRAMEBUFFER, d.__webglFramebuffer);
                        for (let n = 0; n < i.length; n++) {
                            l.push(e.COLOR_ATTACHMENT0 + n),
                            t.depthBuffer && l.push(u);
                            const p = void 0 !== d.__ignoreDepthValues && d.__ignoreDepthValues;
                            if (!1 === p && (t.depthBuffer && (o |= e.DEPTH_BUFFER_BIT),
                            t.stencilBuffer && (o |= e.STENCIL_BUFFER_BIT)),
                            h && e.framebufferRenderbuffer(e.READ_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, d.__webglColorRenderbuffer[n]),
                            !0 === p && (e.invalidateFramebuffer(e.READ_FRAMEBUFFER, [u]),
                            e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [u])),
                            h) {
                                const t = r.get(i[n]).__webglTexture;
                                e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0)
                            }
                            e.blitFramebuffer(0, 0, a, s, 0, 0, a, s, o, e.NEAREST),
                            c && e.invalidateFramebuffer(e.READ_FRAMEBUFFER, l)
                        }
                        if (n.bindFramebuffer(e.READ_FRAMEBUFFER, null),
                        n.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
                        h)
                            for (let t = 0; t < i.length; t++) {
                                n.bindFramebuffer(e.FRAMEBUFFER, d.__webglMultisampledFramebuffer),
                                e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, d.__webglColorRenderbuffer[t]);
                                const a = r.get(i[t]).__webglTexture;
                                n.bindFramebuffer(e.FRAMEBUFFER, d.__webglFramebuffer),
                                e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, a, 0)
                            }
                        n.bindFramebuffer(e.DRAW_FRAMEBUFFER, d.__webglMultisampledFramebuffer)
                    }
                }
                ,
                this.setupDepthRenderbuffer = U,
                this.setupFrameBufferTexture = I,
                this.useMultisampledRTT = F
            }
            function dh(e, t, n) {
                const r = n.isWebGL2;
                return {
                    convert: function(n, i="") {
                        let a;
                        const s = Xs.getTransfer(i);
                        if (n === Ba)
                            return e.UNSIGNED_BYTE;
                        if (1017 === n)
                            return e.UNSIGNED_SHORT_4_4_4_4;
                        if (1018 === n)
                            return e.UNSIGNED_SHORT_5_5_5_1;
                        if (1010 === n)
                            return e.BYTE;
                        if (1011 === n)
                            return e.SHORT;
                        if (n === Ha)
                            return e.UNSIGNED_SHORT;
                        if (n === Ga)
                            return e.INT;
                        if (n === Va)
                            return e.UNSIGNED_INT;
                        if (n === Wa)
                            return e.FLOAT;
                        if (n === ja)
                            return r ? e.HALF_FLOAT : (a = t.get("OES_texture_half_float"),
                            null !== a ? a.HALF_FLOAT_OES : null);
                        if (1021 === n)
                            return e.ALPHA;
                        if (n === qa)
                            return e.RGBA;
                        if (1024 === n)
                            return e.LUMINANCE;
                        if (1025 === n)
                            return e.LUMINANCE_ALPHA;
                        if (n === Ya)
                            return e.DEPTH_COMPONENT;
                        if (n === $a)
                            return e.DEPTH_STENCIL;
                        if (n === ys)
                            return a = t.get("EXT_sRGB"),
                            null !== a ? a.SRGB_ALPHA_EXT : null;
                        if (1028 === n)
                            return e.RED;
                        if (1029 === n)
                            return e.RED_INTEGER;
                        if (1030 === n)
                            return e.RG;
                        if (1031 === n)
                            return e.RG_INTEGER;
                        if (1033 === n)
                            return e.RGBA_INTEGER;
                        if (n === Ka || n === Za || n === Ja || n === Qa)
                            if (s === ps) {
                                if (a = t.get("WEBGL_compressed_texture_s3tc_srgb"),
                                null === a)
                                    return null;
                                if (n === Ka)
                                    return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                                if (n === Za)
                                    return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                                if (n === Ja)
                                    return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                                if (n === Qa)
                                    return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                            } else {
                                if (a = t.get("WEBGL_compressed_texture_s3tc"),
                                null === a)
                                    return null;
                                if (n === Ka)
                                    return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
                                if (n === Za)
                                    return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                                if (n === Ja)
                                    return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                                if (n === Qa)
                                    return a.COMPRESSED_RGBA_S3TC_DXT5_EXT
                            }
                        if (35840 === n || 35841 === n || 35842 === n || 35843 === n) {
                            if (a = t.get("WEBGL_compressed_texture_pvrtc"),
                            null === a)
                                return null;
                            if (35840 === n)
                                return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (35841 === n)
                                return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (35842 === n)
                                return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (35843 === n)
                                return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                        }
                        if (36196 === n)
                            return a = t.get("WEBGL_compressed_texture_etc1"),
                            null !== a ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
                        if (37492 === n || 37496 === n) {
                            if (a = t.get("WEBGL_compressed_texture_etc"),
                            null === a)
                                return null;
                            if (37492 === n)
                                return s === ps ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
                            if (37496 === n)
                                return s === ps ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC
                        }
                        if (37808 === n || 37809 === n || 37810 === n || 37811 === n || 37812 === n || 37813 === n || 37814 === n || 37815 === n || 37816 === n || 37817 === n || 37818 === n || 37819 === n || 37820 === n || 37821 === n) {
                            if (a = t.get("WEBGL_compressed_texture_astc"),
                            null === a)
                                return null;
                            if (37808 === n)
                                return s === ps ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
                            if (37809 === n)
                                return s === ps ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
                            if (37810 === n)
                                return s === ps ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
                            if (37811 === n)
                                return s === ps ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
                            if (37812 === n)
                                return s === ps ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
                            if (37813 === n)
                                return s === ps ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
                            if (37814 === n)
                                return s === ps ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
                            if (37815 === n)
                                return s === ps ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
                            if (37816 === n)
                                return s === ps ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
                            if (37817 === n)
                                return s === ps ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
                            if (37818 === n)
                                return s === ps ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
                            if (37819 === n)
                                return s === ps ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
                            if (37820 === n)
                                return s === ps ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
                            if (37821 === n)
                                return s === ps ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR
                        }
                        if (n === es || 36494 === n || 36495 === n) {
                            if (a = t.get("EXT_texture_compression_bptc"),
                            null === a)
                                return null;
                            if (n === es)
                                return s === ps ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                            if (36494 === n)
                                return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                            if (36495 === n)
                                return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
                        }
                        if (36283 === n || 36284 === n || 36285 === n || 36286 === n) {
                            if (a = t.get("EXT_texture_compression_rgtc"),
                            null === a)
                                return null;
                            if (n === es)
                                return a.COMPRESSED_RED_RGTC1_EXT;
                            if (36284 === n)
                                return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                            if (36285 === n)
                                return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
                            if (36286 === n)
                                return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                        }
                        return n === Xa ? r ? e.UNSIGNED_INT_24_8 : (a = t.get("WEBGL_depth_texture"),
                        null !== a ? a.UNSIGNED_INT_24_8_WEBGL : null) : void 0 !== e[n] ? e[n] : null
                    }
                }
            }
            class hh extends Ec {
                constructor(e=[]) {
                    super(),
                    this.isArrayCamera = !0,
                    this.cameras = e
                }
            }
            class ph extends hl {
                constructor() {
                    super(),
                    this.isGroup = !0,
                    this.type = "Group"
                }
            }
            const fh = {
                type: "move"
            };
            class mh {
                constructor() {
                    this._targetRay = null,
                    this._grip = null,
                    this._hand = null
                }
                getHandSpace() {
                    return null === this._hand && (this._hand = new ph,
                    this._hand.matrixAutoUpdate = !1,
                    this._hand.visible = !1,
                    this._hand.joints = {},
                    this._hand.inputState = {
                        pinching: !1
                    }),
                    this._hand
                }
                getTargetRaySpace() {
                    return null === this._targetRay && (this._targetRay = new ph,
                    this._targetRay.matrixAutoUpdate = !1,
                    this._targetRay.visible = !1,
                    this._targetRay.hasLinearVelocity = !1,
                    this._targetRay.linearVelocity = new lo,
                    this._targetRay.hasAngularVelocity = !1,
                    this._targetRay.angularVelocity = new lo),
                    this._targetRay
                }
                getGripSpace() {
                    return null === this._grip && (this._grip = new ph,
                    this._grip.matrixAutoUpdate = !1,
                    this._grip.visible = !1,
                    this._grip.hasLinearVelocity = !1,
                    this._grip.linearVelocity = new lo,
                    this._grip.hasAngularVelocity = !1,
                    this._grip.angularVelocity = new lo),
                    this._grip
                }
                dispatchEvent(e) {
                    return null !== this._targetRay && this._targetRay.dispatchEvent(e),
                    null !== this._grip && this._grip.dispatchEvent(e),
                    null !== this._hand && this._hand.dispatchEvent(e),
                    this
                }
                connect(e) {
                    if (e && e.hand) {
                        const t = this._hand;
                        if (t)
                            for (const n of e.hand.values())
                                this._getHandJoint(t, n)
                    }
                    return this.dispatchEvent({
                        type: "connected",
                        data: e
                    }),
                    this
                }
                disconnect(e) {
                    return this.dispatchEvent({
                        type: "disconnected",
                        data: e
                    }),
                    null !== this._targetRay && (this._targetRay.visible = !1),
                    null !== this._grip && (this._grip.visible = !1),
                    null !== this._hand && (this._hand.visible = !1),
                    this
                }
                update(e, t, n) {
                    let r = null
                      , i = null
                      , a = null;
                    const s = this._targetRay
                      , o = this._grip
                      , l = this._hand;
                    if (e && "visible-blurred" !== t.session.visibilityState) {
                        if (l && e.hand) {
                            a = !0;
                            for (const r of e.hand.values()) {
                                const e = t.getJointPose(r, n)
                                  , i = this._getHandJoint(l, r);
                                null !== e && (i.matrix.fromArray(e.transform.matrix),
                                i.matrix.decompose(i.position, i.rotation, i.scale),
                                i.matrixWorldNeedsUpdate = !0,
                                i.jointRadius = e.radius),
                                i.visible = null !== e
                            }
                            const r = l.joints["index-finger-tip"]
                              , i = l.joints["thumb-tip"]
                              , s = r.position.distanceTo(i.position)
                              , o = .02
                              , c = .005;
                            l.inputState.pinching && s > o + c ? (l.inputState.pinching = !1,
                            this.dispatchEvent({
                                type: "pinchend",
                                handedness: e.handedness,
                                target: this
                            })) : !l.inputState.pinching && s <= o - c && (l.inputState.pinching = !0,
                            this.dispatchEvent({
                                type: "pinchstart",
                                handedness: e.handedness,
                                target: this
                            }))
                        } else
                            null !== o && e.gripSpace && (i = t.getPose(e.gripSpace, n),
                            null !== i && (o.matrix.fromArray(i.transform.matrix),
                            o.matrix.decompose(o.position, o.rotation, o.scale),
                            o.matrixWorldNeedsUpdate = !0,
                            i.linearVelocity ? (o.hasLinearVelocity = !0,
                            o.linearVelocity.copy(i.linearVelocity)) : o.hasLinearVelocity = !1,
                            i.angularVelocity ? (o.hasAngularVelocity = !0,
                            o.angularVelocity.copy(i.angularVelocity)) : o.hasAngularVelocity = !1));
                        null !== s && (r = t.getPose(e.targetRaySpace, n),
                        null === r && null !== i && (r = i),
                        null !== r && (s.matrix.fromArray(r.transform.matrix),
                        s.matrix.decompose(s.position, s.rotation, s.scale),
                        s.matrixWorldNeedsUpdate = !0,
                        r.linearVelocity ? (s.hasLinearVelocity = !0,
                        s.linearVelocity.copy(r.linearVelocity)) : s.hasLinearVelocity = !1,
                        r.angularVelocity ? (s.hasAngularVelocity = !0,
                        s.angularVelocity.copy(r.angularVelocity)) : s.hasAngularVelocity = !1,
                        this.dispatchEvent(fh)))
                    }
                    return null !== s && (s.visible = null !== r),
                    null !== o && (o.visible = null !== i),
                    null !== l && (l.visible = null !== a),
                    this
                }
                _getHandJoint(e, t) {
                    if (void 0 === e.joints[t.jointName]) {
                        const n = new ph;
                        n.matrixAutoUpdate = !1,
                        n.visible = !1,
                        e.joints[t.jointName] = n,
                        e.add(n)
                    }
                    return e.joints[t.jointName]
                }
            }
            class gh {
                constructor() {
                    this.texture = null,
                    this.mesh = null,
                    this.depthNear = 0,
                    this.depthFar = 0
                }
                init(e, t, n) {
                    if (null === this.texture) {
                        const r = new to;
                        e.properties.get(r).__webglTexture = t.texture,
                        t.depthNear == n.depthNear && t.depthFar == n.depthFar || (this.depthNear = t.depthNear,
                        this.depthFar = t.depthFar),
                        this.texture = r
                    }
                }
                render(e, t) {
                    if (null !== this.texture) {
                        if (null === this.mesh) {
                            const e = t.cameras[0].viewport
                              , n = new vc({
                                extensions: {
                                    fragDepth: !0
                                },
                                vertexShader: "\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",
                                fragmentShader: "\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepthEXT = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepthEXT = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}",
                                uniforms: {
                                    depthColor: {
                                        value: this.texture
                                    },
                                    depthWidth: {
                                        value: e.z
                                    },
                                    depthHeight: {
                                        value: e.w
                                    }
                                }
                            });
                            this.mesh = new uc(new Uc(20,20),n)
                        }
                        e.render(this.mesh, t)
                    }
                }
                reset() {
                    this.texture = null,
                    this.mesh = null
                }
            }
            class vh extends Es {
                constructor(e, t) {
                    super();
                    const n = this;
                    let r = null
                      , i = 1
                      , a = null
                      , s = "local-floor"
                      , o = 1
                      , l = null
                      , c = null
                      , u = null
                      , d = null
                      , h = null
                      , p = null;
                    const f = new gh
                      , m = t.getContextAttributes();
                    let g = null
                      , v = null;
                    const _ = []
                      , y = []
                      , x = new Is;
                    let b = null;
                    const E = new Ec;
                    E.layers.enable(1),
                    E.viewport = new no;
                    const S = new Ec;
                    S.layers.enable(2),
                    S.viewport = new no;
                    const w = [E, S]
                      , M = new hh;
                    M.layers.enable(1),
                    M.layers.enable(2);
                    let T = null
                      , A = null;
                    function C(e) {
                        const t = y.indexOf(e.inputSource);
                        if (-1 === t)
                            return;
                        const n = _[t];
                        void 0 !== n && (n.update(e.inputSource, e.frame, l || a),
                        n.dispatchEvent({
                            type: e.type,
                            data: e.inputSource
                        }))
                    }
                    function P() {
                        r.removeEventListener("select", C),
                        r.removeEventListener("selectstart", C),
                        r.removeEventListener("selectend", C),
                        r.removeEventListener("squeeze", C),
                        r.removeEventListener("squeezestart", C),
                        r.removeEventListener("squeezeend", C),
                        r.removeEventListener("end", P),
                        r.removeEventListener("inputsourceschange", R);
                        for (let e = 0; e < _.length; e++) {
                            const t = y[e];
                            null !== t && (y[e] = null,
                            _[e].disconnect(t))
                        }
                        T = null,
                        A = null,
                        f.reset(),
                        e.setRenderTarget(g),
                        h = null,
                        d = null,
                        u = null,
                        r = null,
                        v = null,
                        N.stop(),
                        n.isPresenting = !1,
                        e.setPixelRatio(b),
                        e.setSize(x.width, x.height, !1),
                        n.dispatchEvent({
                            type: "sessionend"
                        })
                    }
                    function R(e) {
                        for (let t = 0; t < e.removed.length; t++) {
                            const n = e.removed[t]
                              , r = y.indexOf(n);
                            r >= 0 && (y[r] = null,
                            _[r].disconnect(n))
                        }
                        for (let t = 0; t < e.added.length; t++) {
                            const n = e.added[t];
                            let r = y.indexOf(n);
                            if (-1 === r) {
                                for (let e = 0; e < _.length; e++) {
                                    if (e >= y.length) {
                                        y.push(n),
                                        r = e;
                                        break
                                    }
                                    if (null === y[e]) {
                                        y[e] = n,
                                        r = e;
                                        break
                                    }
                                }
                                if (-1 === r)
                                    break
                            }
                            const i = _[r];
                            i && i.connect(n)
                        }
                    }
                    this.cameraAutoUpdate = !0,
                    this.enabled = !1,
                    this.isPresenting = !1,
                    this.getController = function(e) {
                        let t = _[e];
                        return void 0 === t && (t = new mh,
                        _[e] = t),
                        t.getTargetRaySpace()
                    }
                    ,
                    this.getControllerGrip = function(e) {
                        let t = _[e];
                        return void 0 === t && (t = new mh,
                        _[e] = t),
                        t.getGripSpace()
                    }
                    ,
                    this.getHand = function(e) {
                        let t = _[e];
                        return void 0 === t && (t = new mh,
                        _[e] = t),
                        t.getHandSpace()
                    }
                    ,
                    this.setFramebufferScaleFactor = function(e) {
                        i = e,
                        !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                    }
                    ,
                    this.setReferenceSpaceType = function(e) {
                        s = e,
                        !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                    }
                    ,
                    this.getReferenceSpace = function() {
                        return l || a
                    }
                    ,
                    this.setReferenceSpace = function(e) {
                        l = e
                    }
                    ,
                    this.getBaseLayer = function() {
                        return null !== d ? d : h
                    }
                    ,
                    this.getBinding = function() {
                        return u
                    }
                    ,
                    this.getFrame = function() {
                        return p
                    }
                    ,
                    this.getSession = function() {
                        return r
                    }
                    ,
                    this.setSession = async function(c) {
                        if (r = c,
                        null !== r) {
                            if (g = e.getRenderTarget(),
                            r.addEventListener("select", C),
                            r.addEventListener("selectstart", C),
                            r.addEventListener("selectend", C),
                            r.addEventListener("squeeze", C),
                            r.addEventListener("squeezestart", C),
                            r.addEventListener("squeezeend", C),
                            r.addEventListener("end", P),
                            r.addEventListener("inputsourceschange", R),
                            !0 !== m.xrCompatible && await t.makeXRCompatible(),
                            b = e.getPixelRatio(),
                            e.getSize(x),
                            void 0 === r.renderState.layers || !1 === e.capabilities.isWebGL2) {
                                const n = {
                                    antialias: void 0 !== r.renderState.layers || m.antialias,
                                    alpha: !0,
                                    depth: m.depth,
                                    stencil: m.stencil,
                                    framebufferScaleFactor: i
                                };
                                h = new XRWebGLLayer(r,t,n),
                                r.updateRenderState({
                                    baseLayer: h
                                }),
                                e.setPixelRatio(1),
                                e.setSize(h.framebufferWidth, h.framebufferHeight, !1),
                                v = new io(h.framebufferWidth,h.framebufferHeight,{
                                    format: qa,
                                    type: Ba,
                                    colorSpace: e.outputColorSpace,
                                    stencilBuffer: m.stencil
                                })
                            } else {
                                let n = null
                                  , a = null
                                  , s = null;
                                m.depth && (s = m.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24,
                                n = m.stencil ? $a : Ya,
                                a = m.stencil ? Xa : Va);
                                const o = {
                                    colorFormat: t.RGBA8,
                                    depthFormat: s,
                                    scaleFactor: i
                                };
                                u = new XRWebGLBinding(r,t),
                                d = u.createProjectionLayer(o),
                                r.updateRenderState({
                                    layers: [d]
                                }),
                                e.setPixelRatio(1),
                                e.setSize(d.textureWidth, d.textureHeight, !1),
                                v = new io(d.textureWidth,d.textureHeight,{
                                    format: qa,
                                    type: Ba,
                                    depthTexture: new bu(d.textureWidth,d.textureHeight,a,void 0,void 0,void 0,void 0,void 0,void 0,n),
                                    stencilBuffer: m.stencil,
                                    colorSpace: e.outputColorSpace,
                                    samples: m.antialias ? 4 : 0
                                });
                                e.properties.get(v).__ignoreDepthValues = d.ignoreDepthValues
                            }
                            v.isXRRenderTarget = !0,
                            this.setFoveation(o),
                            l = null,
                            a = await r.requestReferenceSpace(s),
                            N.setContext(r),
                            N.start(),
                            n.isPresenting = !0,
                            n.dispatchEvent({
                                type: "sessionstart"
                            })
                        }
                    }
                    ,
                    this.getEnvironmentBlendMode = function() {
                        if (null !== r)
                            return r.environmentBlendMode
                    }
                    ;
                    const L = new lo
                      , O = new lo;
                    function D(e, t) {
                        null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
                        e.matrixWorldInverse.copy(e.matrixWorld).invert()
                    }
                    this.updateCamera = function(e) {
                        if (null === r)
                            return;
                        null !== f.texture && (e.near = f.depthNear,
                        e.far = f.depthFar),
                        M.near = S.near = E.near = e.near,
                        M.far = S.far = E.far = e.far,
                        T === M.near && A === M.far || (r.updateRenderState({
                            depthNear: M.near,
                            depthFar: M.far
                        }),
                        T = M.near,
                        A = M.far,
                        E.near = T,
                        E.far = A,
                        S.near = T,
                        S.far = A,
                        E.updateProjectionMatrix(),
                        S.updateProjectionMatrix(),
                        e.updateProjectionMatrix());
                        const t = e.parent
                          , n = M.cameras;
                        D(M, t);
                        for (let e = 0; e < n.length; e++)
                            D(n[e], t);
                        2 === n.length ? function(e, t, n) {
                            L.setFromMatrixPosition(t.matrixWorld),
                            O.setFromMatrixPosition(n.matrixWorld);
                            const r = L.distanceTo(O)
                              , i = t.projectionMatrix.elements
                              , a = n.projectionMatrix.elements
                              , s = i[14] / (i[10] - 1)
                              , o = i[14] / (i[10] + 1)
                              , l = (i[9] + 1) / i[5]
                              , c = (i[9] - 1) / i[5]
                              , u = (i[8] - 1) / i[0]
                              , d = (a[8] + 1) / a[0]
                              , h = s * u
                              , p = s * d
                              , f = r / (-u + d)
                              , m = f * -u;
                            t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
                            e.translateX(m),
                            e.translateZ(f),
                            e.matrixWorld.compose(e.position, e.quaternion, e.scale),
                            e.matrixWorldInverse.copy(e.matrixWorld).invert();
                            const g = s + f
                              , v = o + f
                              , _ = h - m
                              , y = p + (r - m)
                              , x = l * o / v * g
                              , b = c * o / v * g;
                            e.projectionMatrix.makePerspective(_, y, x, b, g, v),
                            e.projectionMatrixInverse.copy(e.projectionMatrix).invert()
                        }(M, E, S) : M.projectionMatrix.copy(E.projectionMatrix),
                        function(e, t, n) {
                            null === n ? e.matrix.copy(t.matrixWorld) : (e.matrix.copy(n.matrixWorld),
                            e.matrix.invert(),
                            e.matrix.multiply(t.matrixWorld));
                            e.matrix.decompose(e.position, e.quaternion, e.scale),
                            e.updateMatrixWorld(!0),
                            e.projectionMatrix.copy(t.projectionMatrix),
                            e.projectionMatrixInverse.copy(t.projectionMatrixInverse),
                            e.isPerspectiveCamera && (e.fov = 2 * Ms * Math.atan(1 / e.projectionMatrix.elements[5]),
                            e.zoom = 1)
                        }(e, M, t)
                    }
                    ,
                    this.getCamera = function() {
                        return M
                    }
                    ,
                    this.getFoveation = function() {
                        if (null !== d || null !== h)
                            return o
                    }
                    ,
                    this.setFoveation = function(e) {
                        o = e,
                        null !== d && (d.fixedFoveation = e),
                        null !== h && void 0 !== h.fixedFoveation && (h.fixedFoveation = e)
                    }
                    ,
                    this.hasDepthSensing = function() {
                        return null !== f.texture
                    }
                    ;
                    let I = null;
                    const N = new Ic;
                    N.setAnimationLoop((function(t, i) {
                        if (c = i.getViewerPose(l || a),
                        p = i,
                        null !== c) {
                            const t = c.views;
                            null !== h && (e.setRenderTargetFramebuffer(v, h.framebuffer),
                            e.setRenderTarget(v));
                            let n = !1;
                            t.length !== M.cameras.length && (M.cameras.length = 0,
                            n = !0);
                            for (let r = 0; r < t.length; r++) {
                                const i = t[r];
                                let a = null;
                                if (null !== h)
                                    a = h.getViewport(i);
                                else {
                                    const t = u.getViewSubImage(d, i);
                                    a = t.viewport,
                                    0 === r && (e.setRenderTargetTextures(v, t.colorTexture, d.ignoreDepthValues ? void 0 : t.depthStencilTexture),
                                    e.setRenderTarget(v))
                                }
                                let s = w[r];
                                void 0 === s && (s = new Ec,
                                s.layers.enable(r),
                                s.viewport = new no,
                                w[r] = s),
                                s.matrix.fromArray(i.transform.matrix),
                                s.matrix.decompose(s.position, s.quaternion, s.scale),
                                s.projectionMatrix.fromArray(i.projectionMatrix),
                                s.projectionMatrixInverse.copy(s.projectionMatrix).invert(),
                                s.viewport.set(a.x, a.y, a.width, a.height),
                                0 === r && (M.matrix.copy(s.matrix),
                                M.matrix.decompose(M.position, M.quaternion, M.scale)),
                                !0 === n && M.cameras.push(s)
                            }
                            const i = r.enabledFeatures;
                            if (i && i.includes("depth-sensing")) {
                                const n = u.getDepthInformation(t[0]);
                                n && n.isValid && n.texture && f.init(e, n, r.renderState)
                            }
                        }
                        for (let e = 0; e < _.length; e++) {
                            const t = y[e]
                              , n = _[e];
                            null !== t && void 0 !== n && n.update(t, i, l || a)
                        }
                        f.render(e, M),
                        I && I(t, i),
                        i.detectedPlanes && n.dispatchEvent({
                            type: "planesdetected",
                            data: i
                        }),
                        p = null
                    }
                    )),
                    this.setAnimationLoop = function(e) {
                        I = e
                    }
                    ,
                    this.dispose = function() {}
                }
            }
            const _h = new $o
              , yh = new zo;
            function xh(e, t) {
                function n(e, t) {
                    !0 === e.matrixAutoUpdate && e.updateMatrix(),
                    t.value.copy(e.matrix)
                }
                function r(r, i) {
                    r.opacity.value = i.opacity,
                    i.color && r.diffuse.value.copy(i.color),
                    i.emissive && r.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity),
                    i.map && (r.map.value = i.map,
                    n(i.map, r.mapTransform)),
                    i.alphaMap && (r.alphaMap.value = i.alphaMap,
                    n(i.alphaMap, r.alphaMapTransform)),
                    i.bumpMap && (r.bumpMap.value = i.bumpMap,
                    n(i.bumpMap, r.bumpMapTransform),
                    r.bumpScale.value = i.bumpScale,
                    i.side === pa && (r.bumpScale.value *= -1)),
                    i.normalMap && (r.normalMap.value = i.normalMap,
                    n(i.normalMap, r.normalMapTransform),
                    r.normalScale.value.copy(i.normalScale),
                    i.side === pa && r.normalScale.value.negate()),
                    i.displacementMap && (r.displacementMap.value = i.displacementMap,
                    n(i.displacementMap, r.displacementMapTransform),
                    r.displacementScale.value = i.displacementScale,
                    r.displacementBias.value = i.displacementBias),
                    i.emissiveMap && (r.emissiveMap.value = i.emissiveMap,
                    n(i.emissiveMap, r.emissiveMapTransform)),
                    i.specularMap && (r.specularMap.value = i.specularMap,
                    n(i.specularMap, r.specularMapTransform)),
                    i.alphaTest > 0 && (r.alphaTest.value = i.alphaTest);
                    const a = t.get(i)
                      , s = a.envMap
                      , o = a.envMapRotation;
                    if (s && (r.envMap.value = s,
                    _h.copy(o),
                    _h.x *= -1,
                    _h.y *= -1,
                    _h.z *= -1,
                    s.isCubeTexture && !1 === s.isRenderTargetTexture && (_h.y *= -1,
                    _h.z *= -1),
                    r.envMapRotation.value.setFromMatrix4(yh.makeRotationFromEuler(_h)),
                    r.flipEnvMap.value = s.isCubeTexture && !1 === s.isRenderTargetTexture ? -1 : 1,
                    r.reflectivity.value = i.reflectivity,
                    r.ior.value = i.ior,
                    r.refractionRatio.value = i.refractionRatio),
                    i.lightMap) {
                        r.lightMap.value = i.lightMap;
                        const t = !0 === e._useLegacyLights ? Math.PI : 1;
                        r.lightMapIntensity.value = i.lightMapIntensity * t,
                        n(i.lightMap, r.lightMapTransform)
                    }
                    i.aoMap && (r.aoMap.value = i.aoMap,
                    r.aoMapIntensity.value = i.aoMapIntensity,
                    n(i.aoMap, r.aoMapTransform))
                }
                return {
                    refreshFogUniforms: function(t, n) {
                        n.color.getRGB(t.fogColor.value, mc(e)),
                        n.isFog ? (t.fogNear.value = n.near,
                        t.fogFar.value = n.far) : n.isFogExp2 && (t.fogDensity.value = n.density)
                    },
                    refreshMaterialUniforms: function(e, i, a, s, o) {
                        i.isMeshBasicMaterial || i.isMeshLambertMaterial ? r(e, i) : i.isMeshToonMaterial ? (r(e, i),
                        function(e, t) {
                            t.gradientMap && (e.gradientMap.value = t.gradientMap)
                        }(e, i)) : i.isMeshPhongMaterial ? (r(e, i),
                        function(e, t) {
                            e.specular.value.copy(t.specular),
                            e.shininess.value = Math.max(t.shininess, 1e-4)
                        }(e, i)) : i.isMeshStandardMaterial ? (r(e, i),
                        function(e, r) {
                            e.metalness.value = r.metalness,
                            r.metalnessMap && (e.metalnessMap.value = r.metalnessMap,
                            n(r.metalnessMap, e.metalnessMapTransform));
                            e.roughness.value = r.roughness,
                            r.roughnessMap && (e.roughnessMap.value = r.roughnessMap,
                            n(r.roughnessMap, e.roughnessMapTransform));
                            const i = t.get(r).envMap;
                            i && (e.envMapIntensity.value = r.envMapIntensity)
                        }(e, i),
                        i.isMeshPhysicalMaterial && function(e, t, r) {
                            e.ior.value = t.ior,
                            t.sheen > 0 && (e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen),
                            e.sheenRoughness.value = t.sheenRoughness,
                            t.sheenColorMap && (e.sheenColorMap.value = t.sheenColorMap,
                            n(t.sheenColorMap, e.sheenColorMapTransform)),
                            t.sheenRoughnessMap && (e.sheenRoughnessMap.value = t.sheenRoughnessMap,
                            n(t.sheenRoughnessMap, e.sheenRoughnessMapTransform)));
                            t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat,
                            e.clearcoatRoughness.value = t.clearcoatRoughness,
                            t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap,
                            n(t.clearcoatMap, e.clearcoatMapTransform)),
                            t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap,
                            n(t.clearcoatRoughnessMap, e.clearcoatRoughnessMapTransform)),
                            t.clearcoatNormalMap && (e.clearcoatNormalMap.value = t.clearcoatNormalMap,
                            n(t.clearcoatNormalMap, e.clearcoatNormalMapTransform),
                            e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),
                            t.side === pa && e.clearcoatNormalScale.value.negate()));
                            t.iridescence > 0 && (e.iridescence.value = t.iridescence,
                            e.iridescenceIOR.value = t.iridescenceIOR,
                            e.iridescenceThicknessMinimum.value = t.iridescenceThicknessRange[0],
                            e.iridescenceThicknessMaximum.value = t.iridescenceThicknessRange[1],
                            t.iridescenceMap && (e.iridescenceMap.value = t.iridescenceMap,
                            n(t.iridescenceMap, e.iridescenceMapTransform)),
                            t.iridescenceThicknessMap && (e.iridescenceThicknessMap.value = t.iridescenceThicknessMap,
                            n(t.iridescenceThicknessMap, e.iridescenceThicknessMapTransform)));
                            t.transmission > 0 && (e.transmission.value = t.transmission,
                            e.transmissionSamplerMap.value = r.texture,
                            e.transmissionSamplerSize.value.set(r.width, r.height),
                            t.transmissionMap && (e.transmissionMap.value = t.transmissionMap,
                            n(t.transmissionMap, e.transmissionMapTransform)),
                            e.thickness.value = t.thickness,
                            t.thicknessMap && (e.thicknessMap.value = t.thicknessMap,
                            n(t.thicknessMap, e.thicknessMapTransform)),
                            e.attenuationDistance.value = t.attenuationDistance,
                            e.attenuationColor.value.copy(t.attenuationColor));
                            t.anisotropy > 0 && (e.anisotropyVector.value.set(t.anisotropy * Math.cos(t.anisotropyRotation), t.anisotropy * Math.sin(t.anisotropyRotation)),
                            t.anisotropyMap && (e.anisotropyMap.value = t.anisotropyMap,
                            n(t.anisotropyMap, e.anisotropyMapTransform)));
                            e.specularIntensity.value = t.specularIntensity,
                            e.specularColor.value.copy(t.specularColor),
                            t.specularColorMap && (e.specularColorMap.value = t.specularColorMap,
                            n(t.specularColorMap, e.specularColorMapTransform));
                            t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap,
                            n(t.specularIntensityMap, e.specularIntensityMapTransform))
                        }(e, i, o)) : i.isMeshMatcapMaterial ? (r(e, i),
                        function(e, t) {
                            t.matcap && (e.matcap.value = t.matcap)
                        }(e, i)) : i.isMeshDepthMaterial ? r(e, i) : i.isMeshDistanceMaterial ? (r(e, i),
                        function(e, n) {
                            const r = t.get(n).light;
                            e.referencePosition.value.setFromMatrixPosition(r.matrixWorld),
                            e.nearDistance.value = r.shadow.camera.near,
                            e.farDistance.value = r.shadow.camera.far
                        }(e, i)) : i.isMeshNormalMaterial ? r(e, i) : i.isLineBasicMaterial ? (function(e, t) {
                            e.diffuse.value.copy(t.color),
                            e.opacity.value = t.opacity,
                            t.map && (e.map.value = t.map,
                            n(t.map, e.mapTransform))
                        }(e, i),
                        i.isLineDashedMaterial && function(e, t) {
                            e.dashSize.value = t.dashSize,
                            e.totalSize.value = t.dashSize + t.gapSize,
                            e.scale.value = t.scale
                        }(e, i)) : i.isPointsMaterial ? function(e, t, r, i) {
                            e.diffuse.value.copy(t.color),
                            e.opacity.value = t.opacity,
                            e.size.value = t.size * r,
                            e.scale.value = .5 * i,
                            t.map && (e.map.value = t.map,
                            n(t.map, e.uvTransform));
                            t.alphaMap && (e.alphaMap.value = t.alphaMap,
                            n(t.alphaMap, e.alphaMapTransform));
                            t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest)
                        }(e, i, a, s) : i.isSpriteMaterial ? function(e, t) {
                            e.diffuse.value.copy(t.color),
                            e.opacity.value = t.opacity,
                            e.rotation.value = t.rotation,
                            t.map && (e.map.value = t.map,
                            n(t.map, e.mapTransform));
                            t.alphaMap && (e.alphaMap.value = t.alphaMap,
                            n(t.alphaMap, e.alphaMapTransform));
                            t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest)
                        }(e, i) : i.isShadowMaterial ? (e.color.value.copy(i.color),
                        e.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
                    }
                }
            }
            function bh(e, t, n, r) {
                let i = {}
                  , a = {}
                  , s = [];
                const o = n.isWebGL2 ? e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
                function l(e, t, n, r) {
                    const i = e.value
                      , a = t + "_" + n;
                    if (void 0 === r[a])
                        return r[a] = "number" == typeof i || "boolean" == typeof i ? i : i.clone(),
                        !0;
                    {
                        const e = r[a];
                        if ("number" == typeof i || "boolean" == typeof i) {
                            if (e !== i)
                                return r[a] = i,
                                !0
                        } else if (!1 === e.equals(i))
                            return e.copy(i),
                            !0
                    }
                    return !1
                }
                function c(e) {
                    const t = {
                        boundary: 0,
                        storage: 0
                    };
                    return "number" == typeof e || "boolean" == typeof e ? (t.boundary = 4,
                    t.storage = 4) : e.isVector2 ? (t.boundary = 8,
                    t.storage = 8) : e.isVector3 || e.isColor ? (t.boundary = 16,
                    t.storage = 12) : e.isVector4 ? (t.boundary = 16,
                    t.storage = 16) : e.isMatrix3 ? (t.boundary = 48,
                    t.storage = 48) : e.isMatrix4 ? (t.boundary = 64,
                    t.storage = 64) : e.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", e),
                    t
                }
                function u(t) {
                    const n = t.target;
                    n.removeEventListener("dispose", u);
                    const r = s.indexOf(n.__bindingPointIndex);
                    s.splice(r, 1),
                    e.deleteBuffer(i[n.id]),
                    delete i[n.id],
                    delete a[n.id]
                }
                return {
                    bind: function(e, t) {
                        const n = t.program;
                        r.uniformBlockBinding(e, n)
                    },
                    update: function(n, d) {
                        let h = i[n.id];
                        void 0 === h && (!function(e) {
                            const t = e.uniforms;
                            let n = 0;
                            const r = 16;
                            for (let e = 0, i = t.length; e < i; e++) {
                                const i = Array.isArray(t[e]) ? t[e] : [t[e]];
                                for (let e = 0, t = i.length; e < t; e++) {
                                    const t = i[e]
                                      , a = Array.isArray(t.value) ? t.value : [t.value];
                                    for (let e = 0, i = a.length; e < i; e++) {
                                        const i = c(a[e])
                                          , s = n % r;
                                        0 !== s && r - s < i.boundary && (n += r - s),
                                        t.__data = new Float32Array(i.storage / Float32Array.BYTES_PER_ELEMENT),
                                        t.__offset = n,
                                        n += i.storage
                                    }
                                }
                            }
                            const i = n % r;
                            i > 0 && (n += r - i);
                            e.__size = n,
                            e.__cache = {}
                        }(n),
                        h = function(t) {
                            const n = function() {
                                for (let e = 0; e < o; e++)
                                    if (-1 === s.indexOf(e))
                                        return s.push(e),
                                        e;
                                return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
                                0
                            }();
                            t.__bindingPointIndex = n;
                            const r = e.createBuffer()
                              , i = t.__size
                              , a = t.usage;
                            return e.bindBuffer(e.UNIFORM_BUFFER, r),
                            e.bufferData(e.UNIFORM_BUFFER, i, a),
                            e.bindBuffer(e.UNIFORM_BUFFER, null),
                            e.bindBufferBase(e.UNIFORM_BUFFER, n, r),
                            r
                        }(n),
                        i[n.id] = h,
                        n.addEventListener("dispose", u));
                        const p = d.program;
                        r.updateUBOMapping(n, p);
                        const f = t.render.frame;
                        a[n.id] !== f && (!function(t) {
                            const n = i[t.id]
                              , r = t.uniforms
                              , a = t.__cache;
                            e.bindBuffer(e.UNIFORM_BUFFER, n);
                            for (let t = 0, n = r.length; t < n; t++) {
                                const n = Array.isArray(r[t]) ? r[t] : [r[t]];
                                for (let r = 0, i = n.length; r < i; r++) {
                                    const i = n[r];
                                    if (!0 === l(i, t, r, a)) {
                                        const t = i.__offset
                                          , n = Array.isArray(i.value) ? i.value : [i.value];
                                        let r = 0;
                                        for (let a = 0; a < n.length; a++) {
                                            const s = n[a]
                                              , o = c(s);
                                            "number" == typeof s || "boolean" == typeof s ? (i.__data[0] = s,
                                            e.bufferSubData(e.UNIFORM_BUFFER, t + r, i.__data)) : s.isMatrix3 ? (i.__data[0] = s.elements[0],
                                            i.__data[1] = s.elements[1],
                                            i.__data[2] = s.elements[2],
                                            i.__data[3] = 0,
                                            i.__data[4] = s.elements[3],
                                            i.__data[5] = s.elements[4],
                                            i.__data[6] = s.elements[5],
                                            i.__data[7] = 0,
                                            i.__data[8] = s.elements[6],
                                            i.__data[9] = s.elements[7],
                                            i.__data[10] = s.elements[8],
                                            i.__data[11] = 0) : (s.toArray(i.__data, r),
                                            r += o.storage / Float32Array.BYTES_PER_ELEMENT)
                                        }
                                        e.bufferSubData(e.UNIFORM_BUFFER, t, i.__data)
                                    }
                                }
                            }
                            e.bindBuffer(e.UNIFORM_BUFFER, null)
                        }(n),
                        a[n.id] = f)
                    },
                    dispose: function() {
                        for (const t in i)
                            e.deleteBuffer(i[t]);
                        s = [],
                        i = {},
                        a = {}
                    }
                }
            }
            class Eh {
                constructor(e={}) {
                    const {canvas: t=zs(), context: n=null, depth: r=!0, stencil: i=!0, alpha: a=!1, antialias: s=!1, premultipliedAlpha: o=!0, preserveDrawingBuffer: l=!1, powerPreference: c="default", failIfMajorPerformanceCaveat: u=!1} = e;
                    let d;
                    this.isWebGLRenderer = !0,
                    d = null !== n ? n.getContextAttributes().alpha : a;
                    const h = new Uint32Array(4)
                      , p = new Int32Array(4);
                    let f = null
                      , m = null;
                    const g = []
                      , v = [];
                    this.domElement = t,
                    this.debug = {
                        checkShaderErrors: !0,
                        onShaderError: null
                    },
                    this.autoClear = !0,
                    this.autoClearColor = !0,
                    this.autoClearDepth = !0,
                    this.autoClearStencil = !0,
                    this.sortObjects = !0,
                    this.clippingPlanes = [],
                    this.localClippingEnabled = !1,
                    this._outputColorSpace = ls,
                    this._useLegacyLights = !1,
                    this.toneMapping = _a,
                    this.toneMappingExposure = 1;
                    const _ = this;
                    let y = !1
                      , x = 0
                      , b = 0
                      , E = null
                      , S = -1
                      , w = null;
                    const M = new no
                      , T = new no;
                    let A = null;
                    const C = new Cl(0);
                    let P = 0
                      , R = t.width
                      , L = t.height
                      , O = 1
                      , D = null
                      , I = null;
                    const N = new no(0,0,R,L)
                      , U = new no(0,0,R,L);
                    let k = !1;
                    const F = new Dc;
                    let z = !1
                      , B = !1
                      , H = null;
                    const G = new zo
                      , V = new Is
                      , W = new lo
                      , j = {
                        background: null,
                        fog: null,
                        environment: null,
                        overrideMaterial: null,
                        isScene: !0
                    };
                    function X() {
                        return null === E ? O : 1
                    }
                    let q, Y, $, K, Z, J, Q, ee, te, ne, re, ie, ae, se, oe, le, ce, ue, de, he, pe, fe, me, ge, ve = n;
                    function _e(e, n) {
                        for (let r = 0; r < e.length; r++) {
                            const i = e[r]
                              , a = t.getContext(i, n);
                            if (null !== a)
                                return a
                        }
                        return null
                    }
                    try {
                        const e = {
                            alpha: !0,
                            depth: r,
                            stencil: i,
                            antialias: s,
                            premultipliedAlpha: o,
                            preserveDrawingBuffer: l,
                            powerPreference: c,
                            failIfMajorPerformanceCaveat: u
                        };
                        if ("setAttribute"in t && t.setAttribute("data-engine", `three.js r${la}`),
                        t.addEventListener("webglcontextlost", be, !1),
                        t.addEventListener("webglcontextrestored", Ee, !1),
                        t.addEventListener("webglcontextcreationerror", Se, !1),
                        null === ve) {
                            const t = ["webgl2", "webgl", "experimental-webgl"];
                            if (!0 === _.isWebGL1Renderer && t.shift(),
                            ve = _e(t, e),
                            null === ve)
                                throw _e(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                        }
                        "undefined" != typeof WebGLRenderingContext && ve instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."),
                        void 0 === ve.getShaderPrecisionFormat && (ve.getShaderPrecisionFormat = function() {
                            return {
                                rangeMin: 1,
                                rangeMax: 1,
                                precision: 1
                            }
                        }
                        )
                    } catch (e) {
                        throw console.error("THREE.WebGLRenderer: " + e.message),
                        e
                    }
                    function ye() {
                        q = new pu(ve),
                        Y = new Xc(ve,q,e),
                        q.init(Y),
                        fe = new dh(ve,q,Y),
                        $ = new ch(ve,q,Y),
                        K = new gu(ve),
                        Z = new $d,
                        J = new uh(ve,q,$,Z,Y,fe,K),
                        Q = new Yc(_),
                        ee = new hu(_),
                        te = new Nc(ve,Y),
                        me = new Wc(ve,q,te,Y),
                        ne = new fu(ve,te,K,me),
                        re = new xu(ve,ne,te,K),
                        de = new yu(ve,Y,J),
                        le = new qc(Z),
                        ie = new Yd(_,Q,ee,q,Y,me,le),
                        ae = new xh(_,Z),
                        se = new Qd,
                        oe = new ah(q,Y),
                        ue = new Vc(_,Q,ee,$,re,d,o),
                        ce = new lh(_,re,Y),
                        ge = new bh(ve,K,Y,$),
                        he = new jc(ve,q,K,Y),
                        pe = new mu(ve,q,K,Y),
                        K.programs = ie.programs,
                        _.capabilities = Y,
                        _.extensions = q,
                        _.properties = Z,
                        _.renderLists = se,
                        _.shadowMap = ce,
                        _.state = $,
                        _.info = K
                    }
                    ye();
                    const xe = new vh(_,ve);
                    function be(e) {
                        e.preventDefault(),
                        console.log("THREE.WebGLRenderer: Context Lost."),
                        y = !0
                    }
                    function Ee() {
                        console.log("THREE.WebGLRenderer: Context Restored."),
                        y = !1;
                        const e = K.autoReset
                          , t = ce.enabled
                          , n = ce.autoUpdate
                          , r = ce.needsUpdate
                          , i = ce.type;
                        ye(),
                        K.autoReset = e,
                        ce.enabled = t,
                        ce.autoUpdate = n,
                        ce.needsUpdate = r,
                        ce.type = i
                    }
                    function Se(e) {
                        console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", e.statusMessage)
                    }
                    function we(e) {
                        const t = e.target;
                        t.removeEventListener("dispose", we),
                        function(e) {
                            (function(e) {
                                const t = Z.get(e).programs;
                                void 0 !== t && (t.forEach((function(e) {
                                    ie.releaseProgram(e)
                                }
                                )),
                                e.isShaderMaterial && ie.releaseShaderCache(e))
                            }
                            )(e),
                            Z.remove(e)
                        }(t)
                    }
                    function Me(e, t, n) {
                        !0 === e.transparent && 2 === e.side && !1 === e.forceSinglePass ? (e.side = pa,
                        e.needsUpdate = !0,
                        Ie(e, t, n),
                        e.side = ha,
                        e.needsUpdate = !0,
                        Ie(e, t, n),
                        e.side = 2) : Ie(e, t, n)
                    }
                    this.xr = xe,
                    this.getContext = function() {
                        return ve
                    }
                    ,
                    this.getContextAttributes = function() {
                        return ve.getContextAttributes()
                    }
                    ,
                    this.forceContextLoss = function() {
                        const e = q.get("WEBGL_lose_context");
                        e && e.loseContext()
                    }
                    ,
                    this.forceContextRestore = function() {
                        const e = q.get("WEBGL_lose_context");
                        e && e.restoreContext()
                    }
                    ,
                    this.getPixelRatio = function() {
                        return O
                    }
                    ,
                    this.setPixelRatio = function(e) {
                        void 0 !== e && (O = e,
                        this.setSize(R, L, !1))
                    }
                    ,
                    this.getSize = function(e) {
                        return e.set(R, L)
                    }
                    ,
                    this.setSize = function(e, n, r=!0) {
                        xe.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (R = e,
                        L = n,
                        t.width = Math.floor(e * O),
                        t.height = Math.floor(n * O),
                        !0 === r && (t.style.width = e + "px",
                        t.style.height = n + "px"),
                        this.setViewport(0, 0, e, n))
                    }
                    ,
                    this.getDrawingBufferSize = function(e) {
                        return e.set(R * O, L * O).floor()
                    }
                    ,
                    this.setDrawingBufferSize = function(e, n, r) {
                        R = e,
                        L = n,
                        O = r,
                        t.width = Math.floor(e * r),
                        t.height = Math.floor(n * r),
                        this.setViewport(0, 0, e, n)
                    }
                    ,
                    this.getCurrentViewport = function(e) {
                        return e.copy(M)
                    }
                    ,
                    this.getViewport = function(e) {
                        return e.copy(N)
                    }
                    ,
                    this.setViewport = function(e, t, n, r) {
                        e.isVector4 ? N.set(e.x, e.y, e.z, e.w) : N.set(e, t, n, r),
                        $.viewport(M.copy(N).multiplyScalar(O).round())
                    }
                    ,
                    this.getScissor = function(e) {
                        return e.copy(U)
                    }
                    ,
                    this.setScissor = function(e, t, n, r) {
                        e.isVector4 ? U.set(e.x, e.y, e.z, e.w) : U.set(e, t, n, r),
                        $.scissor(T.copy(U).multiplyScalar(O).round())
                    }
                    ,
                    this.getScissorTest = function() {
                        return k
                    }
                    ,
                    this.setScissorTest = function(e) {
                        $.setScissorTest(k = e)
                    }
                    ,
                    this.setOpaqueSort = function(e) {
                        D = e
                    }
                    ,
                    this.setTransparentSort = function(e) {
                        I = e
                    }
                    ,
                    this.getClearColor = function(e) {
                        return e.copy(ue.getClearColor())
                    }
                    ,
                    this.setClearColor = function() {
                        ue.setClearColor.apply(ue, arguments)
                    }
                    ,
                    this.getClearAlpha = function() {
                        return ue.getClearAlpha()
                    }
                    ,
                    this.setClearAlpha = function() {
                        ue.setClearAlpha.apply(ue, arguments)
                    }
                    ,
                    this.clear = function(e=!0, t=!0, n=!0) {
                        let r = 0;
                        if (e) {
                            let e = !1;
                            if (null !== E) {
                                const t = E.texture.format;
                                e = 1033 === t || 1031 === t || 1029 === t
                            }
                            if (e) {
                                const e = E.texture.type
                                  , t = e === Ba || e === Va || e === Ha || e === Xa || 1017 === e || 1018 === e
                                  , n = ue.getClearColor()
                                  , r = ue.getClearAlpha()
                                  , i = n.r
                                  , a = n.g
                                  , s = n.b;
                                t ? (h[0] = i,
                                h[1] = a,
                                h[2] = s,
                                h[3] = r,
                                ve.clearBufferuiv(ve.COLOR, 0, h)) : (p[0] = i,
                                p[1] = a,
                                p[2] = s,
                                p[3] = r,
                                ve.clearBufferiv(ve.COLOR, 0, p))
                            } else
                                r |= ve.COLOR_BUFFER_BIT
                        }
                        t && (r |= ve.DEPTH_BUFFER_BIT),
                        n && (r |= ve.STENCIL_BUFFER_BIT,
                        this.state.buffers.stencil.setMask(4294967295)),
                        ve.clear(r)
                    }
                    ,
                    this.clearColor = function() {
                        this.clear(!0, !1, !1)
                    }
                    ,
                    this.clearDepth = function() {
                        this.clear(!1, !0, !1)
                    }
                    ,
                    this.clearStencil = function() {
                        this.clear(!1, !1, !0)
                    }
                    ,
                    this.dispose = function() {
                        t.removeEventListener("webglcontextlost", be, !1),
                        t.removeEventListener("webglcontextrestored", Ee, !1),
                        t.removeEventListener("webglcontextcreationerror", Se, !1),
                        se.dispose(),
                        oe.dispose(),
                        Z.dispose(),
                        Q.dispose(),
                        ee.dispose(),
                        re.dispose(),
                        me.dispose(),
                        ge.dispose(),
                        ie.dispose(),
                        xe.dispose(),
                        xe.removeEventListener("sessionstart", Ae),
                        xe.removeEventListener("sessionend", Ce),
                        H && (H.dispose(),
                        H = null),
                        Pe.stop()
                    }
                    ,
                    this.renderBufferDirect = function(e, t, n, r, i, a) {
                        null === t && (t = j);
                        const s = i.isMesh && i.matrixWorld.determinant() < 0
                          , o = function(e, t, n, r, i) {
                            !0 !== t.isScene && (t = j);
                            J.resetTextureUnits();
                            const a = t.fog
                              , s = r.isMeshStandardMaterial ? t.environment : null
                              , o = null === E ? _.outputColorSpace : !0 === E.isXRRenderTarget ? E.texture.colorSpace : cs
                              , l = (r.isMeshStandardMaterial ? ee : Q).get(r.envMap || s)
                              , c = !0 === r.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize
                              , u = !!n.attributes.tangent && (!!r.normalMap || r.anisotropy > 0)
                              , d = !!n.morphAttributes.position
                              , h = !!n.morphAttributes.normal
                              , p = !!n.morphAttributes.color;
                            let f = _a;
                            r.toneMapped && (null !== E && !0 !== E.isXRRenderTarget || (f = _.toneMapping));
                            const g = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color
                              , v = void 0 !== g ? g.length : 0
                              , y = Z.get(r)
                              , x = m.state.lights;
                            if (!0 === z && (!0 === B || e !== w)) {
                                const t = e === w && r.id === S;
                                le.setState(r, e, t)
                            }
                            let b = !1;
                            r.version === y.__version ? y.needsLights && y.lightsStateVersion !== x.state.version || y.outputColorSpace !== o || i.isBatchedMesh && !1 === y.batching ? b = !0 : i.isBatchedMesh || !0 !== y.batching ? i.isInstancedMesh && !1 === y.instancing ? b = !0 : i.isInstancedMesh || !0 !== y.instancing ? i.isSkinnedMesh && !1 === y.skinning ? b = !0 : i.isSkinnedMesh || !0 !== y.skinning ? i.isInstancedMesh && !0 === y.instancingColor && null === i.instanceColor || i.isInstancedMesh && !1 === y.instancingColor && null !== i.instanceColor || i.isInstancedMesh && !0 === y.instancingMorph && null === i.morphTexture || i.isInstancedMesh && !1 === y.instancingMorph && null !== i.morphTexture || y.envMap !== l || !0 === r.fog && y.fog !== a ? b = !0 : void 0 === y.numClippingPlanes || y.numClippingPlanes === le.numPlanes && y.numIntersection === le.numIntersection ? (y.vertexAlphas !== c || y.vertexTangents !== u || y.morphTargets !== d || y.morphNormals !== h || y.morphColors !== p || y.toneMapping !== f || !0 === Y.isWebGL2 && y.morphTargetsCount !== v) && (b = !0) : b = !0 : b = !0 : b = !0 : b = !0 : (b = !0,
                            y.__version = r.version);
                            let M = y.currentProgram;
                            !0 === b && (M = Ie(r, t, i));
                            let T = !1
                              , A = !1
                              , C = !1;
                            const P = M.getUniforms()
                              , R = y.uniforms;
                            $.useProgram(M.program) && (T = !0,
                            A = !0,
                            C = !0);
                            r.id !== S && (S = r.id,
                            A = !0);
                            if (T || w !== e) {
                                P.setValue(ve, "projectionMatrix", e.projectionMatrix),
                                P.setValue(ve, "viewMatrix", e.matrixWorldInverse);
                                const t = P.map.cameraPosition;
                                void 0 !== t && t.setValue(ve, W.setFromMatrixPosition(e.matrixWorld)),
                                Y.logarithmicDepthBuffer && P.setValue(ve, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)),
                                (r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial) && P.setValue(ve, "isOrthographic", !0 === e.isOrthographicCamera),
                                w !== e && (w = e,
                                A = !0,
                                C = !0)
                            }
                            if (i.isSkinnedMesh) {
                                P.setOptional(ve, i, "bindMatrix"),
                                P.setOptional(ve, i, "bindMatrixInverse");
                                const e = i.skeleton;
                                e && (Y.floatVertexTextures ? (null === e.boneTexture && e.computeBoneTexture(),
                                P.setValue(ve, "boneTexture", e.boneTexture, J)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
                            }
                            i.isBatchedMesh && (P.setOptional(ve, i, "batchingTexture"),
                            P.setValue(ve, "batchingTexture", i._matricesTexture, J));
                            const D = n.morphAttributes;
                            (void 0 !== D.position || void 0 !== D.normal || void 0 !== D.color && !0 === Y.isWebGL2) && de.update(i, n, M);
                            (A || y.receiveShadow !== i.receiveShadow) && (y.receiveShadow = i.receiveShadow,
                            P.setValue(ve, "receiveShadow", i.receiveShadow));
                            r.isMeshGouraudMaterial && null !== r.envMap && (R.envMap.value = l,
                            R.flipEnvMap.value = l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1);
                            A && (P.setValue(ve, "toneMappingExposure", _.toneMappingExposure),
                            y.needsLights && (N = C,
                            (I = R).ambientLightColor.needsUpdate = N,
                            I.lightProbe.needsUpdate = N,
                            I.directionalLights.needsUpdate = N,
                            I.directionalLightShadows.needsUpdate = N,
                            I.pointLights.needsUpdate = N,
                            I.pointLightShadows.needsUpdate = N,
                            I.spotLights.needsUpdate = N,
                            I.spotLightShadows.needsUpdate = N,
                            I.rectAreaLights.needsUpdate = N,
                            I.hemisphereLights.needsUpdate = N),
                            a && !0 === r.fog && ae.refreshFogUniforms(R, a),
                            ae.refreshMaterialUniforms(R, r, O, L, H),
                            Td.upload(ve, Ne(y), R, J));
                            var I, N;
                            r.isShaderMaterial && !0 === r.uniformsNeedUpdate && (Td.upload(ve, Ne(y), R, J),
                            r.uniformsNeedUpdate = !1);
                            r.isSpriteMaterial && P.setValue(ve, "center", i.center);
                            if (P.setValue(ve, "modelViewMatrix", i.modelViewMatrix),
                            P.setValue(ve, "normalMatrix", i.normalMatrix),
                            P.setValue(ve, "modelMatrix", i.matrixWorld),
                            r.isShaderMaterial || r.isRawShaderMaterial) {
                                const e = r.uniformsGroups;
                                for (let t = 0, n = e.length; t < n; t++)
                                    if (Y.isWebGL2) {
                                        const n = e[t];
                                        ge.update(n, M),
                                        ge.bind(n, M)
                                    } else
                                        console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
                            }
                            return M
                        }(e, t, n, r, i);
                        $.setMaterial(r, s);
                        let l = n.index
                          , c = 1;
                        if (!0 === r.wireframe) {
                            if (l = ne.getWireframeAttribute(n),
                            void 0 === l)
                                return;
                            c = 2
                        }
                        const u = n.drawRange
                          , d = n.attributes.position;
                        let h = u.start * c
                          , p = (u.start + u.count) * c;
                        null !== a && (h = Math.max(h, a.start * c),
                        p = Math.min(p, (a.start + a.count) * c)),
                        null !== l ? (h = Math.max(h, 0),
                        p = Math.min(p, l.count)) : null != d && (h = Math.max(h, 0),
                        p = Math.min(p, d.count));
                        const f = p - h;
                        if (f < 0 || f === 1 / 0)
                            return;
                        let g;
                        me.setup(i, r, o, n, l);
                        let v = he;
                        if (null !== l && (g = te.get(l),
                        v = pe,
                        v.setIndex(g)),
                        i.isMesh)
                            !0 === r.wireframe ? ($.setLineWidth(r.wireframeLinewidth * X()),
                            v.setMode(ve.LINES)) : v.setMode(ve.TRIANGLES);
                        else if (i.isLine) {
                            let e = r.linewidth;
                            void 0 === e && (e = 1),
                            $.setLineWidth(e * X()),
                            i.isLineSegments ? v.setMode(ve.LINES) : i.isLineLoop ? v.setMode(ve.LINE_LOOP) : v.setMode(ve.LINE_STRIP)
                        } else
                            i.isPoints ? v.setMode(ve.POINTS) : i.isSprite && v.setMode(ve.TRIANGLES);
                        if (i.isBatchedMesh)
                            v.renderMultiDraw(i._multiDrawStarts, i._multiDrawCounts, i._multiDrawCount);
                        else if (i.isInstancedMesh)
                            v.renderInstances(h, f, i.count);
                        else if (n.isInstancedBufferGeometry) {
                            const e = void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0
                              , t = Math.min(n.instanceCount, e);
                            v.renderInstances(h, f, t)
                        } else
                            v.render(h, f)
                    }
                    ,
                    this.compile = function(e, t, n=null) {
                        null === n && (n = e),
                        m = oe.get(n),
                        m.init(),
                        v.push(m),
                        n.traverseVisible((function(e) {
                            e.isLight && e.layers.test(t.layers) && (m.pushLight(e),
                            e.castShadow && m.pushShadow(e))
                        }
                        )),
                        e !== n && e.traverseVisible((function(e) {
                            e.isLight && e.layers.test(t.layers) && (m.pushLight(e),
                            e.castShadow && m.pushShadow(e))
                        }
                        )),
                        m.setupLights(_._useLegacyLights);
                        const r = new Set;
                        return e.traverse((function(e) {
                            const t = e.material;
                            if (t)
                                if (Array.isArray(t))
                                    for (let i = 0; i < t.length; i++) {
                                        const a = t[i];
                                        Me(a, n, e),
                                        r.add(a)
                                    }
                                else
                                    Me(t, n, e),
                                    r.add(t)
                        }
                        )),
                        v.pop(),
                        m = null,
                        r
                    }
                    ,
                    this.compileAsync = function(e, t, n=null) {
                        const r = this.compile(e, t, n);
                        return new Promise((t => {
                            function n() {
                                r.forEach((function(e) {
                                    Z.get(e).currentProgram.isReady() && r.delete(e)
                                }
                                )),
                                0 !== r.size ? setTimeout(n, 10) : t(e)
                            }
                            null !== q.get("KHR_parallel_shader_compile") ? n() : setTimeout(n, 10)
                        }
                        ))
                    }
                    ;
                    let Te = null;
                    function Ae() {
                        Pe.stop()
                    }
                    function Ce() {
                        Pe.start()
                    }
                    const Pe = new Ic;
                    function Re(e, t, n, r) {
                        if (!1 === e.visible)
                            return;
                        if (e.layers.test(t.layers))
                            if (e.isGroup)
                                n = e.renderOrder;
                            else if (e.isLOD)
                                !0 === e.autoUpdate && e.update(t);
                            else if (e.isLight)
                                m.pushLight(e),
                                e.castShadow && m.pushShadow(e);
                            else if (e.isSprite) {
                                if (!e.frustumCulled || F.intersectsSprite(e)) {
                                    r && W.setFromMatrixPosition(e.matrixWorld).applyMatrix4(G);
                                    const t = re.update(e)
                                      , i = e.material;
                                    i.visible && f.push(e, t, i, n, W.z, null)
                                }
                            } else if ((e.isMesh || e.isLine || e.isPoints) && (!e.frustumCulled || F.intersectsObject(e))) {
                                const t = re.update(e)
                                  , i = e.material;
                                if (r && (void 0 !== e.boundingSphere ? (null === e.boundingSphere && e.computeBoundingSphere(),
                                W.copy(e.boundingSphere.center)) : (null === t.boundingSphere && t.computeBoundingSphere(),
                                W.copy(t.boundingSphere.center)),
                                W.applyMatrix4(e.matrixWorld).applyMatrix4(G)),
                                Array.isArray(i)) {
                                    const r = t.groups;
                                    for (let a = 0, s = r.length; a < s; a++) {
                                        const s = r[a]
                                          , o = i[s.materialIndex];
                                        o && o.visible && f.push(e, t, o, n, W.z, s)
                                    }
                                } else
                                    i.visible && f.push(e, t, i, n, W.z, null)
                            }
                        const i = e.children;
                        for (let e = 0, a = i.length; e < a; e++)
                            Re(i[e], t, n, r)
                    }
                    function Le(e, t, n, r) {
                        const i = e.opaque
                          , a = e.transmissive
                          , s = e.transparent;
                        m.setupLightsView(n),
                        !0 === z && le.setGlobalState(_.clippingPlanes, n),
                        a.length > 0 && function(e, t, n, r) {
                            const i = !0 === n.isScene ? n.overrideMaterial : null;
                            if (null !== i)
                                return;
                            const a = Y.isWebGL2;
                            null === H && (H = new io(1,1,{
                                generateMipmaps: !0,
                                type: q.has("EXT_color_buffer_half_float") ? ja : Ba,
                                minFilter: za,
                                samples: a ? 4 : 0
                            }));
                            _.getDrawingBufferSize(V),
                            a ? H.setSize(V.x, V.y) : H.setSize(Ls(V.x), Ls(V.y));
                            const s = _.getRenderTarget();
                            _.setRenderTarget(H),
                            _.getClearColor(C),
                            P = _.getClearAlpha(),
                            P < 1 && _.setClearColor(16777215, .5);
                            _.clear();
                            const o = _.toneMapping;
                            _.toneMapping = _a,
                            Oe(e, n, r),
                            J.updateMultisampleRenderTarget(H),
                            J.updateRenderTargetMipmap(H);
                            let l = !1;
                            for (let e = 0, i = t.length; e < i; e++) {
                                const i = t[e]
                                  , a = i.object
                                  , s = i.geometry
                                  , o = i.material
                                  , c = i.group;
                                if (2 === o.side && a.layers.test(r.layers)) {
                                    const e = o.side;
                                    o.side = pa,
                                    o.needsUpdate = !0,
                                    De(a, n, r, s, o, c),
                                    o.side = e,
                                    o.needsUpdate = !0,
                                    l = !0
                                }
                            }
                            !0 === l && (J.updateMultisampleRenderTarget(H),
                            J.updateRenderTargetMipmap(H));
                            _.setRenderTarget(s),
                            _.setClearColor(C, P),
                            _.toneMapping = o
                        }(i, a, t, n),
                        r && $.viewport(M.copy(r)),
                        i.length > 0 && Oe(i, t, n),
                        a.length > 0 && Oe(a, t, n),
                        s.length > 0 && Oe(s, t, n),
                        $.buffers.depth.setTest(!0),
                        $.buffers.depth.setMask(!0),
                        $.buffers.color.setMask(!0),
                        $.setPolygonOffset(!1)
                    }
                    function Oe(e, t, n) {
                        const r = !0 === t.isScene ? t.overrideMaterial : null;
                        for (let i = 0, a = e.length; i < a; i++) {
                            const a = e[i]
                              , s = a.object
                              , o = a.geometry
                              , l = null === r ? a.material : r
                              , c = a.group;
                            s.layers.test(n.layers) && De(s, t, n, o, l, c)
                        }
                    }
                    function De(e, t, n, r, i, a) {
                        e.onBeforeRender(_, t, n, r, i, a),
                        e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld),
                        e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
                        i.onBeforeRender(_, t, n, r, e, a),
                        !0 === i.transparent && 2 === i.side && !1 === i.forceSinglePass ? (i.side = pa,
                        i.needsUpdate = !0,
                        _.renderBufferDirect(n, t, r, i, e, a),
                        i.side = ha,
                        i.needsUpdate = !0,
                        _.renderBufferDirect(n, t, r, i, e, a),
                        i.side = 2) : _.renderBufferDirect(n, t, r, i, e, a),
                        e.onAfterRender(_, t, n, r, i, a)
                    }
                    function Ie(e, t, n) {
                        !0 !== t.isScene && (t = j);
                        const r = Z.get(e)
                          , i = m.state.lights
                          , a = m.state.shadowsArray
                          , s = i.state.version
                          , o = ie.getParameters(e, i.state, a, t, n)
                          , l = ie.getProgramCacheKey(o);
                        let c = r.programs;
                        r.environment = e.isMeshStandardMaterial ? t.environment : null,
                        r.fog = t.fog,
                        r.envMap = (e.isMeshStandardMaterial ? ee : Q).get(e.envMap || r.environment),
                        r.envMapRotation = null !== r.environment && null === e.envMap ? t.environmentRotation : e.envMapRotation,
                        void 0 === c && (e.addEventListener("dispose", we),
                        c = new Map,
                        r.programs = c);
                        let u = c.get(l);
                        if (void 0 !== u) {
                            if (r.currentProgram === u && r.lightsStateVersion === s)
                                return Ue(e, o),
                                u
                        } else
                            o.uniforms = ie.getUniforms(e),
                            e.onBuild(n, o, _),
                            e.onBeforeCompile(o, _),
                            u = ie.acquireProgram(o, l),
                            c.set(l, u),
                            r.uniforms = o.uniforms;
                        const d = r.uniforms;
                        return (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (d.clippingPlanes = le.uniform),
                        Ue(e, o),
                        r.needsLights = function(e) {
                            return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
                        }(e),
                        r.lightsStateVersion = s,
                        r.needsLights && (d.ambientLightColor.value = i.state.ambient,
                        d.lightProbe.value = i.state.probe,
                        d.directionalLights.value = i.state.directional,
                        d.directionalLightShadows.value = i.state.directionalShadow,
                        d.spotLights.value = i.state.spot,
                        d.spotLightShadows.value = i.state.spotShadow,
                        d.rectAreaLights.value = i.state.rectArea,
                        d.ltc_1.value = i.state.rectAreaLTC1,
                        d.ltc_2.value = i.state.rectAreaLTC2,
                        d.pointLights.value = i.state.point,
                        d.pointLightShadows.value = i.state.pointShadow,
                        d.hemisphereLights.value = i.state.hemi,
                        d.directionalShadowMap.value = i.state.directionalShadowMap,
                        d.directionalShadowMatrix.value = i.state.directionalShadowMatrix,
                        d.spotShadowMap.value = i.state.spotShadowMap,
                        d.spotLightMatrix.value = i.state.spotLightMatrix,
                        d.spotLightMap.value = i.state.spotLightMap,
                        d.pointShadowMap.value = i.state.pointShadowMap,
                        d.pointShadowMatrix.value = i.state.pointShadowMatrix),
                        r.currentProgram = u,
                        r.uniformsList = null,
                        u
                    }
                    function Ne(e) {
                        if (null === e.uniformsList) {
                            const t = e.currentProgram.getUniforms();
                            e.uniformsList = Td.seqWithValue(t.seq, e.uniforms)
                        }
                        return e.uniformsList
                    }
                    function Ue(e, t) {
                        const n = Z.get(e);
                        n.outputColorSpace = t.outputColorSpace,
                        n.batching = t.batching,
                        n.instancing = t.instancing,
                        n.instancingColor = t.instancingColor,
                        n.instancingMorph = t.instancingMorph,
                        n.skinning = t.skinning,
                        n.morphTargets = t.morphTargets,
                        n.morphNormals = t.morphNormals,
                        n.morphColors = t.morphColors,
                        n.morphTargetsCount = t.morphTargetsCount,
                        n.numClippingPlanes = t.numClippingPlanes,
                        n.numIntersection = t.numClipIntersection,
                        n.vertexAlphas = t.vertexAlphas,
                        n.vertexTangents = t.vertexTangents,
                        n.toneMapping = t.toneMapping
                    }
                    Pe.setAnimationLoop((function(e) {
                        Te && Te(e)
                    }
                    )),
                    "undefined" != typeof self && Pe.setContext(self),
                    this.setAnimationLoop = function(e) {
                        Te = e,
                        xe.setAnimationLoop(e),
                        null === e ? Pe.stop() : Pe.start()
                    }
                    ,
                    xe.addEventListener("sessionstart", Ae),
                    xe.addEventListener("sessionend", Ce),
                    this.render = function(e, t) {
                        if (void 0 !== t && !0 !== t.isCamera)
                            return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                        if (!0 === y)
                            return;
                        !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(),
                        null === t.parent && !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(),
                        !0 === xe.enabled && !0 === xe.isPresenting && (!0 === xe.cameraAutoUpdate && xe.updateCamera(t),
                        t = xe.getCamera()),
                        !0 === e.isScene && e.onBeforeRender(_, e, t, E),
                        m = oe.get(e, v.length),
                        m.init(),
                        v.push(m),
                        G.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                        F.setFromProjectionMatrix(G),
                        B = this.localClippingEnabled,
                        z = le.init(this.clippingPlanes, B),
                        f = se.get(e, g.length),
                        f.init(),
                        g.push(f),
                        Re(e, t, 0, _.sortObjects),
                        f.finish(),
                        !0 === _.sortObjects && f.sort(D, I),
                        this.info.render.frame++,
                        !0 === z && le.beginShadows();
                        const n = m.state.shadowsArray;
                        if (ce.render(n, e, t),
                        !0 === z && le.endShadows(),
                        !0 === this.info.autoReset && this.info.reset(),
                        !1 !== xe.enabled && !1 !== xe.isPresenting && !1 !== xe.hasDepthSensing() || ue.render(f, e),
                        m.setupLights(_._useLegacyLights),
                        t.isArrayCamera) {
                            const n = t.cameras;
                            for (let t = 0, r = n.length; t < r; t++) {
                                const r = n[t];
                                Le(f, e, r, r.viewport)
                            }
                        } else
                            Le(f, e, t);
                        null !== E && (J.updateMultisampleRenderTarget(E),
                        J.updateRenderTargetMipmap(E)),
                        !0 === e.isScene && e.onAfterRender(_, e, t),
                        me.resetDefaultState(),
                        S = -1,
                        w = null,
                        v.pop(),
                        m = v.length > 0 ? v[v.length - 1] : null,
                        g.pop(),
                        f = g.length > 0 ? g[g.length - 1] : null
                    }
                    ,
                    this.getActiveCubeFace = function() {
                        return x
                    }
                    ,
                    this.getActiveMipmapLevel = function() {
                        return b
                    }
                    ,
                    this.getRenderTarget = function() {
                        return E
                    }
                    ,
                    this.setRenderTargetTextures = function(e, t, n) {
                        Z.get(e.texture).__webglTexture = t,
                        Z.get(e.depthTexture).__webglTexture = n;
                        const r = Z.get(e);
                        r.__hasExternalTextures = !0,
                        r.__autoAllocateDepthBuffer = void 0 === n,
                        r.__autoAllocateDepthBuffer || !0 === q.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
                        r.__useRenderToTexture = !1)
                    }
                    ,
                    this.setRenderTargetFramebuffer = function(e, t) {
                        const n = Z.get(e);
                        n.__webglFramebuffer = t,
                        n.__useDefaultFramebuffer = void 0 === t
                    }
                    ,
                    this.setRenderTarget = function(e, t=0, n=0) {
                        E = e,
                        x = t,
                        b = n;
                        let r = !0
                          , i = null
                          , a = !1
                          , s = !1;
                        if (e) {
                            const o = Z.get(e);
                            void 0 !== o.__useDefaultFramebuffer ? ($.bindFramebuffer(ve.FRAMEBUFFER, null),
                            r = !1) : void 0 === o.__webglFramebuffer ? J.setupRenderTarget(e) : o.__hasExternalTextures && J.rebindTextures(e, Z.get(e.texture).__webglTexture, Z.get(e.depthTexture).__webglTexture);
                            const l = e.texture;
                            (l.isData3DTexture || l.isDataArrayTexture || l.isCompressedArrayTexture) && (s = !0);
                            const c = Z.get(e).__webglFramebuffer;
                            e.isWebGLCubeRenderTarget ? (i = Array.isArray(c[t]) ? c[t][n] : c[t],
                            a = !0) : i = Y.isWebGL2 && e.samples > 0 && !1 === J.useMultisampledRTT(e) ? Z.get(e).__webglMultisampledFramebuffer : Array.isArray(c) ? c[n] : c,
                            M.copy(e.viewport),
                            T.copy(e.scissor),
                            A = e.scissorTest
                        } else
                            M.copy(N).multiplyScalar(O).floor(),
                            T.copy(U).multiplyScalar(O).floor(),
                            A = k;
                        if ($.bindFramebuffer(ve.FRAMEBUFFER, i) && Y.drawBuffers && r && $.drawBuffers(e, i),
                        $.viewport(M),
                        $.scissor(T),
                        $.setScissorTest(A),
                        a) {
                            const r = Z.get(e.texture);
                            ve.framebufferTexture2D(ve.FRAMEBUFFER, ve.COLOR_ATTACHMENT0, ve.TEXTURE_CUBE_MAP_POSITIVE_X + t, r.__webglTexture, n)
                        } else if (s) {
                            const r = Z.get(e.texture)
                              , i = t || 0;
                            ve.framebufferTextureLayer(ve.FRAMEBUFFER, ve.COLOR_ATTACHMENT0, r.__webglTexture, n || 0, i)
                        }
                        S = -1
                    }
                    ,
                    this.readRenderTargetPixels = function(e, t, n, r, i, a, s) {
                        if (!e || !e.isWebGLRenderTarget)
                            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                        let o = Z.get(e).__webglFramebuffer;
                        if (e.isWebGLCubeRenderTarget && void 0 !== s && (o = o[s]),
                        o) {
                            $.bindFramebuffer(ve.FRAMEBUFFER, o);
                            try {
                                const s = e.texture
                                  , o = s.format
                                  , l = s.type;
                                if (o !== qa && fe.convert(o) !== ve.getParameter(ve.IMPLEMENTATION_COLOR_READ_FORMAT))
                                    return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                const c = l === ja && (q.has("EXT_color_buffer_half_float") || Y.isWebGL2 && q.has("EXT_color_buffer_float"));
                                if (!(l === Ba || fe.convert(l) === ve.getParameter(ve.IMPLEMENTATION_COLOR_READ_TYPE) || l === Wa && (Y.isWebGL2 || q.has("OES_texture_float") || q.has("WEBGL_color_buffer_float")) || c))
                                    return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                t >= 0 && t <= e.width - r && n >= 0 && n <= e.height - i && ve.readPixels(t, n, r, i, fe.convert(o), fe.convert(l), a)
                            } finally {
                                const e = null !== E ? Z.get(E).__webglFramebuffer : null;
                                $.bindFramebuffer(ve.FRAMEBUFFER, e)
                            }
                        }
                    }
                    ,
                    this.copyFramebufferToTexture = function(e, t, n=0) {
                        const r = Math.pow(2, -n)
                          , i = Math.floor(t.image.width * r)
                          , a = Math.floor(t.image.height * r);
                        J.setTexture2D(t, 0),
                        ve.copyTexSubImage2D(ve.TEXTURE_2D, n, 0, 0, e.x, e.y, i, a),
                        $.unbindTexture()
                    }
                    ,
                    this.copyTextureToTexture = function(e, t, n, r=0) {
                        const i = t.image.width
                          , a = t.image.height
                          , s = fe.convert(n.format)
                          , o = fe.convert(n.type);
                        J.setTexture2D(n, 0),
                        ve.pixelStorei(ve.UNPACK_FLIP_Y_WEBGL, n.flipY),
                        ve.pixelStorei(ve.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha),
                        ve.pixelStorei(ve.UNPACK_ALIGNMENT, n.unpackAlignment),
                        t.isDataTexture ? ve.texSubImage2D(ve.TEXTURE_2D, r, e.x, e.y, i, a, s, o, t.image.data) : t.isCompressedTexture ? ve.compressedTexSubImage2D(ve.TEXTURE_2D, r, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, s, t.mipmaps[0].data) : ve.texSubImage2D(ve.TEXTURE_2D, r, e.x, e.y, s, o, t.image),
                        0 === r && n.generateMipmaps && ve.generateMipmap(ve.TEXTURE_2D),
                        $.unbindTexture()
                    }
                    ,
                    this.copyTextureToTexture3D = function(e, t, n, r, i=0) {
                        if (_.isWebGL1Renderer)
                            return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                        const a = Math.round(e.max.x - e.min.x)
                          , s = Math.round(e.max.y - e.min.y)
                          , o = e.max.z - e.min.z + 1
                          , l = fe.convert(r.format)
                          , c = fe.convert(r.type);
                        let u;
                        if (r.isData3DTexture)
                            J.setTexture3D(r, 0),
                            u = ve.TEXTURE_3D;
                        else {
                            if (!r.isDataArrayTexture && !r.isCompressedArrayTexture)
                                return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                            J.setTexture2DArray(r, 0),
                            u = ve.TEXTURE_2D_ARRAY
                        }
                        ve.pixelStorei(ve.UNPACK_FLIP_Y_WEBGL, r.flipY),
                        ve.pixelStorei(ve.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultiplyAlpha),
                        ve.pixelStorei(ve.UNPACK_ALIGNMENT, r.unpackAlignment);
                        const d = ve.getParameter(ve.UNPACK_ROW_LENGTH)
                          , h = ve.getParameter(ve.UNPACK_IMAGE_HEIGHT)
                          , p = ve.getParameter(ve.UNPACK_SKIP_PIXELS)
                          , f = ve.getParameter(ve.UNPACK_SKIP_ROWS)
                          , m = ve.getParameter(ve.UNPACK_SKIP_IMAGES)
                          , g = n.isCompressedTexture ? n.mipmaps[i] : n.image;
                        ve.pixelStorei(ve.UNPACK_ROW_LENGTH, g.width),
                        ve.pixelStorei(ve.UNPACK_IMAGE_HEIGHT, g.height),
                        ve.pixelStorei(ve.UNPACK_SKIP_PIXELS, e.min.x),
                        ve.pixelStorei(ve.UNPACK_SKIP_ROWS, e.min.y),
                        ve.pixelStorei(ve.UNPACK_SKIP_IMAGES, e.min.z),
                        n.isDataTexture || n.isData3DTexture ? ve.texSubImage3D(u, i, t.x, t.y, t.z, a, s, o, l, c, g.data) : r.isCompressedArrayTexture ? ve.compressedTexSubImage3D(u, i, t.x, t.y, t.z, a, s, o, l, g.data) : ve.texSubImage3D(u, i, t.x, t.y, t.z, a, s, o, l, c, g),
                        ve.pixelStorei(ve.UNPACK_ROW_LENGTH, d),
                        ve.pixelStorei(ve.UNPACK_IMAGE_HEIGHT, h),
                        ve.pixelStorei(ve.UNPACK_SKIP_PIXELS, p),
                        ve.pixelStorei(ve.UNPACK_SKIP_ROWS, f),
                        ve.pixelStorei(ve.UNPACK_SKIP_IMAGES, m),
                        0 === i && r.generateMipmaps && ve.generateMipmap(u),
                        $.unbindTexture()
                    }
                    ,
                    this.initTexture = function(e) {
                        e.isCubeTexture ? J.setTextureCube(e, 0) : e.isData3DTexture ? J.setTexture3D(e, 0) : e.isDataArrayTexture || e.isCompressedArrayTexture ? J.setTexture2DArray(e, 0) : J.setTexture2D(e, 0),
                        $.unbindTexture()
                    }
                    ,
                    this.resetState = function() {
                        x = 0,
                        b = 0,
                        E = null,
                        $.reset(),
                        me.reset()
                    }
                    ,
                    "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                        detail: this
                    }))
                }
                get coordinateSystem() {
                    return xs
                }
                get outputColorSpace() {
                    return this._outputColorSpace
                }
                set outputColorSpace(e) {
                    this._outputColorSpace = e;
                    const t = this.getContext();
                    t.drawingBufferColorSpace = e === us ? "display-p3" : "srgb",
                    t.unpackColorSpace = Xs.workingColorSpace === ds ? "display-p3" : "srgb"
                }
                get useLegacyLights() {
                    return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),
                    this._useLegacyLights
                }
                set useLegacyLights(e) {
                    console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),
                    this._useLegacyLights = e
                }
            }
            (class extends Eh {
            }
            ).prototype.isWebGL1Renderer = !0;
            class Sh extends hl {
                constructor() {
                    super(),
                    this.isScene = !0,
                    this.type = "Scene",
                    this.background = null,
                    this.environment = null,
                    this.fog = null,
                    this.backgroundBlurriness = 0,
                    this.backgroundIntensity = 1,
                    this.backgroundRotation = new $o,
                    this.environmentRotation = new $o,
                    this.overrideMaterial = null,
                    "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                        detail: this
                    }))
                }
                copy(e, t) {
                    return super.copy(e, t),
                    null !== e.background && (this.background = e.background.clone()),
                    null !== e.environment && (this.environment = e.environment.clone()),
                    null !== e.fog && (this.fog = e.fog.clone()),
                    this.backgroundBlurriness = e.backgroundBlurriness,
                    this.backgroundIntensity = e.backgroundIntensity,
                    this.backgroundRotation.copy(e.backgroundRotation),
                    this.environmentRotation.copy(e.environmentRotation),
                    null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()),
                    this.matrixAutoUpdate = e.matrixAutoUpdate,
                    this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return null !== this.fog && (t.object.fog = this.fog.toJSON()),
                    this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
                    1 !== this.backgroundIntensity && (t.object.backgroundIntensity = this.backgroundIntensity),
                    t.object.backgroundRotation = this.backgroundRotation.toArray(),
                    t.object.environmentRotation = this.environmentRotation.toArray(),
                    t
                }
            }
            class wh extends Nl {
                constructor(e, t, n, r=1) {
                    super(e, t, n),
                    this.isInstancedBufferAttribute = !0,
                    this.meshPerAttribute = r
                }
                copy(e) {
                    return super.copy(e),
                    this.meshPerAttribute = e.meshPerAttribute,
                    this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.meshPerAttribute = this.meshPerAttribute,
                    e.isInstancedBufferAttribute = !0,
                    e
                }
            }
            class Mh extends vc {
                constructor(e) {
                    super(e),
                    this.isRawShaderMaterial = !0,
                    this.type = "RawShaderMaterial"
                }
            }
            function Th(e, t, n) {
                return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
            }
            function Ah(e) {
                return ArrayBuffer.isView(e) && !(e instanceof DataView)
            }
            class Ch {
                constructor(e, t, n, r) {
                    this.parameterPositions = e,
                    this._cachedIndex = 0,
                    this.resultBuffer = void 0 !== r ? r : new t.constructor(n),
                    this.sampleValues = t,
                    this.valueSize = n,
                    this.settings = null,
                    this.DefaultSettings_ = {}
                }
                evaluate(e) {
                    const t = this.parameterPositions;
                    let n = this._cachedIndex
                      , r = t[n]
                      , i = t[n - 1];
                    e: {
                        t: {
                            let a;
                            n: {
                                r: if (!(e < r)) {
                                    for (let a = n + 2; ; ) {
                                        if (void 0 === r) {
                                            if (e < i)
                                                break r;
                                            return n = t.length,
                                            this._cachedIndex = n,
                                            this.copySampleValue_(n - 1)
                                        }
                                        if (n === a)
                                            break;
                                        if (i = r,
                                        r = t[++n],
                                        e < r)
                                            break t
                                    }
                                    a = t.length;
                                    break n
                                }
                                if (e >= i)
                                    break e;
                                {
                                    const s = t[1];
                                    e < s && (n = 2,
                                    i = s);
                                    for (let a = n - 2; ; ) {
                                        if (void 0 === i)
                                            return this._cachedIndex = 0,
                                            this.copySampleValue_(0);
                                        if (n === a)
                                            break;
                                        if (r = i,
                                        i = t[--n - 1],
                                        e >= i)
                                            break t
                                    }
                                    a = n,
                                    n = 0
                                }
                            }
                            for (; n < a; ) {
                                const r = n + a >>> 1;
                                e < t[r] ? a = r : n = r + 1
                            }
                            if (r = t[n],
                            i = t[n - 1],
                            void 0 === i)
                                return this._cachedIndex = 0,
                                this.copySampleValue_(0);
                            if (void 0 === r)
                                return n = t.length,
                                this._cachedIndex = n,
                                this.copySampleValue_(n - 1)
                        }
                        this._cachedIndex = n,
                        this.intervalChanged_(n, i, r)
                    }
                    return this.interpolate_(n, i, e, r)
                }
                getSettings_() {
                    return this.settings || this.DefaultSettings_
                }
                copySampleValue_(e) {
                    const t = this.resultBuffer
                      , n = this.sampleValues
                      , r = this.valueSize
                      , i = e * r;
                    for (let e = 0; e !== r; ++e)
                        t[e] = n[i + e];
                    return t
                }
                interpolate_() {
                    throw new Error("call to abstract method")
                }
                intervalChanged_() {}
            }
            class Ph extends Ch {
                constructor(e, t, n, r) {
                    super(e, t, n, r),
                    this._weightPrev = -0,
                    this._offsetPrev = -0,
                    this._weightNext = -0,
                    this._offsetNext = -0,
                    this.DefaultSettings_ = {
                        endingStart: is,
                        endingEnd: is
                    }
                }
                intervalChanged_(e, t, n) {
                    const r = this.parameterPositions;
                    let i = e - 2
                      , a = e + 1
                      , s = r[i]
                      , o = r[a];
                    if (void 0 === s)
                        switch (this.getSettings_().endingStart) {
                        case as:
                            i = e,
                            s = 2 * t - n;
                            break;
                        case ss:
                            i = r.length - 2,
                            s = t + r[i] - r[i + 1];
                            break;
                        default:
                            i = e,
                            s = n
                        }
                    if (void 0 === o)
                        switch (this.getSettings_().endingEnd) {
                        case as:
                            a = e,
                            o = 2 * n - t;
                            break;
                        case ss:
                            a = 1,
                            o = n + r[1] - r[0];
                            break;
                        default:
                            a = e - 1,
                            o = t
                        }
                    const l = .5 * (n - t)
                      , c = this.valueSize;
                    this._weightPrev = l / (t - s),
                    this._weightNext = l / (o - n),
                    this._offsetPrev = i * c,
                    this._offsetNext = a * c
                }
                interpolate_(e, t, n, r) {
                    const i = this.resultBuffer
                      , a = this.sampleValues
                      , s = this.valueSize
                      , o = e * s
                      , l = o - s
                      , c = this._offsetPrev
                      , u = this._offsetNext
                      , d = this._weightPrev
                      , h = this._weightNext
                      , p = (n - t) / (r - t)
                      , f = p * p
                      , m = f * p
                      , g = -d * m + 2 * d * f - d * p
                      , v = (1 + d) * m + (-1.5 - 2 * d) * f + (-.5 + d) * p + 1
                      , _ = (-1 - h) * m + (1.5 + h) * f + .5 * p
                      , y = h * m - h * f;
                    for (let e = 0; e !== s; ++e)
                        i[e] = g * a[c + e] + v * a[l + e] + _ * a[o + e] + y * a[u + e];
                    return i
                }
            }
            class Rh extends Ch {
                constructor(e, t, n, r) {
                    super(e, t, n, r)
                }
                interpolate_(e, t, n, r) {
                    const i = this.resultBuffer
                      , a = this.sampleValues
                      , s = this.valueSize
                      , o = e * s
                      , l = o - s
                      , c = (n - t) / (r - t)
                      , u = 1 - c;
                    for (let e = 0; e !== s; ++e)
                        i[e] = a[l + e] * u + a[o + e] * c;
                    return i
                }
            }
            class Lh extends Ch {
                constructor(e, t, n, r) {
                    super(e, t, n, r)
                }
                interpolate_(e) {
                    return this.copySampleValue_(e - 1)
                }
            }
            class Oh {
                constructor(e, t, n, r) {
                    if (void 0 === e)
                        throw new Error("THREE.KeyframeTrack: track name is undefined");
                    if (void 0 === t || 0 === t.length)
                        throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                    this.name = e,
                    this.times = Th(t, this.TimeBufferType),
                    this.values = Th(n, this.ValueBufferType),
                    this.setInterpolation(r || this.DefaultInterpolation)
                }
                static toJSON(e) {
                    const t = e.constructor;
                    let n;
                    if (t.toJSON !== this.toJSON)
                        n = t.toJSON(e);
                    else {
                        n = {
                            name: e.name,
                            times: Th(e.times, Array),
                            values: Th(e.values, Array)
                        };
                        const t = e.getInterpolation();
                        t !== e.DefaultInterpolation && (n.interpolation = t)
                    }
                    return n.type = e.ValueTypeName,
                    n
                }
                InterpolantFactoryMethodDiscrete(e) {
                    return new Lh(this.times,this.values,this.getValueSize(),e)
                }
                InterpolantFactoryMethodLinear(e) {
                    return new Rh(this.times,this.values,this.getValueSize(),e)
                }
                InterpolantFactoryMethodSmooth(e) {
                    return new Ph(this.times,this.values,this.getValueSize(),e)
                }
                setInterpolation(e) {
                    let t;
                    switch (e) {
                    case ts:
                        t = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case ns:
                        t = this.InterpolantFactoryMethodLinear;
                        break;
                    case rs:
                        t = this.InterpolantFactoryMethodSmooth
                    }
                    if (void 0 === t) {
                        const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                        if (void 0 === this.createInterpolant) {
                            if (e === this.DefaultInterpolation)
                                throw new Error(t);
                            this.setInterpolation(this.DefaultInterpolation)
                        }
                        return console.warn("THREE.KeyframeTrack:", t),
                        this
                    }
                    return this.createInterpolant = t,
                    this
                }
                getInterpolation() {
                    switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return ts;
                    case this.InterpolantFactoryMethodLinear:
                        return ns;
                    case this.InterpolantFactoryMethodSmooth:
                        return rs
                    }
                }
                getValueSize() {
                    return this.values.length / this.times.length
                }
                shift(e) {
                    if (0 !== e) {
                        const t = this.times;
                        for (let n = 0, r = t.length; n !== r; ++n)
                            t[n] += e
                    }
                    return this
                }
                scale(e) {
                    if (1 !== e) {
                        const t = this.times;
                        for (let n = 0, r = t.length; n !== r; ++n)
                            t[n] *= e
                    }
                    return this
                }
                trim(e, t) {
                    const n = this.times
                      , r = n.length;
                    let i = 0
                      , a = r - 1;
                    for (; i !== r && n[i] < e; )
                        ++i;
                    for (; -1 !== a && n[a] > t; )
                        --a;
                    if (++a,
                    0 !== i || a !== r) {
                        i >= a && (a = Math.max(a, 1),
                        i = a - 1);
                        const e = this.getValueSize();
                        this.times = n.slice(i, a),
                        this.values = this.values.slice(i * e, a * e)
                    }
                    return this
                }
                validate() {
                    let e = !0;
                    const t = this.getValueSize();
                    t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
                    e = !1);
                    const n = this.times
                      , r = this.values
                      , i = n.length;
                    0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this),
                    e = !1);
                    let a = null;
                    for (let t = 0; t !== i; t++) {
                        const r = n[t];
                        if ("number" == typeof r && isNaN(r)) {
                            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, t, r),
                            e = !1;
                            break
                        }
                        if (null !== a && a > r) {
                            console.error("THREE.KeyframeTrack: Out of order keys.", this, t, r, a),
                            e = !1;
                            break
                        }
                        a = r
                    }
                    if (void 0 !== r && Ah(r))
                        for (let t = 0, n = r.length; t !== n; ++t) {
                            const n = r[t];
                            if (isNaN(n)) {
                                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, t, n),
                                e = !1;
                                break
                            }
                        }
                    return e
                }
                optimize() {
                    const e = this.times.slice()
                      , t = this.values.slice()
                      , n = this.getValueSize()
                      , r = this.getInterpolation() === rs
                      , i = e.length - 1;
                    let a = 1;
                    for (let s = 1; s < i; ++s) {
                        let i = !1;
                        const o = e[s];
                        if (o !== e[s + 1] && (1 !== s || o !== e[0]))
                            if (r)
                                i = !0;
                            else {
                                const e = s * n
                                  , r = e - n
                                  , a = e + n;
                                for (let s = 0; s !== n; ++s) {
                                    const n = t[e + s];
                                    if (n !== t[r + s] || n !== t[a + s]) {
                                        i = !0;
                                        break
                                    }
                                }
                            }
                        if (i) {
                            if (s !== a) {
                                e[a] = e[s];
                                const r = s * n
                                  , i = a * n;
                                for (let e = 0; e !== n; ++e)
                                    t[i + e] = t[r + e]
                            }
                            ++a
                        }
                    }
                    if (i > 0) {
                        e[a] = e[i];
                        for (let e = i * n, r = a * n, s = 0; s !== n; ++s)
                            t[r + s] = t[e + s];
                        ++a
                    }
                    return a !== e.length ? (this.times = e.slice(0, a),
                    this.values = t.slice(0, a * n)) : (this.times = e,
                    this.values = t),
                    this
                }
                clone() {
                    const e = this.times.slice()
                      , t = this.values.slice()
                      , n = new (0,
                    this.constructor)(this.name,e,t);
                    return n.createInterpolant = this.createInterpolant,
                    n
                }
            }
            Oh.prototype.TimeBufferType = Float32Array,
            Oh.prototype.ValueBufferType = Float32Array,
            Oh.prototype.DefaultInterpolation = ns;
            class Dh extends Oh {
            }
            Dh.prototype.ValueTypeName = "bool",
            Dh.prototype.ValueBufferType = Array,
            Dh.prototype.DefaultInterpolation = ts,
            Dh.prototype.InterpolantFactoryMethodLinear = void 0,
            Dh.prototype.InterpolantFactoryMethodSmooth = void 0;
            class Ih extends Oh {
            }
            Ih.prototype.ValueTypeName = "color";
            class Nh extends Oh {
            }
            Nh.prototype.ValueTypeName = "number";
            class Uh extends Ch {
                constructor(e, t, n, r) {
                    super(e, t, n, r)
                }
                interpolate_(e, t, n, r) {
                    const i = this.resultBuffer
                      , a = this.sampleValues
                      , s = this.valueSize
                      , o = (n - t) / (r - t);
                    let l = e * s;
                    for (let e = l + s; l !== e; l += 4)
                        oo.slerpFlat(i, 0, a, l - s, a, l, o);
                    return i
                }
            }
            class kh extends Oh {
                InterpolantFactoryMethodLinear(e) {
                    return new Uh(this.times,this.values,this.getValueSize(),e)
                }
            }
            kh.prototype.ValueTypeName = "quaternion",
            kh.prototype.DefaultInterpolation = ns,
            kh.prototype.InterpolantFactoryMethodSmooth = void 0;
            class Fh extends Oh {
            }
            Fh.prototype.ValueTypeName = "string",
            Fh.prototype.ValueBufferType = Array,
            Fh.prototype.DefaultInterpolation = ts,
            Fh.prototype.InterpolantFactoryMethodLinear = void 0,
            Fh.prototype.InterpolantFactoryMethodSmooth = void 0;
            class zh extends Oh {
            }
            zh.prototype.ValueTypeName = "vector";
            const Bh = {
                enabled: !1,
                files: {},
                add: function(e, t) {
                    !1 !== this.enabled && (this.files[e] = t)
                },
                get: function(e) {
                    if (!1 !== this.enabled)
                        return this.files[e]
                },
                remove: function(e) {
                    delete this.files[e]
                },
                clear: function() {
                    this.files = {}
                }
            };
            class Hh {
                constructor(e, t, n) {
                    const r = this;
                    let i, a = !1, s = 0, o = 0;
                    const l = [];
                    this.onStart = void 0,
                    this.onLoad = e,
                    this.onProgress = t,
                    this.onError = n,
                    this.itemStart = function(e) {
                        o++,
                        !1 === a && void 0 !== r.onStart && r.onStart(e, s, o),
                        a = !0
                    }
                    ,
                    this.itemEnd = function(e) {
                        s++,
                        void 0 !== r.onProgress && r.onProgress(e, s, o),
                        s === o && (a = !1,
                        void 0 !== r.onLoad && r.onLoad())
                    }
                    ,
                    this.itemError = function(e) {
                        void 0 !== r.onError && r.onError(e)
                    }
                    ,
                    this.resolveURL = function(e) {
                        return i ? i(e) : e
                    }
                    ,
                    this.setURLModifier = function(e) {
                        return i = e,
                        this
                    }
                    ,
                    this.addHandler = function(e, t) {
                        return l.push(e, t),
                        this
                    }
                    ,
                    this.removeHandler = function(e) {
                        const t = l.indexOf(e);
                        return -1 !== t && l.splice(t, 2),
                        this
                    }
                    ,
                    this.getHandler = function(e) {
                        for (let t = 0, n = l.length; t < n; t += 2) {
                            const n = l[t]
                              , r = l[t + 1];
                            if (n.global && (n.lastIndex = 0),
                            n.test(e))
                                return r
                        }
                        return null
                    }
                }
            }
            const Gh = new Hh;
            class Vh {
                constructor(e) {
                    this.manager = void 0 !== e ? e : Gh,
                    this.crossOrigin = "anonymous",
                    this.withCredentials = !1,
                    this.path = "",
                    this.resourcePath = "",
                    this.requestHeader = {}
                }
                load() {}
                loadAsync(e, t) {
                    const n = this;
                    return new Promise((function(r, i) {
                        n.load(e, r, t, i)
                    }
                    ))
                }
                parse() {}
                setCrossOrigin(e) {
                    return this.crossOrigin = e,
                    this
                }
                setWithCredentials(e) {
                    return this.withCredentials = e,
                    this
                }
                setPath(e) {
                    return this.path = e,
                    this
                }
                setResourcePath(e) {
                    return this.resourcePath = e,
                    this
                }
                setRequestHeader(e) {
                    return this.requestHeader = e,
                    this
                }
            }
            Vh.DEFAULT_MATERIAL_NAME = "__DEFAULT";
            Error;
            class Wh extends Vh {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    void 0 !== this.path && (e = this.path + e),
                    e = this.manager.resolveURL(e);
                    const i = this
                      , a = Bh.get(e);
                    if (void 0 !== a)
                        return i.manager.itemStart(e),
                        setTimeout((function() {
                            t && t(a),
                            i.manager.itemEnd(e)
                        }
                        ), 0),
                        a;
                    const s = Fs("img");
                    function o() {
                        c(),
                        Bh.add(e, this),
                        t && t(this),
                        i.manager.itemEnd(e)
                    }
                    function l(t) {
                        c(),
                        r && r(t),
                        i.manager.itemError(e),
                        i.manager.itemEnd(e)
                    }
                    function c() {
                        s.removeEventListener("load", o, !1),
                        s.removeEventListener("error", l, !1)
                    }
                    return s.addEventListener("load", o, !1),
                    s.addEventListener("error", l, !1),
                    "data:" !== e.slice(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin),
                    i.manager.itemStart(e),
                    s.src = e,
                    s
                }
            }
            class jh extends Vh {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    const i = new to
                      , a = new Wh(this.manager);
                    return a.setCrossOrigin(this.crossOrigin),
                    a.setPath(this.path),
                    a.load(e, (function(e) {
                        i.image = e,
                        i.needsUpdate = !0,
                        void 0 !== t && t(i)
                    }
                    ), n, r),
                    i
                }
            }
            class Xh extends Xl {
                constructor() {
                    super(),
                    this.isInstancedBufferGeometry = !0,
                    this.type = "InstancedBufferGeometry",
                    this.instanceCount = 1 / 0
                }
                copy(e) {
                    return super.copy(e),
                    this.instanceCount = e.instanceCount,
                    this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.instanceCount = this.instanceCount,
                    e.isInstancedBufferGeometry = !0,
                    e
                }
            }
            class qh {
                constructor(e=!0) {
                    this.autoStart = e,
                    this.startTime = 0,
                    this.oldTime = 0,
                    this.elapsedTime = 0,
                    this.running = !1
                }
                start() {
                    this.startTime = Yh(),
                    this.oldTime = this.startTime,
                    this.elapsedTime = 0,
                    this.running = !0
                }
                stop() {
                    this.getElapsedTime(),
                    this.running = !1,
                    this.autoStart = !1
                }
                getElapsedTime() {
                    return this.getDelta(),
                    this.elapsedTime
                }
                getDelta() {
                    let e = 0;
                    if (this.autoStart && !this.running)
                        return this.start(),
                        0;
                    if (this.running) {
                        const t = Yh();
                        e = (t - this.oldTime) / 1e3,
                        this.oldTime = t,
                        this.elapsedTime += e
                    }
                    return e
                }
            }
            function Yh() {
                return ("undefined" == typeof performance ? Date : performance).now()
            }
            const $h = "\\[\\]\\.:\\/"
              , Kh = new RegExp("[" + $h + "]","g")
              , Zh = "[^" + $h + "]"
              , Jh = "[^" + $h.replace("\\.", "") + "]"
              , Qh = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", Zh) + /(WCOD+)?/.source.replace("WCOD", Jh) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Zh) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Zh) + "$")
              , ep = ["material", "materials", "bones", "map"];
            class tp {
                constructor(e, t, n) {
                    this.path = t,
                    this.parsedPath = n || tp.parseTrackName(t),
                    this.node = tp.findNode(e, this.parsedPath.nodeName),
                    this.rootNode = e,
                    this.getValue = this._getValue_unbound,
                    this.setValue = this._setValue_unbound
                }
                static create(e, t, n) {
                    return e && e.isAnimationObjectGroup ? new tp.Composite(e,t,n) : new tp(e,t,n)
                }
                static sanitizeNodeName(e) {
                    return e.replace(/\s/g, "_").replace(Kh, "")
                }
                static parseTrackName(e) {
                    const t = Qh.exec(e);
                    if (null === t)
                        throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                    const n = {
                        nodeName: t[2],
                        objectName: t[3],
                        objectIndex: t[4],
                        propertyName: t[5],
                        propertyIndex: t[6]
                    }
                      , r = n.nodeName && n.nodeName.lastIndexOf(".");
                    if (void 0 !== r && -1 !== r) {
                        const e = n.nodeName.substring(r + 1);
                        -1 !== ep.indexOf(e) && (n.nodeName = n.nodeName.substring(0, r),
                        n.objectName = e)
                    }
                    if (null === n.propertyName || 0 === n.propertyName.length)
                        throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                    return n
                }
                static findNode(e, t) {
                    if (void 0 === t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid)
                        return e;
                    if (e.skeleton) {
                        const n = e.skeleton.getBoneByName(t);
                        if (void 0 !== n)
                            return n
                    }
                    if (e.children) {
                        const n = function(e) {
                            for (let r = 0; r < e.length; r++) {
                                const i = e[r];
                                if (i.name === t || i.uuid === t)
                                    return i;
                                const a = n(i.children);
                                if (a)
                                    return a
                            }
                            return null
                        }
                          , r = n(e.children);
                        if (r)
                            return r
                    }
                    return null
                }
                _getValue_unavailable() {}
                _setValue_unavailable() {}
                _getValue_direct(e, t) {
                    e[t] = this.targetObject[this.propertyName]
                }
                _getValue_array(e, t) {
                    const n = this.resolvedProperty;
                    for (let r = 0, i = n.length; r !== i; ++r)
                        e[t++] = n[r]
                }
                _getValue_arrayElement(e, t) {
                    e[t] = this.resolvedProperty[this.propertyIndex]
                }
                _getValue_toArray(e, t) {
                    this.resolvedProperty.toArray(e, t)
                }
                _setValue_direct(e, t) {
                    this.targetObject[this.propertyName] = e[t]
                }
                _setValue_direct_setNeedsUpdate(e, t) {
                    this.targetObject[this.propertyName] = e[t],
                    this.targetObject.needsUpdate = !0
                }
                _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
                    this.targetObject[this.propertyName] = e[t],
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_array(e, t) {
                    const n = this.resolvedProperty;
                    for (let r = 0, i = n.length; r !== i; ++r)
                        n[r] = e[t++]
                }
                _setValue_array_setNeedsUpdate(e, t) {
                    const n = this.resolvedProperty;
                    for (let r = 0, i = n.length; r !== i; ++r)
                        n[r] = e[t++];
                    this.targetObject.needsUpdate = !0
                }
                _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
                    const n = this.resolvedProperty;
                    for (let r = 0, i = n.length; r !== i; ++r)
                        n[r] = e[t++];
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_arrayElement(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t]
                }
                _setValue_arrayElement_setNeedsUpdate(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t],
                    this.targetObject.needsUpdate = !0
                }
                _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t],
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_fromArray(e, t) {
                    this.resolvedProperty.fromArray(e, t)
                }
                _setValue_fromArray_setNeedsUpdate(e, t) {
                    this.resolvedProperty.fromArray(e, t),
                    this.targetObject.needsUpdate = !0
                }
                _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
                    this.resolvedProperty.fromArray(e, t),
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _getValue_unbound(e, t) {
                    this.bind(),
                    this.getValue(e, t)
                }
                _setValue_unbound(e, t) {
                    this.bind(),
                    this.setValue(e, t)
                }
                bind() {
                    let e = this.node;
                    const t = this.parsedPath
                      , n = t.objectName
                      , r = t.propertyName;
                    let i = t.propertyIndex;
                    if (e || (e = tp.findNode(this.rootNode, t.nodeName),
                    this.node = e),
                    this.getValue = this._getValue_unavailable,
                    this.setValue = this._setValue_unavailable,
                    !e)
                        return void console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
                    if (n) {
                        let r = t.objectIndex;
                        switch (n) {
                        case "materials":
                            if (!e.material)
                                return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!e.material.materials)
                                return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            e = e.material.materials;
                            break;
                        case "bones":
                            if (!e.skeleton)
                                return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            e = e.skeleton.bones;
                            for (let t = 0; t < e.length; t++)
                                if (e[t].name === r) {
                                    r = t;
                                    break
                                }
                            break;
                        case "map":
                            if ("map"in e) {
                                e = e.map;
                                break
                            }
                            if (!e.material)
                                return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!e.material.map)
                                return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                            e = e.material.map;
                            break;
                        default:
                            if (void 0 === e[n])
                                return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            e = e[n]
                        }
                        if (void 0 !== r) {
                            if (void 0 === e[r])
                                return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                            e = e[r]
                        }
                    }
                    const a = e[r];
                    if (void 0 === a) {
                        const n = t.nodeName;
                        return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + r + " but it wasn't found.", e)
                    }
                    let s = this.Versioning.None;
                    this.targetObject = e,
                    void 0 !== e.needsUpdate ? s = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (s = this.Versioning.MatrixWorldNeedsUpdate);
                    let o = this.BindingType.Direct;
                    if (void 0 !== i) {
                        if ("morphTargetInfluences" === r) {
                            if (!e.geometry)
                                return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (!e.geometry.morphAttributes)
                                return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                            void 0 !== e.morphTargetDictionary[i] && (i = e.morphTargetDictionary[i])
                        }
                        o = this.BindingType.ArrayElement,
                        this.resolvedProperty = a,
                        this.propertyIndex = i
                    } else
                        void 0 !== a.fromArray && void 0 !== a.toArray ? (o = this.BindingType.HasFromToArray,
                        this.resolvedProperty = a) : Array.isArray(a) ? (o = this.BindingType.EntireArray,
                        this.resolvedProperty = a) : this.propertyName = r;
                    this.getValue = this.GetterByBindingType[o],
                    this.setValue = this.SetterByBindingTypeAndVersioning[o][s]
                }
                unbind() {
                    this.node = null,
                    this.getValue = this._getValue_unbound,
                    this.setValue = this._setValue_unbound
                }
            }
            tp.Composite = class {
                constructor(e, t, n) {
                    const r = n || tp.parseTrackName(t);
                    this._targetGroup = e,
                    this._bindings = e.subscribe_(t, r)
                }
                getValue(e, t) {
                    this.bind();
                    const n = this._targetGroup.nCachedObjects_
                      , r = this._bindings[n];
                    void 0 !== r && r.getValue(e, t)
                }
                setValue(e, t) {
                    const n = this._bindings;
                    for (let r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r)
                        n[r].setValue(e, t)
                }
                bind() {
                    const e = this._bindings;
                    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
                        e[t].bind()
                }
                unbind() {
                    const e = this._bindings;
                    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
                        e[t].unbind()
                }
            }
            ,
            tp.prototype.BindingType = {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            },
            tp.prototype.Versioning = {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            },
            tp.prototype.GetterByBindingType = [tp.prototype._getValue_direct, tp.prototype._getValue_array, tp.prototype._getValue_arrayElement, tp.prototype._getValue_toArray],
            tp.prototype.SetterByBindingTypeAndVersioning = [[tp.prototype._setValue_direct, tp.prototype._setValue_direct_setNeedsUpdate, tp.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [tp.prototype._setValue_array, tp.prototype._setValue_array_setNeedsUpdate, tp.prototype._setValue_array_setMatrixWorldNeedsUpdate], [tp.prototype._setValue_arrayElement, tp.prototype._setValue_arrayElement_setNeedsUpdate, tp.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [tp.prototype._setValue_fromArray, tp.prototype._setValue_fromArray_setNeedsUpdate, tp.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
            new Float32Array(1);
            const np = new zo;
            class rp {
                constructor(e, t, n=0, r=1 / 0) {
                    this.ray = new Fo(e,t),
                    this.near = n,
                    this.far = r,
                    this.camera = null,
                    this.layers = new Ko,
                    this.params = {
                        Mesh: {},
                        Line: {
                            threshold: 1
                        },
                        LOD: {},
                        Points: {
                            threshold: 1
                        },
                        Sprite: {}
                    }
                }
                set(e, t) {
                    this.ray.set(e, t)
                }
                setFromCamera(e, t) {
                    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
                    this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(),
                    this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
                    this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
                    this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
                }
                setFromXRController(e) {
                    return np.identity().extractRotation(e.matrixWorld),
                    this.ray.origin.setFromMatrixPosition(e.matrixWorld),
                    this.ray.direction.set(0, 0, -1).applyMatrix4(np),
                    this
                }
                intersectObject(e, t=!0, n=[]) {
                    return ap(e, this, n, t),
                    n.sort(ip),
                    n
                }
                intersectObjects(e, t=!0, n=[]) {
                    for (let r = 0, i = e.length; r < i; r++)
                        ap(e[r], this, n, t);
                    return n.sort(ip),
                    n
                }
            }
            function ip(e, t) {
                return e.distance - t.distance
            }
            function ap(e, t, n, r) {
                if (e.layers.test(t.layers) && e.raycast(t, n),
                !0 === r) {
                    const r = e.children;
                    for (let e = 0, i = r.length; e < i; e++)
                        ap(r[e], t, n, !0)
                }
            }
            "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
                detail: {
                    revision: la
                }
            })),
            "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = la);
            var sp = n(7)
              , op = n.n(sp)
              , lp = n(606)
              , cp = Object.assign || function(e) {
                for (var t, n = 1, r = arguments.length; n < r; n++)
                    for (var i in t = arguments[n])
                        Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
                return e
            }
              , up = [["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/], ["opera", /Opera\/([0-9\.]+)(?:\s|$)/], ["opera", /OPR\/([0-9\.]+)(:?\s|$)$/], ["edge", /Edge\/([0-9\._]+)/], ["ie", /Trident\/7\.0.*rv\:([0-9\.]+)\).*Gecko$/], ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/], ["ie", /MSIE\s(7\.0)/], ["safari", /Version\/([0-9\._]+).*Safari/], ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/], ["android", /Android\s([0-9\.]+)/], ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/], ["yandexbrowser", /YaBrowser\/([0-9\._]+)/], ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/]]
              , dp = ["Windows Phone", "Android", "CentOS", {
                name: "Chrome OS",
                pattern: "CrOS"
            }, "Debian", "Fedora", "FreeBSD", "Gentoo", "Haiku", "Kubuntu", "Linux Mint", "OpenBSD", "Red Hat", "SuSE", "Ubuntu", "Xubuntu", "Cygwin", "Symbian OS", "hpwOS", "webOS ", "webOS", "Tablet OS", "Tizen", "Linux", "Mac OS X", "Macintosh", "Mac", "Windows 98;", "Windows "]
              , hp = {
                "10.0": "10",
                6.4: "10 Technical Preview",
                6.3: "8.1",
                6.2: "8",
                6.1: "Server 2008 R2 / 7",
                "6.0": "Server 2008 / Vista",
                5.2: "Server 2003 / XP 64-bit",
                5.1: "XP",
                5.01: "2000 SP1",
                "5.0": "2000",
                "4.0": "NT",
                "4.90": "ME"
            }
              , pp = new RegExp(["(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|", "compal|elaine|fennec|hiptop|iemobile|ip(hone|od|ad)|iris|kindle|lge |maemo|", "midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)", "\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|", "wap|windows ce|xda|xiino"].join(""),"i")
              , fp = new RegExp(["1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|", "ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|", "avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|", "cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|", "ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|", "g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|", "hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|", "i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|", "kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])", "|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|", "mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|", "n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|", "op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|", "po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|", "raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|", "se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|k\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|", "so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|", "tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|", "veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|", "w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-"].join(""),"i")
              , mp = function() {
                function e(e, t, n) {
                    this.navigator = t,
                    this.process = n,
                    this.userAgent = e || (this.navigator ? t.userAgent || t.vendor : "")
                }
                return e.prototype.detect = function() {
                    if (this.process && !this.userAgent) {
                        var e = this.process.version.slice(1).split(".").slice(0, 3)
                          , t = Array.prototype.slice.call(e, 1).join("") || "0";
                        return {
                            name: "node",
                            version: e.join("."),
                            versionNumber: parseFloat(e[0] + "." + t),
                            mobile: !1,
                            os: this.process.platform
                        }
                    }
                    return this.userAgent || this.handleMissingError(),
                    cp({}, this.checkBrowser(), this.checkMobile(), this.checkOs())
                }
                ,
                e.prototype.checkBrowser = function() {
                    var e = this;
                    return up.filter((function(t) {
                        return t[1].test(e.userAgent)
                    }
                    )).map((function(t) {
                        var n = t[1].exec(e.userAgent)
                          , r = n && n[1].split(/[._]/).slice(0, 3)
                          , i = Array.prototype.slice.call(r, 1).join("") || "0";
                        return r && r.length < 3 && Array.prototype.push.apply(r, 1 === r.length ? [0, 0] : [0]),
                        {
                            name: String(t[0]),
                            version: r.join("."),
                            versionNumber: Number(r[0] + "." + i)
                        }
                    }
                    )).shift()
                }
                ,
                e.prototype.checkMobile = function() {
                    var e = this.userAgent.substr(0, 4);
                    return {
                        mobile: pp.test(this.userAgent) || fp.test(e)
                    }
                }
                ,
                e.prototype.checkOs = function() {
                    var e = this;
                    return dp.map((function(t) {
                        var n = t.name || t
                          , r = e.getOsPattern(t);
                        return {
                            name: n,
                            pattern: r,
                            value: RegExp("\\b" + r.replace(/([ -])(?!$)/g, "$1?") + "(?:x?[\\d._]+|[ \\w.]*)", "i").exec(e.userAgent)
                        }
                    }
                    )).filter((function(e) {
                        return e.value
                    }
                    )).map((function(e) {
                        var t, n = e.value[0] || "";
                        return e.pattern && e.name && /^Win/i.test(n) && !/^Windows Phone /i.test(n) && (t = hp[n.replace(/[^\d.]/g, "")]) && (n = "Windows " + t),
                        e.pattern && e.name && (n = n.replace(RegExp(e.pattern, "i"), e.name)),
                        n = n.replace(/ ce$/i, " CE").replace(/\bhpw/i, "web").replace(/\bMacintosh\b/, "Mac OS").replace(/_PowerPC\b/i, " OS").replace(/\b(OS X) [^ \d]+/i, "$1").replace(/\bMac (OS X)\b/, "$1").replace(/\/(\d)/, " $1").replace(/_/g, ".").replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, "").replace(/\bx86\.64\b/gi, "x86_64").replace(/\b(Windows Phone) OS\b/, "$1").replace(/\b(Chrome OS \w+) [\d.]+\b/, "$1").split(" on ")[0].trim(),
                        {
                            os: n = /^(?:webOS|i(?:OS|P))/.test(n) ? n : n.charAt(0).toUpperCase() + n.slice(1)
                        }
                    }
                    )).shift()
                }
                ,
                e.prototype.getOsPattern = function(e) {
                    var t = e;
                    return ("string" == typeof e ? e : void 0) || t.pattern || t.name
                }
                ,
                e.prototype.handleMissingError = function() {
                    throw new Error("Please give user-agent.\n> browser(navigator.userAgent or res.headers['user-agent']).")
                }
                ,
                e
            }();
            function gp(e, t) {
                return e(t = {
                    exports: {}
                }, t.exports),
                t.exports
            }
            var vp = gp((function(e) {
                var t = e.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
                "number" == typeof __g && (__g = t)
            }
            ))
              , _p = gp((function(e) {
                var t = e.exports = {
                    version: "2.5.7"
                };
                "number" == typeof __e && (__e = t)
            }
            ))
              , yp = (_p.version,
            function(e) {
                return "object" == typeof e ? null !== e : "function" == typeof e
            }
            )
              , xp = function(e) {
                if (!yp(e))
                    throw TypeError(e + " is not an object!");
                return e
            }
              , bp = function(e) {
                try {
                    return !!e()
                } catch (e) {
                    return !0
                }
            }
              , Ep = !bp((function() {
                return 7 != Object.defineProperty({}, "a", {
                    get: function() {
                        return 7
                    }
                }).a
            }
            ))
              , Sp = vp.document
              , wp = yp(Sp) && yp(Sp.createElement)
              , Mp = !Ep && !bp((function() {
                return 7 != Object.defineProperty((e = "div",
                wp ? Sp.createElement(e) : {}), "a", {
                    get: function() {
                        return 7
                    }
                }).a;
                var e
            }
            ))
              , Tp = Object.defineProperty
              , Ap = {
                f: Ep ? Object.defineProperty : function(e, t, n) {
                    if (xp(e),
                    t = function(e, t) {
                        if (!yp(e))
                            return e;
                        var n, r;
                        if (t && "function" == typeof (n = e.toString) && !yp(r = n.call(e)))
                            return r;
                        if ("function" == typeof (n = e.valueOf) && !yp(r = n.call(e)))
                            return r;
                        if (!t && "function" == typeof (n = e.toString) && !yp(r = n.call(e)))
                            return r;
                        throw TypeError("Can't convert object to primitive value")
                    }(t, !0),
                    xp(n),
                    Mp)
                        try {
                            return Tp(e, t, n)
                        } catch (e) {}
                    if ("get"in n || "set"in n)
                        throw TypeError("Accessors not supported!");
                    return "value"in n && (e[t] = n.value),
                    e
                }
            }
              , Cp = Ep ? function(e, t, n) {
                return Ap.f(e, t, function(e, t) {
                    return {
                        enumerable: !(1 & e),
                        configurable: !(2 & e),
                        writable: !(4 & e),
                        value: t
                    }
                }(1, n))
            }
            : function(e, t, n) {
                return e[t] = n,
                e
            }
              , Pp = {}.hasOwnProperty
              , Rp = function(e, t) {
                return Pp.call(e, t)
            }
              , Lp = 0
              , Op = Math.random()
              , Dp = function(e) {
                return "Symbol(".concat(void 0 === e ? "" : e, ")_", (++Lp + Op).toString(36))
            }
              , Ip = gp((function(e) {
                var t = Dp("src")
                  , n = "toString"
                  , r = Function[n]
                  , i = ("" + r).split(n);
                _p.inspectSource = function(e) {
                    return r.call(e)
                }
                ,
                (e.exports = function(e, n, r, a) {
                    var s = "function" == typeof r;
                    s && (Rp(r, "name") || Cp(r, "name", n)),
                    e[n] !== r && (s && (Rp(r, t) || Cp(r, t, e[n] ? "" + e[n] : i.join(String(n)))),
                    e === vp ? e[n] = r : a ? e[n] ? e[n] = r : Cp(e, n, r) : (delete e[n],
                    Cp(e, n, r)))
                }
                )(Function.prototype, n, (function() {
                    return "function" == typeof this && this[t] || r.call(this)
                }
                ))
            }
            ))
              , Np = function(e, t, n) {
                if (function(e) {
                    if ("function" != typeof e)
                        throw TypeError(e + " is not a function!")
                }(e),
                void 0 === t)
                    return e;
                switch (n) {
                case 1:
                    return function(n) {
                        return e.call(t, n)
                    }
                    ;
                case 2:
                    return function(n, r) {
                        return e.call(t, n, r)
                    }
                    ;
                case 3:
                    return function(n, r, i) {
                        return e.call(t, n, r, i)
                    }
                }
                return function() {
                    return e.apply(t, arguments)
                }
            }
              , Up = "prototype"
              , kp = function(e, t, n) {
                var r, i, a, s, o = e & kp.F, l = e & kp.G, c = e & kp.S, u = e & kp.P, d = e & kp.B, h = l ? vp : c ? vp[t] || (vp[t] = {}) : (vp[t] || {})[Up], p = l ? _p : _p[t] || (_p[t] = {}), f = p[Up] || (p[Up] = {});
                for (r in l && (n = t),
                n)
                    a = ((i = !o && h && void 0 !== h[r]) ? h : n)[r],
                    s = d && i ? Np(a, vp) : u && "function" == typeof a ? Np(Function.call, a) : a,
                    h && Ip(h, r, a, e & kp.U),
                    p[r] != a && Cp(p, r, s),
                    u && f[r] != a && (f[r] = a)
            };
            vp.core = _p,
            kp.F = 1,
            kp.G = 2,
            kp.S = 4,
            kp.P = 8,
            kp.B = 16,
            kp.W = 32,
            kp.U = 64,
            kp.R = 128;
            var Fp = kp
              , zp = {}.toString
              , Bp = function(e) {
                return zp.call(e).slice(8, -1)
            }
              , Hp = Object("z").propertyIsEnumerable(0) ? Object : function(e) {
                return "String" == Bp(e) ? e.split("") : Object(e)
            }
              , Gp = function(e) {
                if (null == e)
                    throw TypeError("Can't call method on  " + e);
                return e
            }
              , Vp = Math.ceil
              , Wp = Math.floor
              , jp = Math.min
              , Xp = function(e) {
                return e > 0 ? jp(function(e) {
                    return isNaN(e = +e) ? 0 : (e > 0 ? Wp : Vp)(e)
                }(e), 9007199254740991) : 0
            }
              , qp = Array.isArray || function(e) {
                return "Array" == Bp(e)
            }
              , Yp = gp((function(e) {
                var t = "__core-js_shared__"
                  , n = vp[t] || (vp[t] = {});
                (e.exports = function(e, t) {
                    return n[e] || (n[e] = void 0 !== t ? t : {})
                }
                )("versions", []).push({
                    version: _p.version,
                    mode: "global",
                    copyright: "© 2018 Denis Pushkarev (zloirock.ru)"
                })
            }
            ))
              , $p = gp((function(e) {
                var t = Yp("wks")
                  , n = vp.Symbol
                  , r = "function" == typeof n;
                (e.exports = function(e) {
                    return t[e] || (t[e] = r && n[e] || (r ? n : Dp)("Symbol." + e))
                }
                ).store = t
            }
            ))("species")
              , Kp = function(e, t) {
                return new (function(e) {
                    var t;
                    return qp(e) && ("function" != typeof (t = e.constructor) || t !== Array && !qp(t.prototype) || (t = void 0),
                    yp(t) && null === (t = t[$p]) && (t = void 0)),
                    void 0 === t ? Array : t
                }(e))(t)
            }
              , Zp = function(e, t) {
                var n = 1 == e
                  , r = 2 == e
                  , i = 3 == e
                  , a = 4 == e
                  , s = 6 == e
                  , o = 5 == e || s
                  , l = t || Kp;
                return function(t, c, u) {
                    for (var d, h, p = Object(Gp(t)), f = Hp(p), m = Np(c, u, 3), g = Xp(f.length), v = 0, _ = n ? l(t, g) : r ? l(t, 0) : void 0; g > v; v++)
                        if ((o || v in f) && (h = m(d = f[v], v, p),
                        e))
                            if (n)
                                _[v] = h;
                            else if (h)
                                switch (e) {
                                case 3:
                                    return !0;
                                case 5:
                                    return d;
                                case 6:
                                    return v;
                                case 2:
                                    _.push(d)
                                }
                            else if (a)
                                return !1;
                    return s ? -1 : i || a ? a : _
                }
            }
              , Jp = function(e, t) {
                return !!e && bp((function() {
                    t ? e.call(null, (function() {}
                    ), 1) : e.call(null)
                }
                ))
            }
              , Qp = Zp(2);
            Fp(Fp.P + Fp.F * !Jp([].filter, !0), "Array", {
                filter: function(e) {
                    return Qp(this, e, arguments[1])
                }
            });
            _p.Array.filter;
            var ef = Zp(1);
            Fp(Fp.P + Fp.F * !Jp([].map, !0), "Array", {
                map: function(e) {
                    return ef(this, e, arguments[1])
                }
            });
            _p.Array.map;
            var tf = "\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"
              , nf = "[" + tf + "]"
              , rf = RegExp("^" + nf + nf + "*")
              , af = RegExp(nf + nf + "*$")
              , sf = function(e, t, n) {
                var r = {}
                  , i = bp((function() {
                    return !!tf[e]() || "​" != "​"[e]()
                }
                ))
                  , a = r[e] = i ? t(of) : tf[e];
                n && (r[n] = a),
                Fp(Fp.P + Fp.F * i, "String", r)
            }
              , of = sf.trim = function(e, t) {
                return e = String(Gp(e)),
                1 & t && (e = e.replace(rf, "")),
                2 & t && (e = e.replace(af, "")),
                e
            }
            ;
            sf("trim", (function(e) {
                return function() {
                    return e(this, 3)
                }
            }
            ));
            _p.String.trim;
            var lf = "undefined" != typeof window ? window.navigator : void 0
              , cf = void 0 !== lp ? lp : void 0;
            var uf = function(e) {
                return new mp(e,lf,cf).detect()
            }
              , df = !1
              , hf = !1
              , pf = function() {
                return !!function() {
                    if (df)
                        return hf;
                    df = !0;
                    try {
                        var e = Object.defineProperty({}, "passive", {
                            get: function() {
                                hf = !0
                            }
                        });
                        window.addEventListener("test", null, e)
                    } catch (e) {
                        return hf
                    }
                    return window.removeEventListener("test", null, opts),
                    hf
                }() && {
                    passive: !0
                }
            };
            function ff(e) {
                return ff = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                }
                : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }
                ,
                ff(e)
            }
            function mf(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1,
                    r.configurable = !0,
                    "value"in r && (r.writable = !0),
                    Object.defineProperty(e, gf(r.key), r)
                }
            }
            function gf(e) {
                var t = function(e, t) {
                    if ("object" != ff(e) || !e)
                        return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var r = n.call(e, t || "default");
                        if ("object" != ff(r))
                            return r;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return ("string" === t ? String : Number)(e)
                }(e, "string");
                return "symbol" == ff(t) ? t : String(t)
            }
            function vf(e, t, n) {
                return t = yf(t),
                function(e, t) {
                    if (t && ("object" === ff(t) || "function" == typeof t))
                        return t;
                    if (void 0 !== t)
                        throw new TypeError("Derived constructors may only return object or undefined");
                    return function(e) {
                        if (void 0 === e)
                            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return e
                    }(e)
                }(e, _f() ? Reflect.construct(t, n || [], yf(e).constructor) : t.apply(e, n))
            }
            function _f() {
                try {
                    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
                    )))
                } catch (e) {}
                return (_f = function() {
                    return !!e
                }
                )()
            }
            function yf(e) {
                return yf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                }
                ,
                yf(e)
            }
            function xf(e, t) {
                return xf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
                    return e.__proto__ = t,
                    e
                }
                ,
                xf(e, t)
            }
            var bf = function(e) {
                function t(e, n) {
                    var r;
                    return function(e, t) {
                        if (!(e instanceof t))
                            throw new TypeError("Cannot call a class as a function")
                    }(this, t),
                    (r = vf(this, t)).camera = e,
                    r.el = n || window,
                    r.plane = new Rc,
                    r.raycaster = new rp,
                    r.mouse = new Is,
                    r.offset = new lo,
                    r.intersection = new lo,
                    r.objects = [],
                    r.hovered = null,
                    r.selected = null,
                    r.isDown = !1,
                    r.browser = uf(),
                    r.enable(),
                    r
                }
                var n, r, i;
                return function(e, t) {
                    if ("function" != typeof t && null !== t)
                        throw new TypeError("Super expression must either be null or a function");
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            writable: !0,
                            configurable: !0
                        }
                    }),
                    Object.defineProperty(e, "prototype", {
                        writable: !1
                    }),
                    t && xf(e, t)
                }(t, e),
                n = t,
                r = [{
                    key: "enabled",
                    get: function() {
                        return this._enabled
                    }
                }, {
                    key: "enable",
                    value: function() {
                        this.enabled || (this.addListeners(),
                        this._enabled = !0)
                    }
                }, {
                    key: "disable",
                    value: function() {
                        this.enabled && (this.removeListeners(),
                        this._enabled = !1)
                    }
                }, {
                    key: "addListeners",
                    value: function() {
                        this.handlerDown = this.onDown.bind(this),
                        this.handlerMove = this.onMove.bind(this),
                        this.handlerUp = this.onUp.bind(this),
                        this.handlerLeave = this.onLeave.bind(this),
                        this.browser.mobile ? (window.addEventListener("touchstart", this.handlerDown, pf),
                        window.addEventListener("touchmove", this.handlerMove, pf),
                        window.addEventListener("touchend", this.handlerUp, pf)) : (window.addEventListener("mousedown", this.handlerDown),
                        window.addEventListener("mousemove", this.handlerMove),
                        window.addEventListener("mouseup", this.handlerUp),
                        window.addEventListener("mouseleave", this.handlerLeave))
                    }
                }, {
                    key: "removeListeners",
                    value: function() {
                        this.browser.mobile ? (window.removeEventListener("touchstart", this.handlerDown),
                        window.removeEventListener("touchmove", this.handlerMove),
                        window.removeEventListener("touchend", this.handlerUp)) : (window.removeEventListener("mousedown", this.handlerDown),
                        window.removeEventListener("mousemove", this.handlerMove),
                        window.removeEventListener("mouseup", this.handlerUp),
                        window.removeEventListener("mouseleave", this.handlerLeave))
                    }
                }, {
                    key: "resize",
                    value: function(e, t, n, r) {
                        e || t || n || r ? this.rect = {
                            x: e,
                            y: t,
                            width: n,
                            height: r
                        } : this.el === window ? this.rect = {
                            x: 0,
                            y: 0,
                            width: window.innerWidth,
                            height: window.innerHeight
                        } : this.rect = this.el.getBoundingClientRect()
                    }
                }, {
                    key: "onMove",
                    value: function(e) {
                        var t = e.touches ? e.touches[0] : e
                          , n = t.clientX
                          , r = t.clientY;
                        this.mouse.x = (n + this.rect.x) / this.rect.width * 2 - 1,
                        this.mouse.y = -(r + this.rect.y) / this.rect.height * 2 + 1,
                        this.raycaster.setFromCamera(this.mouse, this.camera);
                        var i = this.raycaster.intersectObjects(this.objects);
                        if (i.length > 0) {
                            var a = i[0].object;
                            this.intersectionData = i[0],
                            this.plane.setFromNormalAndCoplanarPoint(this.camera.getWorldDirection(this.plane.normal), a.position),
                            this.hovered !== a ? (this.emit("interactive-out", {
                                object: this.hovered
                            }),
                            this.emit("interactive-over", {
                                object: a
                            }),
                            this.hovered = a) : this.emit("interactive-move", {
                                object: a,
                                intersectionData: this.intersectionData
                            })
                        } else
                            this.intersectionData = null,
                            null !== this.hovered && (this.emit("interactive-out", {
                                object: this.hovered
                            }),
                            this.hovered = null)
                    }
                }, {
                    key: "onDown",
                    value: function(e) {
                        this.isDown = !0,
                        this.onMove(e),
                        this.emit("interactive-down", {
                            object: this.hovered,
                            previous: this.selected,
                            intersectionData: this.intersectionData
                        }),
                        this.selected = this.hovered,
                        this.selected && this.raycaster.ray.intersectPlane(this.plane, this.intersection) && this.offset.copy(this.intersection).sub(this.selected.position)
                    }
                }, {
                    key: "onUp",
                    value: function(e) {
                        this.isDown = !1,
                        this.emit("interactive-up", {
                            object: this.hovered
                        })
                    }
                }, {
                    key: "onLeave",
                    value: function(e) {
                        this.onUp(e),
                        this.emit("interactive-out", {
                            object: this.hovered
                        }),
                        this.hovered = null
                    }
                }],
                r && mf(n.prototype, r),
                i && mf(n, i),
                Object.defineProperty(n, "prototype", {
                    writable: !1
                }),
                t
            }(op())
              , Ef = function(e, t, n, r) {
                return n * Math.sin(e / r * (Math.PI / 2)) + t
            };
            function Sf(e) {
                return Sf = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                }
                : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }
                ,
                Sf(e)
            }
            function wf(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1,
                    r.configurable = !0,
                    "value"in r && (r.writable = !0),
                    Object.defineProperty(e, Mf(r.key), r)
                }
            }
            function Mf(e) {
                var t = function(e, t) {
                    if ("object" != Sf(e) || !e)
                        return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var r = n.call(e, t || "default");
                        if ("object" != Sf(r))
                            return r;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return ("string" === t ? String : Number)(e)
                }(e, "string");
                return "symbol" == Sf(t) ? t : String(t)
            }
            var Tf = function() {
                function e(t) {
                    !function(e, t) {
                        if (!(e instanceof t))
                            throw new TypeError("Cannot call a class as a function")
                    }(this, e),
                    this.parent = t,
                    this.size = 64,
                    this.maxAge = 120,
                    this.radius = .15,
                    this.trail = [],
                    this.initTexture()
                }
                var t, n, r;
                return t = e,
                (n = [{
                    key: "initTexture",
                    value: function() {
                        this.canvas = document.createElement("canvas"),
                        this.canvas.width = this.canvas.height = this.size,
                        this.ctx = this.canvas.getContext("2d"),
                        this.ctx.fillStyle = "black",
                        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height),
                        this.texture = new to(this.canvas),
                        this.canvas.id = "touchTexture",
                        this.canvas.style.width = this.canvas.style.height = "".concat(this.canvas.width, "px")
                    }
                }, {
                    key: "update",
                    value: function(e) {
                        var t = this;
                        this.clear(),
                        this.trail.forEach((function(e, n) {
                            e.age++,
                            e.age > t.maxAge && t.trail.splice(n, 1)
                        }
                        )),
                        this.trail.forEach((function(e, n) {
                            t.drawTouch(e)
                        }
                        )),
                        this.texture.needsUpdate = !0
                    }
                }, {
                    key: "clear",
                    value: function() {
                        this.ctx.fillStyle = "black",
                        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height)
                    }
                }, {
                    key: "addTouch",
                    value: function(e) {
                        var t = 0
                          , n = this.trail[this.trail.length - 1];
                        if (n) {
                            var r = n.x - e.x
                              , i = n.y - e.y
                              , a = r * r + i * i;
                            t = Math.min(1e4 * a, 1)
                        }
                        this.trail.push({
                            x: e.x,
                            y: e.y,
                            age: 0,
                            force: t
                        })
                    }
                }, {
                    key: "drawTouch",
                    value: function(e) {
                        var t = {
                            x: e.x * this.size,
                            y: (1 - e.y) * this.size
                        }
                          , n = 1;
                        n = e.age < .3 * this.maxAge ? Ef(e.age / (.3 * this.maxAge), 0, 1, 1) : Ef(1 - (e.age - .3 * this.maxAge) / (.7 * this.maxAge), 0, 1, 1),
                        n *= e.force;
                        var r = this.size * this.radius * n
                          , i = this.ctx.createRadialGradient(t.x, t.y, .25 * r, t.x, t.y, r);
                        i.addColorStop(0, "rgba(255, 255, 255, 0.2)"),
                        i.addColorStop(1, "rgba(0, 0, 0, 0.0)"),
                        this.ctx.beginPath(),
                        this.ctx.fillStyle = i,
                        this.ctx.arc(t.x, t.y, r, 0, 2 * Math.PI),
                        this.ctx.fill()
                    }
                }]) && wf(t.prototype, n),
                r && wf(t, r),
                Object.defineProperty(t, "prototype", {
                    writable: !1
                }),
                e
            }();
            function Af(e) {
                return Af = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                }
                : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }
                ,
                Af(e)
            }
            function Cf(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1,
                    r.configurable = !0,
                    "value"in r && (r.writable = !0),
                    Object.defineProperty(e, Pf(r.key), r)
                }
            }
            function Pf(e) {
                var t = function(e, t) {
                    if ("object" != Af(e) || !e)
                        return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var r = n.call(e, t || "default");
                        if ("object" != Af(r))
                            return r;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return ("string" === t ? String : Number)(e)
                }(e, "string");
                return "symbol" == Af(t) ? t : String(t)
            }
            var Rf = n(209)
              , Lf = function() {
                function e(t) {
                    !function(e, t) {
                        if (!(e instanceof t))
                            throw new TypeError("Cannot call a class as a function")
                    }(this, e),
                    this.webgl = t,
                    this.container = new hl
                }
                var t, r, i;
                return t = e,
                r = [{
                    key: "init",
                    value: function(e) {
                        var t = this;
                        (new jh).load(e, (function(e) {
                            t.texture = e,
                            t.texture.minFilter = ka,
                            t.texture.magFilter = ka,
                            t.texture.format = qa,
                            t.width = e.image.width,
                            t.height = e.image.height,
                            t.initPoints(!0),
                            t.initHitArea(),
                            t.initTouch(),
                            t.resize(),
                            t.show()
                        }
                        ))
                    }
                }, {
                    key: "initPoints",
                    value: function(e) {
                        this.numPoints = this.width * this.height;
                        var t, r = this.numPoints, i = 0;
                        if (e) {
                            r = 0,
                            i = 34;
                            var a = this.texture.image
                              , s = document.createElement("canvas")
                              , o = s.getContext("2d");
                            s.width = this.width,
                            s.height = this.height,
                            o.scale(1, -1),
                            o.drawImage(a, 0, 0, this.width, -1 * this.height);
                            var l = o.getImageData(0, 0, s.width, s.height);
                            t = Float32Array.from(l.data);
                            for (var c = 0; c < this.numPoints; c++)
                                t[4 * c + 0] > i && r++
                        }
                        var u = {
                            uTime: {
                                value: 0
                            },
                            uRandom: {
                                value: 1
                            },
                            uDepth: {
                                value: 2
                            },
                            uSize: {
                                value: 0
                            },
                            uTextureSize: {
                                value: new Is(this.width,this.height)
                            },
                            uTexture: {
                                value: this.texture
                            },
                            uTouch: {
                                value: null
                            }
                        }
                          , d = new Mh({
                            uniforms: u,
                            vertexShader: Rf(n(451)),
                            fragmentShader: Rf(n(802)),
                            depthTest: !1,
                            transparent: !0
                        })
                          , h = new Xh
                          , p = new Nl(new Float32Array(12),3);
                        p.setXYZ(0, -.5, .5, 0),
                        p.setXYZ(1, .5, .5, 0),
                        p.setXYZ(2, -.5, -.5, 0),
                        p.setXYZ(3, .5, -.5, 0),
                        h.setAttribute("position", p);
                        var f = new Nl(new Float32Array(8),2);
                        f.setXYZ(0, 0, 0),
                        f.setXYZ(1, 1, 0),
                        f.setXYZ(2, 0, 1),
                        f.setXYZ(3, 1, 1),
                        h.setAttribute("uv", f),
                        h.setIndex(new Nl(new Uint16Array([0, 2, 1, 2, 3, 1]),1));
                        for (var m = new Uint16Array(r), g = new Float32Array(3 * r), v = new Float32Array(r), _ = 0, y = 0; _ < this.numPoints; _++)
                            e && t[4 * _ + 0] <= i || (g[3 * y + 0] = _ % this.width,
                            g[3 * y + 1] = Math.floor(_ / this.width),
                            m[y] = _,
                            v[y] = Math.random() * Math.PI,
                            y++);
                        h.setAttribute("pindex", new wh(m,1,!1)),
                        h.setAttribute("offset", new wh(g,3,!1)),
                        h.setAttribute("angle", new wh(v,1,!1)),
                        this.object3D = new uc(h,d),
                        this.container.add(this.object3D)
                    }
                }, {
                    key: "initTouch",
                    value: function() {
                        this.touch || (this.touch = new Tf(this)),
                        this.object3D.material.uniforms.uTouch.value = this.touch.texture
                    }
                }, {
                    key: "initHitArea",
                    value: function() {
                        var e = new Uc(this.width,this.height,1,1)
                          , t = new Ol({
                            color: 16777215,
                            wireframe: !0,
                            depthTest: !1
                        });
                        t.visible = !1,
                        this.hitArea = new uc(e,t),
                        this.container.add(this.hitArea)
                    }
                }, {
                    key: "addListeners",
                    value: function() {
                        this.handlerInteractiveMove = this.onInteractiveMove.bind(this),
                        this.webgl.interactive.addListener("interactive-move", this.handlerInteractiveMove),
                        this.webgl.interactive.objects.push(this.hitArea),
                        this.webgl.interactive.enable()
                    }
                }, {
                    key: "removeListeners",
                    value: function() {
                        var e = this;
                        this.webgl.interactive.removeListener("interactive-move", this.handlerInteractiveMove);
                        var t = this.webgl.interactive.objects.findIndex((function(t) {
                            return t === e.hitArea
                        }
                        ));
                        this.webgl.interactive.objects.splice(t, 1),
                        this.webgl.interactive.disable()
                    }
                }, {
                    key: "update",
                    value: function(e) {
                        this.object3D && (this.touch && this.touch.update(),
                        this.object3D.material.uniforms.uTime.value += e)
                    }
                }, {
                    key: "show",
                    value: function() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
                        Tn.fromTo(this.object3D.material.uniforms.uSize, e, {
                            value: 0
                        }, {
                            value: 1.5
                        }),
                        Tn.to(this.object3D.material.uniforms.uRandom, e, {
                            value: 5
                        }),
                        Tn.fromTo(this.object3D.material.uniforms.uDepth, 1.5 * e, {
                            value: -20
                        }, {
                            value: 0
                        }),
                        this.addListeners()
                    }
                }, {
                    key: "hide",
                    value: function(e) {
                        var t = this
                          , n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .8;
                        return new Promise((function(r, i) {
                            Tn.to(t.object3D.material.uniforms.uRandom, n, {
                                value: 5,
                                onComplete: function() {
                                    e && t.destroy(),
                                    r()
                                }
                            }),
                            Tn.to(t.object3D.material.uniforms.uDepth, n, {
                                value: -20
                            }),
                            Tn.to(t.object3D.material.uniforms.uSize, .8 * n, {
                                value: 0
                            }),
                            t.removeListeners()
                        }
                        ))
                    }
                }, {
                    key: "resize",
                    value: function() {
                        if (this.object3D) {
                            var e = this.webgl.fovHeight / this.height;
                            this.object3D.scale.set(e, e, 1),
                            this.hitArea.scale.set(e, e, 1)
                        }
                    }
                }, {
                    key: "onInteractiveMove",
                    value: function(e) {
                        if (y.IS_DESKTOP && !y.IS_REDUCED_MOTION) {
                            var t = e.intersectionData.uv;
                            this.touch && this.touch.addTouch(t)
                        }
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        this.object3D && (this.object3D.parent.remove(this.object3D),
                        this.object3D.geometry.dispose(),
                        this.object3D.material.dispose(),
                        this.object3D = null,
                        this.hitArea && (this.hitArea.parent.remove(this.hitArea),
                        this.hitArea.geometry.dispose(),
                        this.hitArea.material.dispose(),
                        this.hitArea = null))
                    }
                }],
                r && Cf(t.prototype, r),
                i && Cf(t, i),
                Object.defineProperty(t, "prototype", {
                    writable: !1
                }),
                e
            }();
            function Of(e) {
                return Of = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                }
                : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }
                ,
                Of(e)
            }
            function Df(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1,
                    r.configurable = !0,
                    "value"in r && (r.writable = !0),
                    Object.defineProperty(e, If(r.key), r)
                }
            }
            function If(e) {
                var t = function(e, t) {
                    if ("object" != Of(e) || !e)
                        return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var r = n.call(e, t || "default");
                        if ("object" != Of(r))
                            return r;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return ("string" === t ? String : Number)(e)
                }(e, "string");
                return "symbol" == Of(t) ? t : String(t)
            }
            n(209);
            var Nf = function() {
                function e(t) {
                    !function(e, t) {
                        if (!(e instanceof t))
                            throw new TypeError("Cannot call a class as a function")
                    }(this, e),
                    this.currSample = null,
                    this.screenWidth = window.innerWidth,
                    this.initThree(),
                    this.initParticles(),
                    this.initControls()
                }
                var t, n, r;
                return t = e,
                n = [{
                    key: "initThree",
                    value: function() {
                        this.scene = new Sh,
                        this.camera = new Ec(50,this.screenWidth / window.innerHeight,1,1e4),
                        this.camera.position.z = 300,
                        this.renderer = new Eh({
                            antialias: !0,
                            alpha: !0
                        }),
                        this.clock = new qh(!0)
                    }
                }, {
                    key: "initControls",
                    value: function() {
                        this.interactive = new bf(this.camera,this.renderer.domElement)
                    }
                }, {
                    key: "initParticles",
                    value: function() {
                        this.particles = new Lf(this),
                        this.scene.add(this.particles.container)
                    }
                }, {
                    key: "update",
                    value: function() {
                        var e = this.clock.getDelta();
                        this.particles && this.particles.update(e)
                    }
                }, {
                    key: "draw",
                    value: function() {
                        this.renderer.render(this.scene, this.camera)
                    }
                }, {
                    key: "renderImage",
                    value: function() {
                        var e = this
                          , t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                        null !== t && this.currSample !== t && (null === this.currSample ? this.particles.init(t) : this.particles.hide(!0).then((function() {
                            e.particles.init(t)
                        }
                        )),
                        this.currSample = t)
                    }
                }, {
                    key: "resize",
                    value: function() {
                        this.renderer && (this.screenWidth = window.innerWidth,
                        this.camera.aspect = this.screenWidth / window.innerHeight,
                        this.camera.updateProjectionMatrix(),
                        this.fovHeight = 2 * Math.tan(this.camera.fov * Math.PI / 180 / 2) * this.camera.position.z,
                        this.renderer.setSize(this.screenWidth, window.innerHeight),
                        this.interactive && this.interactive.resize(),
                        this.particles && this.particles.resize())
                    }
                }],
                n && Df(t.prototype, n),
                r && Df(t, r),
                Object.defineProperty(t, "prototype", {
                    writable: !1
                }),
                e
            }();
            function Uf(e) {
                return Uf = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                }
                : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }
                ,
                Uf(e)
            }
            function kf(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1,
                    r.configurable = !0,
                    "value"in r && (r.writable = !0),
                    Object.defineProperty(e, Ff(r.key), r)
                }
            }
            function Ff(e) {
                var t = function(e, t) {
                    if ("object" != Uf(e) || !e)
                        return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var r = n.call(e, t || "default");
                        if ("object" != Uf(r))
                            return r;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return ("string" === t ? String : Number)(e)
                }(e, "string");
                return "symbol" == Uf(t) ? t : String(t)
            }
            function zf(e, t, n) {
                return t = Hf(t),
                function(e, t) {
                    if (t && ("object" === Uf(t) || "function" == typeof t))
                        return t;
                    if (void 0 !== t)
                        throw new TypeError("Derived constructors may only return object or undefined");
                    return function(e) {
                        if (void 0 === e)
                            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return e
                    }(e)
                }(e, Bf() ? Reflect.construct(t, n || [], Hf(e).constructor) : t.apply(e, n))
            }
            function Bf() {
                try {
                    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
                    )))
                } catch (e) {}
                return (Bf = function() {
                    return !!e
                }
                )()
            }
            function Hf(e) {
                return Hf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                }
                ,
                Hf(e)
            }
            function Gf(e, t) {
                return Gf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
                    return e.__proto__ = t,
                    e
                }
                ,
                Gf(e, t)
            }
            var Vf = function(e) {
                function t(e) {
                    var n;
                    return function(e, t) {
                        if (!(e instanceof t))
                            throw new TypeError("Cannot call a class as a function")
                    }(this, t),
                    (n = zf(this, t, [e])).images = null,
                    n
                }
                var n, r, i;
                return function(e, t) {
                    if ("function" != typeof t && null !== t)
                        throw new TypeError("Super expression must either be null or a function");
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            writable: !0,
                            configurable: !0
                        }
                    }),
                    Object.defineProperty(e, "prototype", {
                        writable: !1
                    }),
                    t && Gf(e, t)
                }(t, e),
                n = t,
                r = [{
                    key: "init",
                    value: function() {
                        this.initWebGL(),
                        this.addListeners(),
                        this.animate(),
                        this.resize(),
                        this.images = this.el.querySelectorAll("[data-particles-image]"),
                        this.images.length && this.renderImage(this.images[0].src),
                        y.IS_DEV && console.log("Particles: Initiated")
                    }
                }, {
                    key: "renderImage",
                    value: function() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                        null !== e && this.webgl.renderImage(e)
                    }
                }, {
                    key: "initWebGL",
                    value: function() {
                        this.webgl = new Nf(this.el),
                        this.el.appendChild(this.webgl.renderer.domElement)
                    }
                }, {
                    key: "addListeners",
                    value: function() {
                        this.handlerAnimate = this.animate.bind(this),
                        window.addEventListener("resize", this.resize.bind(this))
                    }
                }, {
                    key: "animate",
                    value: function() {
                        this.update(),
                        this.draw(),
                        this.raf = requestAnimationFrame(this.handlerAnimate)
                    }
                }, {
                    key: "update",
                    value: function() {
                        this.webgl && this.webgl.update()
                    }
                }, {
                    key: "draw",
                    value: function() {
                        this.webgl && this.webgl.draw()
                    }
                }, {
                    key: "resize",
                    value: function() {
                        this.webgl && this.webgl.resize()
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        y.IS_DEV && console.log("Particles: Destroyed")
                    }
                }],
                r && kf(n.prototype, r),
                i && kf(n, i),
                Object.defineProperty(n, "prototype", {
                    writable: !1
                }),
                t
            }(p);
            function Wf(e) {
                return Wf = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                }
                : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }
                ,
                Wf(e)
            }
            function jf(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1,
                    r.configurable = !0,
                    "value"in r && (r.writable = !0),
                    Object.defineProperty(e, Xf(r.key), r)
                }
            }
            function Xf(e) {
                var t = function(e, t) {
                    if ("object" != Wf(e) || !e)
                        return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var r = n.call(e, t || "default");
                        if ("object" != Wf(r))
                            return r;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return ("string" === t ? String : Number)(e)
                }(e, "string");
                return "symbol" == Wf(t) ? t : String(t)
            }
            function qf(e, t, n) {
                return t = $f(t),
                function(e, t) {
                    if (t && ("object" === Wf(t) || "function" == typeof t))
                        return t;
                    if (void 0 !== t)
                        throw new TypeError("Derived constructors may only return object or undefined");
                    return function(e) {
                        if (void 0 === e)
                            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return e
                    }(e)
                }(e, Yf() ? Reflect.construct(t, n || [], $f(e).constructor) : t.apply(e, n))
            }
            function Yf() {
                try {
                    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
                    )))
                } catch (e) {}
                return (Yf = function() {
                    return !!e
                }
                )()
            }
            function $f(e) {
                return $f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                }
                ,
                $f(e)
            }
            function Kf(e, t) {
                return Kf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
                    return e.__proto__ = t,
                    e
                }
                ,
                Kf(e, t)
            }
            var Zf = function(e) {
                function t(e) {
                    var n;
                    return function(e, t) {
                        if (!(e instanceof t))
                            throw new TypeError("Cannot call a class as a function")
                    }(this, t),
                    (n = qf(this, t, [e])).images = null,
                    n
                }
                var n, r, i;
                return function(e, t) {
                    if ("function" != typeof t && null !== t)
                        throw new TypeError("Super expression must either be null or a function");
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            writable: !0,
                            configurable: !0
                        }
                    }),
                    Object.defineProperty(e, "prototype", {
                        writable: !1
                    }),
                    t && Kf(e, t)
                }(t, e),
                n = t,
                (r = [{
                    key: "init",
                    value: function() {
                        this.images = this.el.querySelectorAll("[data-particles-aggregator-image]"),
                        this.images.length && this.call("renderImage", this.images[0].src, "Particles", "main"),
                        y.IS_DEV && console.log("Particles Aggregator: Initiated")
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        y.IS_DEV && console.log("Particles Aggregator: Destroyed")
                    }
                }]) && jf(n.prototype, r),
                i && jf(n, i),
                Object.defineProperty(n, "prototype", {
                    writable: !1
                }),
                t
            }(p);
            function Jf(e) {
                return Jf = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                }
                : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }
                ,
                Jf(e)
            }
            function Qf(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1,
                    r.configurable = !0,
                    "value"in r && (r.writable = !0),
                    Object.defineProperty(e, em(r.key), r)
                }
            }
            function em(e) {
                var t = function(e, t) {
                    if ("object" != Jf(e) || !e)
                        return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var r = n.call(e, t || "default");
                        if ("object" != Jf(r))
                            return r;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return ("string" === t ? String : Number)(e)
                }(e, "string");
                return "symbol" == Jf(t) ? t : String(t)
            }
            function tm(e, t, n) {
                return t = rm(t),
                function(e, t) {
                    if (t && ("object" === Jf(t) || "function" == typeof t))
                        return t;
                    if (void 0 !== t)
                        throw new TypeError("Derived constructors may only return object or undefined");
                    return function(e) {
                        if (void 0 === e)
                            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return e
                    }(e)
                }(e, nm() ? Reflect.construct(t, n || [], rm(e).constructor) : t.apply(e, n))
            }
            function nm() {
                try {
                    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
                    )))
                } catch (e) {}
                return (nm = function() {
                    return !!e
                }
                )()
            }
            function rm(e) {
                return rm = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                }
                ,
                rm(e)
            }
            function im(e, t) {
                return im = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
                    return e.__proto__ = t,
                    e
                }
                ,
                im(e, t)
            }
            var am = function(e) {
                function t(e) {
                    var n;
                    return function(e, t) {
                        if (!(e instanceof t))
                            throw new TypeError("Cannot call a class as a function")
                    }(this, t),
                    (n = tm(this, t, [e])).items = null,
                    n.currItem = 0,
                    n.refreshTrigger = null,
                    n
                }
                var n, r, i;
                return function(e, t) {
                    if ("function" != typeof t && null !== t)
                        throw new TypeError("Super expression must either be null or a function");
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            writable: !0,
                            configurable: !0
                        }
                    }),
                    Object.defineProperty(e, "prototype", {
                        writable: !1
                    }),
                    t && im(e, t)
                }(t, e),
                n = t,
                (r = [{
                    key: "init",
                    value: function() {
                        var e = this;
                        this.items = this.el.querySelectorAll("[data-particle-text-rotator-item]"),
                        this.refreshTrigger = this.el.querySelector("[data-particle-text-rotator-refresh]"),
                        this.items.length && (this.setCurrent(),
                        this.items.length > 1 && this.refreshTrigger.addEventListener("click", (function() {
                            e.refresh()
                        }
                        ))),
                        y.IS_DEV && console.log("Particle & Text Rotator: Initiated")
                    }
                }, {
                    key: "refresh",
                    value: function() {
                        this.currItem >= this.items.length - 1 ? this.currItem = 0 : this.currItem++,
                        this.setCurrent()
                    }
                }, {
                    key: "setCurrent",
                    value: function() {
                        for (var e = this, t = this.items[this.currItem].querySelector("[data-particle-text-rotator-image]"), n = 0; n < this.items.length; n++)
                            this.items[n].classList.remove("is-showing");
                        this.items[this.currItem].classList.add("is-showing"),
                        this.call("renderImage", t.src, "Particles", "main"),
                        setTimeout((function() {
                            var t = e.items[e.currItem];
                            t.parentNode.appendChild(t)
                        }
                        ), 1e3)
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        y.IS_DEV && console.log("Particle & Text Rotator: Destroyed")
                    }
                }]) && Qf(n.prototype, r),
                i && Qf(n, i),
                Object.defineProperty(n, "prototype", {
                    writable: !1
                }),
                t
            }(p);
            function sm(e) {
                return sm = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                }
                : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }
                ,
                sm(e)
            }
            function om(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1,
                    r.configurable = !0,
                    "value"in r && (r.writable = !0),
                    Object.defineProperty(e, lm(r.key), r)
                }
            }
            function lm(e) {
                var t = function(e, t) {
                    if ("object" != sm(e) || !e)
                        return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var r = n.call(e, t || "default");
                        if ("object" != sm(r))
                            return r;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return ("string" === t ? String : Number)(e)
                }(e, "string");
                return "symbol" == sm(t) ? t : String(t)
            }
            function cm(e, t, n) {
                return t = dm(t),
                function(e, t) {
                    if (t && ("object" === sm(t) || "function" == typeof t))
                        return t;
                    if (void 0 !== t)
                        throw new TypeError("Derived constructors may only return object or undefined");
                    return function(e) {
                        if (void 0 === e)
                            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return e
                    }(e)
                }(e, um() ? Reflect.construct(t, n || [], dm(e).constructor) : t.apply(e, n))
            }
            function um() {
                try {
                    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
                    )))
                } catch (e) {}
                return (um = function() {
                    return !!e
                }
                )()
            }
            function dm(e) {
                return dm = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                }
                ,
                dm(e)
            }
            function hm(e, t) {
                return hm = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
                    return e.__proto__ = t,
                    e
                }
                ,
                hm(e, t)
            }
            var pm = function(e) {
                function t(e) {
                    var n;
                    return function(e, t) {
                        if (!(e instanceof t))
                            throw new TypeError("Cannot call a class as a function")
                    }(this, t),
                    (n = cm(this, t, [e])).videoUrl = null,
                    n.validVideo = !1,
                    n.embedCode = null,
                    n.embedTarget = null,
                    n
                }
                var n, r, i;
                return function(e, t) {
                    if ("function" != typeof t && null !== t)
                        throw new TypeError("Super expression must either be null or a function");
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            writable: !0,
                            configurable: !0
                        }
                    }),
                    Object.defineProperty(e, "prototype", {
                        writable: !1
                    }),
                    t && hm(e, t)
                }(t, e),
                n = t,
                (r = [{
                    key: "init",
                    value: function() {
                        var e = this;
                        this.videoUrl = this.el.href,
                        null !== this.videoUrl && (this.embedTarget = g.querySelector("[data-module-video-embed]"),
                        this.validateVideo(),
                        this.el.addEventListener("click", (function(t) {
                            e.playVideo(t)
                        }
                        ))),
                        y.IS_DEV && console.log("Play Video: Initiated")
                    }
                }, {
                    key: "playVideo",
                    value: function(e) {
                        e.preventDefault(),
                        null === this.validVideo || null === this.embedCode || null === this.embedTarget || g.classList.contains(x.VIDEO_PLAYING) || (this.embedTarget.innerHTML = this.embedCode,
                        g.classList.add(x.VIDEO_PLAYING),
                        this.call("pauseScroll", !0, "Scroll", "main"))
                    }
                }, {
                    key: "validateVideo",
                    value: function() {
                        this.videoUrl.match(/(http:|https:|)\/\/(player.|www.)?(vimeo\.com|youtu(be\.com|\.be|be\.googleapis\.com))\/(video\/|embed\/|watch\?v=|v\/)?([A-Za-z0-9._%-]*)(\&\S+)?/),
                        RegExp.$3.indexOf("youtu") > -1 ? (this.validVideo = !0,
                        this.embedCode = '<iframe width="420" height="345" src="https://www.youtube.com/embed/' + RegExp.$6 + '" frameborder="0" allowfullscreen></iframe>') : RegExp.$3.indexOf("vimeo") > -1 && (this.validVideo = !0,
                        this.embedCode = '<iframe width="420" height="345" src="//player.vimeo.com/video/' + RegExp.$6 + '" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>')
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        y.IS_DEV && console.log("Play Video: Destroyed")
                    }
                }]) && om(n.prototype, r),
                i && om(n, i),
                Object.defineProperty(n, "prototype", {
                    writable: !1
                }),
                t
            }(p);
            function fm(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1,
                    r.configurable = !0,
                    "value"in r && (r.writable = !0),
                    Object.defineProperty(e, r.key, r)
                }
            }
            var mm, gm, vm, _m, ym, xm, bm, Em, Sm, wm, Mm, Tm, Am, Cm = function() {
                return mm || "undefined" != typeof window && (mm = window.gsap) && mm.registerPlugin && mm
            }, Pm = 1, Rm = [], Lm = [], Om = [], Dm = Date.now, Im = function(e, t) {
                return t
            }, Nm = function(e, t) {
                return ~Om.indexOf(e) && Om[Om.indexOf(e) + 1][t]
            }, Um = function(e) {
                return !!~wm.indexOf(e)
            }, km = function(e, t, n, r, i) {
                return e.addEventListener(t, n, {
                    passive: !1 !== r,
                    capture: !!i
                })
            }, Fm = function(e, t, n, r) {
                return e.removeEventListener(t, n, !!r)
            }, zm = "scrollLeft", Bm = "scrollTop", Hm = function() {
                return Mm && Mm.isPressed || Lm.cache++
            }, Gm = function(e, t) {
                var n = function n(r) {
                    if (r || 0 === r) {
                        Pm && (vm.history.scrollRestoration = "manual");
                        var i = Mm && Mm.isPressed;
                        r = n.v = Math.round(r) || (Mm && Mm.iOS ? 1 : 0),
                        e(r),
                        n.cacheID = Lm.cache,
                        i && Im("ss", r)
                    } else
                        (t || Lm.cache !== n.cacheID || Im("ref")) && (n.cacheID = Lm.cache,
                        n.v = e());
                    return n.v + n.offset
                };
                return n.offset = 0,
                e && n
            }, Vm = {
                s: zm,
                p: "left",
                p2: "Left",
                os: "right",
                os2: "Right",
                d: "width",
                d2: "Width",
                a: "x",
                sc: Gm((function(e) {
                    return arguments.length ? vm.scrollTo(e, Wm.sc()) : vm.pageXOffset || _m[zm] || ym[zm] || xm[zm] || 0
                }
                ))
            }, Wm = {
                s: Bm,
                p: "top",
                p2: "Top",
                os: "bottom",
                os2: "Bottom",
                d: "height",
                d2: "Height",
                a: "y",
                op: Vm,
                sc: Gm((function(e) {
                    return arguments.length ? vm.scrollTo(Vm.sc(), e) : vm.pageYOffset || _m[Bm] || ym[Bm] || xm[Bm] || 0
                }
                ))
            }, jm = function(e, t) {
                return (t && t._ctx && t._ctx.selector || mm.utils.toArray)(e)[0] || ("string" == typeof e && !1 !== mm.config().nullTargetWarn ? console.warn("Element not found:", e) : null)
            }, Xm = function(e, t) {
                var n = t.s
                  , r = t.sc;
                Um(e) && (e = _m.scrollingElement || ym);
                var i = Lm.indexOf(e)
                  , a = r === Wm.sc ? 1 : 2;
                !~i && (i = Lm.push(e) - 1),
                Lm[i + a] || km(e, "scroll", Hm);
                var s = Lm[i + a]
                  , o = s || (Lm[i + a] = Gm(Nm(e, n), !0) || (Um(e) ? r : Gm((function(t) {
                    return arguments.length ? e[n] = t : e[n]
                }
                ))));
                return o.target = e,
                s || (o.smooth = "smooth" === mm.getProperty(e, "scrollBehavior")),
                o
            }, qm = function(e, t, n) {
                var r = e
                  , i = e
                  , a = Dm()
                  , s = a
                  , o = t || 50
                  , l = Math.max(500, 3 * o)
                  , c = function(e, t) {
                    var l = Dm();
                    t || l - a > o ? (i = r,
                    r = e,
                    s = a,
                    a = l) : n ? r += e : r = i + (e - i) / (l - s) * (a - s)
                };
                return {
                    update: c,
                    reset: function() {
                        i = r = n ? 0 : r,
                        s = a = 0
                    },
                    getVelocity: function(e) {
                        var t = s
                          , o = i
                          , u = Dm();
                        return (e || 0 === e) && e !== r && c(e),
                        a === s || u - s > l ? 0 : (r + (n ? o : -o)) / ((n ? u : a) - t) * 1e3
                    }
                }
            }, Ym = function(e, t) {
                return t && !e._gsapAllow && e.preventDefault(),
                e.changedTouches ? e.changedTouches[0] : e
            }, $m = function(e) {
                var t = Math.max.apply(Math, e)
                  , n = Math.min.apply(Math, e);
                return Math.abs(t) >= Math.abs(n) ? t : n
            }, Km = function() {
                var e, t, n, r;
                (Sm = mm.core.globals().ScrollTrigger) && Sm.core && (e = Sm.core,
                t = e.bridge || {},
                n = e._scrollers,
                r = e._proxies,
                n.push.apply(n, Lm),
                r.push.apply(r, Om),
                Lm = n,
                Om = r,
                Im = function(e, n) {
                    return t[e](n)
                }
                )
            }, Zm = function(e) {
                return mm = e || Cm(),
                !gm && mm && "undefined" != typeof document && document.body && (vm = window,
                _m = document,
                ym = _m.documentElement,
                xm = _m.body,
                wm = [vm, _m, ym, xm],
                mm.utils.clamp,
                Am = mm.core.context || function() {}
                ,
                Em = "onpointerenter"in xm ? "pointer" : "mouse",
                bm = Jm.isTouch = vm.matchMedia && vm.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart"in vm || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0,
                Tm = Jm.eventTypes = ("ontouchstart"in ym ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown"in ym ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","),
                setTimeout((function() {
                    return Pm = 0
                }
                ), 500),
                Km(),
                gm = 1),
                gm
            };
            Vm.op = Wm,
            Lm.cache = 0;
            var Jm = function() {
                function e(e) {
                    this.init(e)
                }
                var t, n, r;
                return e.prototype.init = function(e) {
                    gm || Zm(mm) || console.warn("Please gsap.registerPlugin(Observer)"),
                    Sm || Km();
                    var t = e.tolerance
                      , n = e.dragMinimum
                      , r = e.type
                      , i = e.target
                      , a = e.lineHeight
                      , s = e.debounce
                      , o = e.preventDefault
                      , l = e.onStop
                      , c = e.onStopDelay
                      , u = e.ignore
                      , d = e.wheelSpeed
                      , h = e.event
                      , p = e.onDragStart
                      , f = e.onDragEnd
                      , m = e.onDrag
                      , g = e.onPress
                      , v = e.onRelease
                      , _ = e.onRight
                      , y = e.onLeft
                      , x = e.onUp
                      , b = e.onDown
                      , E = e.onChangeX
                      , S = e.onChangeY
                      , w = e.onChange
                      , M = e.onToggleX
                      , T = e.onToggleY
                      , A = e.onHover
                      , C = e.onHoverEnd
                      , P = e.onMove
                      , R = e.ignoreCheck
                      , L = e.isNormalizer
                      , O = e.onGestureStart
                      , D = e.onGestureEnd
                      , I = e.onWheel
                      , N = e.onEnable
                      , U = e.onDisable
                      , k = e.onClick
                      , F = e.scrollSpeed
                      , z = e.capture
                      , B = e.allowClicks
                      , H = e.lockAxis
                      , G = e.onLockAxis;
                    this.target = i = jm(i) || ym,
                    this.vars = e,
                    u && (u = mm.utils.toArray(u)),
                    t = t || 1e-9,
                    n = n || 0,
                    d = d || 1,
                    F = F || 1,
                    r = r || "wheel,touch,pointer",
                    s = !1 !== s,
                    a || (a = parseFloat(vm.getComputedStyle(xm).lineHeight) || 22);
                    var V, W, j, X, q, Y, $, K = this, Z = 0, J = 0, Q = e.passive || !o, ee = Xm(i, Vm), te = Xm(i, Wm), ne = ee(), re = te(), ie = ~r.indexOf("touch") && !~r.indexOf("pointer") && "pointerdown" === Tm[0], ae = Um(i), se = i.ownerDocument || _m, oe = [0, 0, 0], le = [0, 0, 0], ce = 0, ue = function() {
                        return ce = Dm()
                    }, de = function(e, t) {
                        return (K.event = e) && u && ~u.indexOf(e.target) || t && ie && "touch" !== e.pointerType || R && R(e, t)
                    }, he = function() {
                        var e = K.deltaX = $m(oe)
                          , n = K.deltaY = $m(le)
                          , r = Math.abs(e) >= t
                          , i = Math.abs(n) >= t;
                        w && (r || i) && w(K, e, n, oe, le),
                        r && (_ && K.deltaX > 0 && _(K),
                        y && K.deltaX < 0 && y(K),
                        E && E(K),
                        M && K.deltaX < 0 != Z < 0 && M(K),
                        Z = K.deltaX,
                        oe[0] = oe[1] = oe[2] = 0),
                        i && (b && K.deltaY > 0 && b(K),
                        x && K.deltaY < 0 && x(K),
                        S && S(K),
                        T && K.deltaY < 0 != J < 0 && T(K),
                        J = K.deltaY,
                        le[0] = le[1] = le[2] = 0),
                        (X || j) && (P && P(K),
                        j && (m(K),
                        j = !1),
                        X = !1),
                        Y && !(Y = !1) && G && G(K),
                        q && (I(K),
                        q = !1),
                        V = 0
                    }, pe = function(e, t, n) {
                        oe[n] += e,
                        le[n] += t,
                        K._vx.update(e),
                        K._vy.update(t),
                        s ? V || (V = requestAnimationFrame(he)) : he()
                    }, fe = function(e, t) {
                        H && !$ && (K.axis = $ = Math.abs(e) > Math.abs(t) ? "x" : "y",
                        Y = !0),
                        "y" !== $ && (oe[2] += e,
                        K._vx.update(e, !0)),
                        "x" !== $ && (le[2] += t,
                        K._vy.update(t, !0)),
                        s ? V || (V = requestAnimationFrame(he)) : he()
                    }, me = function(e) {
                        if (!de(e, 1)) {
                            var t = (e = Ym(e, o)).clientX
                              , r = e.clientY
                              , i = t - K.x
                              , a = r - K.y
                              , s = K.isDragging;
                            K.x = t,
                            K.y = r,
                            (s || Math.abs(K.startX - t) >= n || Math.abs(K.startY - r) >= n) && (m && (j = !0),
                            s || (K.isDragging = !0),
                            fe(i, a),
                            s || p && p(K))
                        }
                    }, ge = K.onPress = function(e) {
                        de(e, 1) || e && e.button || (K.axis = $ = null,
                        W.pause(),
                        K.isPressed = !0,
                        e = Ym(e),
                        Z = J = 0,
                        K.startX = K.x = e.clientX,
                        K.startY = K.y = e.clientY,
                        K._vx.reset(),
                        K._vy.reset(),
                        km(L ? i : se, Tm[1], me, Q, !0),
                        K.deltaX = K.deltaY = 0,
                        g && g(K))
                    }
                    , ve = K.onRelease = function(e) {
                        if (!de(e, 1)) {
                            Fm(L ? i : se, Tm[1], me, !0);
                            var t = !isNaN(K.y - K.startY)
                              , n = K.isDragging
                              , r = n && (Math.abs(K.x - K.startX) > 3 || Math.abs(K.y - K.startY) > 3)
                              , a = Ym(e);
                            !r && t && (K._vx.reset(),
                            K._vy.reset(),
                            o && B && mm.delayedCall(.08, (function() {
                                if (Dm() - ce > 300 && !e.defaultPrevented)
                                    if (e.target.click)
                                        e.target.click();
                                    else if (se.createEvent) {
                                        var t = se.createEvent("MouseEvents");
                                        t.initMouseEvent("click", !0, !0, vm, 1, a.screenX, a.screenY, a.clientX, a.clientY, !1, !1, !1, !1, 0, null),
                                        e.target.dispatchEvent(t)
                                    }
                            }
                            ))),
                            K.isDragging = K.isGesturing = K.isPressed = !1,
                            l && n && !L && W.restart(!0),
                            f && n && f(K),
                            v && v(K, r)
                        }
                    }
                    , _e = function(e) {
                        return e.touches && e.touches.length > 1 && (K.isGesturing = !0) && O(e, K.isDragging)
                    }, ye = function() {
                        return (K.isGesturing = !1) || D(K)
                    }, xe = function(e) {
                        if (!de(e)) {
                            var t = ee()
                              , n = te();
                            pe((t - ne) * F, (n - re) * F, 1),
                            ne = t,
                            re = n,
                            l && W.restart(!0)
                        }
                    }, be = function(e) {
                        if (!de(e)) {
                            e = Ym(e, o),
                            I && (q = !0);
                            var t = (1 === e.deltaMode ? a : 2 === e.deltaMode ? vm.innerHeight : 1) * d;
                            pe(e.deltaX * t, e.deltaY * t, 0),
                            l && !L && W.restart(!0)
                        }
                    }, Ee = function(e) {
                        if (!de(e)) {
                            var t = e.clientX
                              , n = e.clientY
                              , r = t - K.x
                              , i = n - K.y;
                            K.x = t,
                            K.y = n,
                            X = !0,
                            l && W.restart(!0),
                            (r || i) && fe(r, i)
                        }
                    }, Se = function(e) {
                        K.event = e,
                        A(K)
                    }, we = function(e) {
                        K.event = e,
                        C(K)
                    }, Me = function(e) {
                        return de(e) || Ym(e, o) && k(K)
                    };
                    W = K._dc = mm.delayedCall(c || .25, (function() {
                        K._vx.reset(),
                        K._vy.reset(),
                        W.pause(),
                        l && l(K)
                    }
                    )).pause(),
                    K.deltaX = K.deltaY = 0,
                    K._vx = qm(0, 50, !0),
                    K._vy = qm(0, 50, !0),
                    K.scrollX = ee,
                    K.scrollY = te,
                    K.isDragging = K.isGesturing = K.isPressed = !1,
                    Am(this),
                    K.enable = function(e) {
                        return K.isEnabled || (km(ae ? se : i, "scroll", Hm),
                        r.indexOf("scroll") >= 0 && km(ae ? se : i, "scroll", xe, Q, z),
                        r.indexOf("wheel") >= 0 && km(i, "wheel", be, Q, z),
                        (r.indexOf("touch") >= 0 && bm || r.indexOf("pointer") >= 0) && (km(i, Tm[0], ge, Q, z),
                        km(se, Tm[2], ve),
                        km(se, Tm[3], ve),
                        B && km(i, "click", ue, !0, !0),
                        k && km(i, "click", Me),
                        O && km(se, "gesturestart", _e),
                        D && km(se, "gestureend", ye),
                        A && km(i, Em + "enter", Se),
                        C && km(i, Em + "leave", we),
                        P && km(i, Em + "move", Ee)),
                        K.isEnabled = !0,
                        e && e.type && ge(e),
                        N && N(K)),
                        K
                    }
                    ,
                    K.disable = function() {
                        K.isEnabled && (Rm.filter((function(e) {
                            return e !== K && Um(e.target)
                        }
                        )).length || Fm(ae ? se : i, "scroll", Hm),
                        K.isPressed && (K._vx.reset(),
                        K._vy.reset(),
                        Fm(L ? i : se, Tm[1], me, !0)),
                        Fm(ae ? se : i, "scroll", xe, z),
                        Fm(i, "wheel", be, z),
                        Fm(i, Tm[0], ge, z),
                        Fm(se, Tm[2], ve),
                        Fm(se, Tm[3], ve),
                        Fm(i, "click", ue, !0),
                        Fm(i, "click", Me),
                        Fm(se, "gesturestart", _e),
                        Fm(se, "gestureend", ye),
                        Fm(i, Em + "enter", Se),
                        Fm(i, Em + "leave", we),
                        Fm(i, Em + "move", Ee),
                        K.isEnabled = K.isPressed = K.isDragging = !1,
                        U && U(K))
                    }
                    ,
                    K.kill = K.revert = function() {
                        K.disable();
                        var e = Rm.indexOf(K);
                        e >= 0 && Rm.splice(e, 1),
                        Mm === K && (Mm = 0)
                    }
                    ,
                    Rm.push(K),
                    L && Um(i) && (Mm = K),
                    K.enable(h)
                }
                ,
                t = e,
                (n = [{
                    key: "velocityX",
                    get: function() {
                        return this._vx.getVelocity()
                    }
                }, {
                    key: "velocityY",
                    get: function() {
                        return this._vy.getVelocity()
                    }
                }]) && fm(t.prototype, n),
                r && fm(t, r),
                e
            }();
            Jm.version = "3.12.5",
            Jm.create = function(e) {
                return new Jm(e)
            }
            ,
            Jm.register = Zm,
            Jm.getAll = function() {
                return Rm.slice()
            }
            ,
            Jm.getById = function(e) {
                return Rm.filter((function(t) {
                    return t.vars.id === e
                }
                ))[0]
            }
            ,
            Cm() && mm.registerPlugin(Jm);
            var Qm, eg, tg, ng, rg, ig, ag, sg, og, lg, cg, ug, dg, hg, pg, fg, mg, gg, vg, _g, yg, xg, bg, Eg, Sg, wg, Mg, Tg, Ag, Cg, Pg, Rg, Lg, Og, Dg, Ig, Ng, Ug, kg = 1, Fg = Date.now, zg = Fg(), Bg = 0, Hg = 0, Gg = function(e, t, n) {
                var r = nv(e) && ("clamp(" === e.substr(0, 6) || e.indexOf("max") > -1);
                return n["_" + t + "Clamp"] = r,
                r ? e.substr(6, e.length - 7) : e
            }, Vg = function(e, t) {
                return !t || nv(e) && "clamp(" === e.substr(0, 6) ? e : "clamp(" + e + ")"
            }, Wg = function e() {
                return Hg && requestAnimationFrame(e)
            }, jg = function() {
                return hg = 1
            }, Xg = function() {
                return hg = 0
            }, qg = function(e) {
                return e
            }, Yg = function(e) {
                return Math.round(1e5 * e) / 1e5 || 0
            }, $g = function() {
                return "undefined" != typeof window
            }, Kg = function() {
                return Qm || $g() && (Qm = window.gsap) && Qm.registerPlugin && Qm
            }, Zg = function(e) {
                return !!~ag.indexOf(e)
            }, Jg = function(e) {
                return ("Height" === e ? Pg : tg["inner" + e]) || rg["client" + e] || ig["client" + e]
            }, Qg = function(e) {
                return Nm(e, "getBoundingClientRect") || (Zg(e) ? function() {
                    return h_.width = tg.innerWidth,
                    h_.height = Pg,
                    h_
                }
                : function() {
                    return Mv(e)
                }
                )
            }, ev = function(e, t) {
                var n = t.s
                  , r = t.d2
                  , i = t.d
                  , a = t.a;
                return Math.max(0, (n = "scroll" + r) && (a = Nm(e, n)) ? a() - Qg(e)()[i] : Zg(e) ? (rg[n] || ig[n]) - Jg(r) : e[n] - e["offset" + r])
            }, tv = function(e, t) {
                for (var n = 0; n < vg.length; n += 3)
                    (!t || ~t.indexOf(vg[n + 1])) && e(vg[n], vg[n + 1], vg[n + 2])
            }, nv = function(e) {
                return "string" == typeof e
            }, rv = function(e) {
                return "function" == typeof e
            }, iv = function(e) {
                return "number" == typeof e
            }, av = function(e) {
                return "object" == typeof e
            }, sv = function(e, t, n) {
                return e && e.progress(t ? 0 : 1) && n && e.pause()
            }, ov = function(e, t) {
                if (e.enabled) {
                    var n = e._ctx ? e._ctx.add((function() {
                        return t(e)
                    }
                    )) : t(e);
                    n && n.totalTime && (e.callbackAnimation = n)
                }
            }, lv = Math.abs, cv = "left", uv = "right", dv = "bottom", hv = "width", pv = "height", fv = "Right", mv = "Left", gv = "Top", vv = "Bottom", _v = "padding", yv = "margin", xv = "Width", bv = "Height", Ev = "px", Sv = function(e) {
                return tg.getComputedStyle(e)
            }, wv = function(e, t) {
                for (var n in t)
                    n in e || (e[n] = t[n]);
                return e
            }, Mv = function(e, t) {
                var n = t && "matrix(1, 0, 0, 1, 0, 0)" !== Sv(e)[pg] && Qm.to(e, {
                    x: 0,
                    y: 0,
                    xPercent: 0,
                    yPercent: 0,
                    rotation: 0,
                    rotationX: 0,
                    rotationY: 0,
                    scale: 1,
                    skewX: 0,
                    skewY: 0
                }).progress(1)
                  , r = e.getBoundingClientRect();
                return n && n.progress(0).kill(),
                r
            }, Tv = function(e, t) {
                var n = t.d2;
                return e["offset" + n] || e["client" + n] || 0
            }, Av = function(e) {
                var t, n = [], r = e.labels, i = e.duration();
                for (t in r)
                    n.push(r[t] / i);
                return n
            }, Cv = function(e) {
                var t = Qm.utils.snap(e)
                  , n = Array.isArray(e) && e.slice(0).sort((function(e, t) {
                    return e - t
                }
                ));
                return n ? function(e, r, i) {
                    var a;
                    if (void 0 === i && (i = .001),
                    !r)
                        return t(e);
                    if (r > 0) {
                        for (e -= i,
                        a = 0; a < n.length; a++)
                            if (n[a] >= e)
                                return n[a];
                        return n[a - 1]
                    }
                    for (a = n.length,
                    e += i; a--; )
                        if (n[a] <= e)
                            return n[a];
                    return n[0]
                }
                : function(n, r, i) {
                    void 0 === i && (i = .001);
                    var a = t(n);
                    return !r || Math.abs(a - n) < i || a - n < 0 == r < 0 ? a : t(r < 0 ? n - e : n + e)
                }
            }, Pv = function(e, t, n, r) {
                return n.split(",").forEach((function(n) {
                    return e(t, n, r)
                }
                ))
            }, Rv = function(e, t, n, r, i) {
                return e.addEventListener(t, n, {
                    passive: !r,
                    capture: !!i
                })
            }, Lv = function(e, t, n, r) {
                return e.removeEventListener(t, n, !!r)
            }, Ov = function(e, t, n) {
                (n = n && n.wheelHandler) && (e(t, "wheel", n),
                e(t, "touchmove", n))
            }, Dv = {
                startColor: "green",
                endColor: "red",
                indent: 0,
                fontSize: "16px",
                fontWeight: "normal"
            }, Iv = {
                toggleActions: "play",
                anticipatePin: 0
            }, Nv = {
                top: 0,
                left: 0,
                center: .5,
                bottom: 1,
                right: 1
            }, Uv = function(e, t) {
                if (nv(e)) {
                    var n = e.indexOf("=")
                      , r = ~n ? +(e.charAt(n - 1) + 1) * parseFloat(e.substr(n + 1)) : 0;
                    ~n && (e.indexOf("%") > n && (r *= t / 100),
                    e = e.substr(0, n - 1)),
                    e = r + (e in Nv ? Nv[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0)
                }
                return e
            }, kv = function(e, t, n, r, i, a, s, o) {
                var l = i.startColor
                  , c = i.endColor
                  , u = i.fontSize
                  , d = i.indent
                  , h = i.fontWeight
                  , p = ng.createElement("div")
                  , f = Zg(n) || "fixed" === Nm(n, "pinType")
                  , m = -1 !== e.indexOf("scroller")
                  , g = f ? ig : n
                  , v = -1 !== e.indexOf("start")
                  , _ = v ? l : c
                  , y = "border-color:" + _ + ";font-size:" + u + ";color:" + _ + ";font-weight:" + h + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
                return y += "position:" + ((m || o) && f ? "fixed;" : "absolute;"),
                (m || o || !f) && (y += (r === Wm ? uv : dv) + ":" + (a + parseFloat(d)) + "px;"),
                s && (y += "box-sizing:border-box;text-align:left;width:" + s.offsetWidth + "px;"),
                p._isStart = v,
                p.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")),
                p.style.cssText = y,
                p.innerText = t || 0 === t ? e + "-" + t : e,
                g.children[0] ? g.insertBefore(p, g.children[0]) : g.appendChild(p),
                p._offset = p["offset" + r.op.d2],
                Fv(p, 0, r, v),
                p
            }, Fv = function(e, t, n, r) {
                var i = {
                    display: "block"
                }
                  , a = n[r ? "os2" : "p2"]
                  , s = n[r ? "p2" : "os2"];
                e._isFlipped = r,
                i[n.a + "Percent"] = r ? -100 : 0,
                i[n.a] = r ? "1px" : 0,
                i["border" + a + xv] = 1,
                i["border" + s + xv] = 0,
                i[n.p] = t + "px",
                Qm.set(e, i)
            }, zv = [], Bv = {}, Hv = function() {
                return Fg() - Bg > 34 && (Dg || (Dg = requestAnimationFrame(a_)))
            }, Gv = function() {
                (!bg || !bg.isPressed || bg.startX > ig.clientWidth) && (Lm.cache++,
                bg ? Dg || (Dg = requestAnimationFrame(a_)) : a_(),
                Bg || Yv("scrollStart"),
                Bg = Fg())
            }, Vv = function() {
                wg = tg.innerWidth,
                Sg = tg.innerHeight
            }, Wv = function() {
                Lm.cache++,
                !dg && !xg && !ng.fullscreenElement && !ng.webkitFullscreenElement && (!Eg || wg !== tg.innerWidth || Math.abs(tg.innerHeight - Sg) > .25 * tg.innerHeight) && sg.restart(!0)
            }, jv = {}, Xv = [], qv = function e() {
                return Lv(y_, "scrollEnd", e) || n_(!0)
            }, Yv = function(e) {
                return jv[e] && jv[e].map((function(e) {
                    return e()
                }
                )) || Xv
            }, $v = [], Kv = function(e) {
                for (var t = 0; t < $v.length; t += 5)
                    (!e || $v[t + 4] && $v[t + 4].query === e) && ($v[t].style.cssText = $v[t + 1],
                    $v[t].getBBox && $v[t].setAttribute("transform", $v[t + 2] || ""),
                    $v[t + 3].uncache = 1)
            }, Zv = function(e, t) {
                var n;
                for (fg = 0; fg < zv.length; fg++)
                    !(n = zv[fg]) || t && n._ctx !== t || (e ? n.kill(1) : n.revert(!0, !0));
                Rg = !0,
                t && Kv(t),
                t || Yv("revert")
            }, Jv = function(e, t) {
                Lm.cache++,
                (t || !Ig) && Lm.forEach((function(e) {
                    return rv(e) && e.cacheID++ && (e.rec = 0)
                }
                )),
                nv(e) && (tg.history.scrollRestoration = Ag = e)
            }, Qv = 0, e_ = function() {
                ig.appendChild(Cg),
                Pg = !bg && Cg.offsetHeight || tg.innerHeight,
                ig.removeChild(Cg)
            }, t_ = function(e) {
                return og(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach((function(t) {
                    return t.style.display = e ? "none" : "block"
                }
                ))
            }, n_ = function(e, t) {
                if (!Bg || e || Rg) {
                    e_(),
                    Ig = y_.isRefreshing = !0,
                    Lm.forEach((function(e) {
                        return rv(e) && ++e.cacheID && (e.rec = e())
                    }
                    ));
                    var n = Yv("refreshInit");
                    _g && y_.sort(),
                    t || Zv(),
                    Lm.forEach((function(e) {
                        rv(e) && (e.smooth && (e.target.style.scrollBehavior = "auto"),
                        e(0))
                    }
                    )),
                    zv.slice(0).forEach((function(e) {
                        return e.refresh()
                    }
                    )),
                    Rg = !1,
                    zv.forEach((function(e) {
                        if (e._subPinOffset && e.pin) {
                            var t = e.vars.horizontal ? "offsetWidth" : "offsetHeight"
                              , n = e.pin[t];
                            e.revert(!0, 1),
                            e.adjustPinSpacing(e.pin[t] - n),
                            e.refresh()
                        }
                    }
                    )),
                    Lg = 1,
                    t_(!0),
                    zv.forEach((function(e) {
                        var t = ev(e.scroller, e._dir)
                          , n = "max" === e.vars.end || e._endClamp && e.end > t
                          , r = e._startClamp && e.start >= t;
                        (n || r) && e.setPositions(r ? t - 1 : e.start, n ? Math.max(r ? t : e.start + 1, t) : e.end, !0)
                    }
                    )),
                    t_(!1),
                    Lg = 0,
                    n.forEach((function(e) {
                        return e && e.render && e.render(-1)
                    }
                    )),
                    Lm.forEach((function(e) {
                        rv(e) && (e.smooth && requestAnimationFrame((function() {
                            return e.target.style.scrollBehavior = "smooth"
                        }
                        )),
                        e.rec && e(e.rec))
                    }
                    )),
                    Jv(Ag, 1),
                    sg.pause(),
                    Qv++,
                    Ig = 2,
                    a_(2),
                    zv.forEach((function(e) {
                        return rv(e.vars.onRefresh) && e.vars.onRefresh(e)
                    }
                    )),
                    Ig = y_.isRefreshing = !1,
                    Yv("refresh")
                } else
                    Rv(y_, "scrollEnd", qv)
            }, r_ = 0, i_ = 1, a_ = function(e) {
                if (2 === e || !Ig && !Rg) {
                    y_.isUpdating = !0,
                    Ug && Ug.update(0);
                    var t = zv.length
                      , n = Fg()
                      , r = n - zg >= 50
                      , i = t && zv[0].scroll();
                    if (i_ = r_ > i ? -1 : 1,
                    Ig || (r_ = i),
                    r && (Bg && !hg && n - Bg > 200 && (Bg = 0,
                    Yv("scrollEnd")),
                    cg = zg,
                    zg = n),
                    i_ < 0) {
                        for (fg = t; fg-- > 0; )
                            zv[fg] && zv[fg].update(0, r);
                        i_ = 1
                    } else
                        for (fg = 0; fg < t; fg++)
                            zv[fg] && zv[fg].update(0, r);
                    y_.isUpdating = !1
                }
                Dg = 0
            }, s_ = [cv, "top", dv, uv, yv + vv, yv + fv, yv + gv, yv + mv, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], o_ = s_.concat([hv, pv, "boxSizing", "max" + xv, "max" + bv, "position", yv, _v, _v + gv, _v + fv, _v + vv, _v + mv]), l_ = function(e, t, n, r) {
                if (!e._gsap.swappedIn) {
                    for (var i, a = s_.length, s = t.style, o = e.style; a--; )
                        s[i = s_[a]] = n[i];
                    s.position = "absolute" === n.position ? "absolute" : "relative",
                    "inline" === n.display && (s.display = "inline-block"),
                    o[dv] = o[uv] = "auto",
                    s.flexBasis = n.flexBasis || "auto",
                    s.overflow = "visible",
                    s.boxSizing = "border-box",
                    s[hv] = Tv(e, Vm) + Ev,
                    s[pv] = Tv(e, Wm) + Ev,
                    s[_v] = o[yv] = o.top = o[cv] = "0",
                    u_(r),
                    o[hv] = o["max" + xv] = n[hv],
                    o[pv] = o["max" + bv] = n[pv],
                    o[_v] = n[_v],
                    e.parentNode !== t && (e.parentNode.insertBefore(t, e),
                    t.appendChild(e)),
                    e._gsap.swappedIn = !0
                }
            }, c_ = /([A-Z])/g, u_ = function(e) {
                if (e) {
                    var t, n, r = e.t.style, i = e.length, a = 0;
                    for ((e.t._gsap || Qm.core.getCache(e.t)).uncache = 1; a < i; a += 2)
                        n = e[a + 1],
                        t = e[a],
                        n ? r[t] = n : r[t] && r.removeProperty(t.replace(c_, "-$1").toLowerCase())
                }
            }, d_ = function(e) {
                for (var t = o_.length, n = e.style, r = [], i = 0; i < t; i++)
                    r.push(o_[i], n[o_[i]]);
                return r.t = e,
                r
            }, h_ = {
                left: 0,
                top: 0
            }, p_ = function(e, t, n, r, i, a, s, o, l, c, u, d, h, p) {
                rv(e) && (e = e(o)),
                nv(e) && "max" === e.substr(0, 3) && (e = d + ("=" === e.charAt(4) ? Uv("0" + e.substr(3), n) : 0));
                var f, m, g, v = h ? h.time() : 0;
                if (h && h.seek(0),
                isNaN(e) || (e = +e),
                iv(e))
                    h && (e = Qm.utils.mapRange(h.scrollTrigger.start, h.scrollTrigger.end, 0, d, e)),
                    s && Fv(s, n, r, !0);
                else {
                    rv(t) && (t = t(o));
                    var _, y, x, b, E = (e || "0").split(" ");
                    g = jm(t, o) || ig,
                    (_ = Mv(g) || {}) && (_.left || _.top) || "none" !== Sv(g).display || (b = g.style.display,
                    g.style.display = "block",
                    _ = Mv(g),
                    b ? g.style.display = b : g.style.removeProperty("display")),
                    y = Uv(E[0], _[r.d]),
                    x = Uv(E[1] || "0", n),
                    e = _[r.p] - l[r.p] - c + y + i - x,
                    s && Fv(s, x, r, n - x < 20 || s._isStart && x > 20),
                    n -= n - x
                }
                if (p && (o[p] = e || -.001,
                e < 0 && (e = 0)),
                a) {
                    var S = e + n
                      , w = a._isStart;
                    f = "scroll" + r.d2,
                    Fv(a, S, r, w && S > 20 || !w && (u ? Math.max(ig[f], rg[f]) : a.parentNode[f]) <= S + 1),
                    u && (l = Mv(s),
                    u && (a.style[r.op.p] = l[r.op.p] - r.op.m - a._offset + Ev))
                }
                return h && g && (f = Mv(g),
                h.seek(d),
                m = Mv(g),
                h._caScrollDist = f[r.p] - m[r.p],
                e = e / h._caScrollDist * d),
                h && h.seek(v),
                h ? e : Math.round(e)
            }, f_ = /(webkit|moz|length|cssText|inset)/i, m_ = function(e, t, n, r) {
                if (e.parentNode !== t) {
                    var i, a, s = e.style;
                    if (t === ig) {
                        for (i in e._stOrig = s.cssText,
                        a = Sv(e))
                            +i || f_.test(i) || !a[i] || "string" != typeof s[i] || "0" === i || (s[i] = a[i]);
                        s.top = n,
                        s.left = r
                    } else
                        s.cssText = e._stOrig;
                    Qm.core.getCache(e).uncache = 1,
                    t.appendChild(e)
                }
            }, g_ = function(e, t, n) {
                var r = t
                  , i = r;
                return function(t) {
                    var a = Math.round(e());
                    return a !== r && a !== i && Math.abs(a - r) > 3 && Math.abs(a - i) > 3 && (t = a,
                    n && n()),
                    i = r,
                    r = t,
                    t
                }
            }, v_ = function(e, t, n) {
                var r = {};
                r[t.p] = "+=" + n,
                Qm.set(e, r)
            }, __ = function(e, t) {
                var n = Xm(e, t)
                  , r = "_scroll" + t.p2
                  , i = function t(i, a, s, o, l) {
                    var c = t.tween
                      , u = a.onComplete
                      , d = {};
                    s = s || n();
                    var h = g_(n, s, (function() {
                        c.kill(),
                        t.tween = 0
                    }
                    ));
                    return l = o && l || 0,
                    o = o || i - s,
                    c && c.kill(),
                    a[r] = i,
                    a.inherit = !1,
                    a.modifiers = d,
                    d[r] = function() {
                        return h(s + o * c.ratio + l * c.ratio * c.ratio)
                    }
                    ,
                    a.onUpdate = function() {
                        Lm.cache++,
                        t.tween && a_()
                    }
                    ,
                    a.onComplete = function() {
                        t.tween = 0,
                        u && u.call(c)
                    }
                    ,
                    c = t.tween = Qm.to(e, a)
                };
                return e[r] = n,
                n.wheelHandler = function() {
                    return i.tween && i.tween.kill() && (i.tween = 0)
                }
                ,
                Rv(e, "wheel", n.wheelHandler),
                y_.isTouch && Rv(e, "touchmove", n.wheelHandler),
                i
            }, y_ = function() {
                function e(t, n) {
                    eg || e.register(Qm) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
                    Tg(this),
                    this.init(t, n)
                }
                return e.prototype.init = function(t, n) {
                    if (this.progress = this.start = 0,
                    this.vars && this.kill(!0, !0),
                    Hg) {
                        var r, i, a, s, o, l, c, u, d, h, p, f, m, g, v, _, y, x, b, E, S, w, M, T, A, C, P, R, L, O, D, I, N, U, k, F, z, B, H, G, V, W, j = t = wv(nv(t) || iv(t) || t.nodeType ? {
                            trigger: t
                        } : t, Iv), X = j.onUpdate, q = j.toggleClass, Y = j.id, $ = j.onToggle, K = j.onRefresh, Z = j.scrub, J = j.trigger, Q = j.pin, ee = j.pinSpacing, te = j.invalidateOnRefresh, ne = j.anticipatePin, re = j.onScrubComplete, ie = j.onSnapComplete, ae = j.once, se = j.snap, oe = j.pinReparent, le = j.pinSpacer, ce = j.containerAnimation, ue = j.fastScrollEnd, de = j.preventOverlaps, he = t.horizontal || t.containerAnimation && !1 !== t.horizontal ? Vm : Wm, pe = !Z && 0 !== Z, fe = jm(t.scroller || tg), me = Qm.core.getCache(fe), ge = Zg(fe), ve = "fixed" === ("pinType"in t ? t.pinType : Nm(fe, "pinType") || ge && "fixed"), _e = [t.onEnter, t.onLeave, t.onEnterBack, t.onLeaveBack], ye = pe && t.toggleActions.split(" "), xe = "markers"in t ? t.markers : Iv.markers, be = ge ? 0 : parseFloat(Sv(fe)["border" + he.p2 + xv]) || 0, Ee = this, Se = t.onRefreshInit && function() {
                            return t.onRefreshInit(Ee)
                        }
                        , we = function(e, t, n) {
                            var r = n.d
                              , i = n.d2
                              , a = n.a;
                            return (a = Nm(e, "getBoundingClientRect")) ? function() {
                                return a()[r]
                            }
                            : function() {
                                return (t ? Jg(i) : e["client" + i]) || 0
                            }
                        }(fe, ge, he), Me = function(e, t) {
                            return !t || ~Om.indexOf(e) ? Qg(e) : function() {
                                return h_
                            }
                        }(fe, ge), Te = 0, Ae = 0, Ce = 0, Pe = Xm(fe, he);
                        if (Ee._startClamp = Ee._endClamp = !1,
                        Ee._dir = he,
                        ne *= 45,
                        Ee.scroller = fe,
                        Ee.scroll = ce ? ce.time.bind(ce) : Pe,
                        s = Pe(),
                        Ee.vars = t,
                        n = n || t.animation,
                        "refreshPriority"in t && (_g = 1,
                        -9999 === t.refreshPriority && (Ug = Ee)),
                        me.tweenScroll = me.tweenScroll || {
                            top: __(fe, Wm),
                            left: __(fe, Vm)
                        },
                        Ee.tweenTo = r = me.tweenScroll[he.p],
                        Ee.scrubDuration = function(e) {
                            (N = iv(e) && e) ? I ? I.duration(e) : I = Qm.to(n, {
                                ease: "expo",
                                totalProgress: "+=0",
                                inherit: !1,
                                duration: N,
                                paused: !0,
                                onComplete: function() {
                                    return re && re(Ee)
                                }
                            }) : (I && I.progress(1).kill(),
                            I = 0)
                        }
                        ,
                        n && (n.vars.lazy = !1,
                        n._initted && !Ee.isReverted || !1 !== n.vars.immediateRender && !1 !== t.immediateRender && n.duration() && n.render(0, !0, !0),
                        Ee.animation = n.pause(),
                        n.scrollTrigger = Ee,
                        Ee.scrubDuration(Z),
                        O = 0,
                        Y || (Y = n.vars.id)),
                        se && (av(se) && !se.push || (se = {
                            snapTo: se
                        }),
                        "scrollBehavior"in ig.style && Qm.set(ge ? [ig, rg] : fe, {
                            scrollBehavior: "auto"
                        }),
                        Lm.forEach((function(e) {
                            return rv(e) && e.target === (ge ? ng.scrollingElement || rg : fe) && (e.smooth = !1)
                        }
                        )),
                        a = rv(se.snapTo) ? se.snapTo : "labels" === se.snapTo ? function(e) {
                            return function(t) {
                                return Qm.utils.snap(Av(e), t)
                            }
                        }(n) : "labelsDirectional" === se.snapTo ? (G = n,
                        function(e, t) {
                            return Cv(Av(G))(e, t.direction)
                        }
                        ) : !1 !== se.directional ? function(e, t) {
                            return Cv(se.snapTo)(e, Fg() - Ae < 500 ? 0 : t.direction)
                        }
                        : Qm.utils.snap(se.snapTo),
                        U = se.duration || {
                            min: .1,
                            max: 2
                        },
                        U = av(U) ? lg(U.min, U.max) : lg(U, U),
                        k = Qm.delayedCall(se.delay || N / 2 || .1, (function() {
                            var e = Pe()
                              , t = Fg() - Ae < 500
                              , i = r.tween;
                            if (!(t || Math.abs(Ee.getVelocity()) < 10) || i || hg || Te === e)
                                Ee.isActive && Te !== e && k.restart(!0);
                            else {
                                var s, o, u = (e - l) / g, d = n && !pe ? n.totalProgress() : u, h = t ? 0 : (d - D) / (Fg() - cg) * 1e3 || 0, p = Qm.utils.clamp(-u, 1 - u, lv(h / 2) * h / .185), f = u + (!1 === se.inertia ? 0 : p), m = se, v = m.onStart, _ = m.onInterrupt, y = m.onComplete;
                                if (s = a(f, Ee),
                                iv(s) || (s = f),
                                o = Math.round(l + s * g),
                                e <= c && e >= l && o !== e) {
                                    if (i && !i._initted && i.data <= lv(o - e))
                                        return;
                                    !1 === se.inertia && (p = s - u),
                                    r(o, {
                                        duration: U(lv(.185 * Math.max(lv(f - d), lv(s - d)) / h / .05 || 0)),
                                        ease: se.ease || "power3",
                                        data: lv(o - e),
                                        onInterrupt: function() {
                                            return k.restart(!0) && _ && _(Ee)
                                        },
                                        onComplete: function() {
                                            Ee.update(),
                                            Te = Pe(),
                                            n && (I ? I.resetTo("totalProgress", s, n._tTime / n._tDur) : n.progress(s)),
                                            O = D = n && !pe ? n.totalProgress() : Ee.progress,
                                            ie && ie(Ee),
                                            y && y(Ee)
                                        }
                                    }, e, p * g, o - e - p * g),
                                    v && v(Ee, r.tween)
                                }
                            }
                        }
                        )).pause()),
                        Y && (Bv[Y] = Ee),
                        (H = (J = Ee.trigger = jm(J || !0 !== Q && Q)) && J._gsap && J._gsap.stRevert) && (H = H(Ee)),
                        Q = !0 === Q ? J : jm(Q),
                        nv(q) && (q = {
                            targets: J,
                            className: q
                        }),
                        Q && (!1 === ee || ee === yv || (ee = !(!ee && Q.parentNode && Q.parentNode.style && "flex" === Sv(Q.parentNode).display) && _v),
                        Ee.pin = Q,
                        (i = Qm.core.getCache(Q)).spacer ? v = i.pinState : (le && ((le = jm(le)) && !le.nodeType && (le = le.current || le.nativeElement),
                        i.spacerIsNative = !!le,
                        le && (i.spacerState = d_(le))),
                        i.spacer = x = le || ng.createElement("div"),
                        x.classList.add("pin-spacer"),
                        Y && x.classList.add("pin-spacer-" + Y),
                        i.pinState = v = d_(Q)),
                        !1 !== t.force3D && Qm.set(Q, {
                            force3D: !0
                        }),
                        Ee.spacer = x = i.spacer,
                        L = Sv(Q),
                        T = L[ee + he.os2],
                        E = Qm.getProperty(Q),
                        S = Qm.quickSetter(Q, he.a, Ev),
                        l_(Q, x, L),
                        y = d_(Q)),
                        xe) {
                            f = av(xe) ? wv(xe, Dv) : Dv,
                            h = kv("scroller-start", Y, fe, he, f, 0),
                            p = kv("scroller-end", Y, fe, he, f, 0, h),
                            b = h["offset" + he.op.d2];
                            var Re = jm(Nm(fe, "content") || fe);
                            u = this.markerStart = kv("start", Y, Re, he, f, b, 0, ce),
                            d = this.markerEnd = kv("end", Y, Re, he, f, b, 0, ce),
                            ce && (B = Qm.quickSetter([u, d], he.a, Ev)),
                            ve || Om.length && !0 === Nm(fe, "fixedMarkers") || (W = Sv(V = ge ? ig : fe).position,
                            V.style.position = "absolute" === W || "fixed" === W ? W : "relative",
                            Qm.set([h, p], {
                                force3D: !0
                            }),
                            C = Qm.quickSetter(h, he.a, Ev),
                            R = Qm.quickSetter(p, he.a, Ev))
                        }
                        if (ce) {
                            var Le = ce.vars.onUpdate
                              , Oe = ce.vars.onUpdateParams;
                            ce.eventCallback("onUpdate", (function() {
                                Ee.update(0, 0, 1),
                                Le && Le.apply(ce, Oe || [])
                            }
                            ))
                        }
                        if (Ee.previous = function() {
                            return zv[zv.indexOf(Ee) - 1]
                        }
                        ,
                        Ee.next = function() {
                            return zv[zv.indexOf(Ee) + 1]
                        }
                        ,
                        Ee.revert = function(e, t) {
                            if (!t)
                                return Ee.kill(!0);
                            var r = !1 !== e || !Ee.enabled
                              , i = dg;
                            r !== Ee.isReverted && (r && (F = Math.max(Pe(), Ee.scroll.rec || 0),
                            Ce = Ee.progress,
                            z = n && n.progress()),
                            u && [u, d, h, p].forEach((function(e) {
                                return e.style.display = r ? "none" : "block"
                            }
                            )),
                            r && (dg = Ee,
                            Ee.update(r)),
                            !Q || oe && Ee.isActive || (r ? function(e, t, n) {
                                u_(n);
                                var r = e._gsap;
                                if (r.spacerIsNative)
                                    u_(r.spacerState);
                                else if (e._gsap.swappedIn) {
                                    var i = t.parentNode;
                                    i && (i.insertBefore(e, t),
                                    i.removeChild(t))
                                }
                                e._gsap.swappedIn = !1
                            }(Q, x, v) : l_(Q, x, Sv(Q), A)),
                            r || Ee.update(r),
                            dg = i,
                            Ee.isReverted = r)
                        }
                        ,
                        Ee.refresh = function(i, a, f, b) {
                            if (!dg && Ee.enabled || a)
                                if (Q && i && Bg)
                                    Rv(e, "scrollEnd", qv);
                                else {
                                    !Ig && Se && Se(Ee),
                                    dg = Ee,
                                    r.tween && !f && (r.tween.kill(),
                                    r.tween = 0),
                                    I && I.pause(),
                                    te && n && n.revert({
                                        kill: !1
                                    }).invalidate(),
                                    Ee.isReverted || Ee.revert(!0, !0),
                                    Ee._subPinOffset = !1;
                                    var S, T, C, R, L, O, D, N, U, B, H, G, V, W = we(), j = Me(), X = ce ? ce.duration() : ev(fe, he), q = g <= .01, Y = 0, $ = b || 0, Z = av(f) ? f.end : t.end, ne = t.endTrigger || J, re = av(f) ? f.start : t.start || (0 !== t.start && J ? Q ? "0 0" : "0 100%" : 0), ie = Ee.pinnedContainer = t.pinnedContainer && jm(t.pinnedContainer, Ee), ae = J && Math.max(0, zv.indexOf(Ee)) || 0, se = ae;
                                    for (xe && av(f) && (G = Qm.getProperty(h, he.p),
                                    V = Qm.getProperty(p, he.p)); se--; )
                                        (O = zv[se]).end || O.refresh(0, 1) || (dg = Ee),
                                        !(D = O.pin) || D !== J && D !== Q && D !== ie || O.isReverted || (B || (B = []),
                                        B.unshift(O),
                                        O.revert(!0, !0)),
                                        O !== zv[se] && (ae--,
                                        se--);
                                    for (rv(re) && (re = re(Ee)),
                                    re = Gg(re, "start", Ee),
                                    l = p_(re, J, W, he, Pe(), u, h, Ee, j, be, ve, X, ce, Ee._startClamp && "_startClamp") || (Q ? -.001 : 0),
                                    rv(Z) && (Z = Z(Ee)),
                                    nv(Z) && !Z.indexOf("+=") && (~Z.indexOf(" ") ? Z = (nv(re) ? re.split(" ")[0] : "") + Z : (Y = Uv(Z.substr(2), W),
                                    Z = nv(re) ? re : (ce ? Qm.utils.mapRange(0, ce.duration(), ce.scrollTrigger.start, ce.scrollTrigger.end, l) : l) + Y,
                                    ne = J)),
                                    Z = Gg(Z, "end", Ee),
                                    c = Math.max(l, p_(Z || (ne ? "100% 0" : X), ne, W, he, Pe() + Y, d, p, Ee, j, be, ve, X, ce, Ee._endClamp && "_endClamp")) || -.001,
                                    Y = 0,
                                    se = ae; se--; )
                                        (D = (O = zv[se]).pin) && O.start - O._pinPush <= l && !ce && O.end > 0 && (S = O.end - (Ee._startClamp ? Math.max(0, O.start) : O.start),
                                        (D === J && O.start - O._pinPush < l || D === ie) && isNaN(re) && (Y += S * (1 - O.progress)),
                                        D === Q && ($ += S));
                                    if (l += Y,
                                    c += Y,
                                    Ee._startClamp && (Ee._startClamp += Y),
                                    Ee._endClamp && !Ig && (Ee._endClamp = c || -.001,
                                    c = Math.min(c, ev(fe, he))),
                                    g = c - l || (l -= .01) && .001,
                                    q && (Ce = Qm.utils.clamp(0, 1, Qm.utils.normalize(l, c, F))),
                                    Ee._pinPush = $,
                                    u && Y && ((S = {})[he.a] = "+=" + Y,
                                    ie && (S[he.p] = "-=" + Pe()),
                                    Qm.set([u, d], S)),
                                    !Q || Lg && Ee.end >= ev(fe, he)) {
                                        if (J && Pe() && !ce)
                                            for (T = J.parentNode; T && T !== ig; )
                                                T._pinOffset && (l -= T._pinOffset,
                                                c -= T._pinOffset),
                                                T = T.parentNode
                                    } else
                                        S = Sv(Q),
                                        R = he === Wm,
                                        C = Pe(),
                                        w = parseFloat(E(he.a)) + $,
                                        !X && c > 1 && (H = {
                                            style: H = (ge ? ng.scrollingElement || rg : fe).style,
                                            value: H["overflow" + he.a.toUpperCase()]
                                        },
                                        ge && "scroll" !== Sv(ig)["overflow" + he.a.toUpperCase()] && (H.style["overflow" + he.a.toUpperCase()] = "scroll")),
                                        l_(Q, x, S),
                                        y = d_(Q),
                                        T = Mv(Q, !0),
                                        N = ve && Xm(fe, R ? Vm : Wm)(),
                                        ee ? ((A = [ee + he.os2, g + $ + Ev]).t = x,
                                        (se = ee === _v ? Tv(Q, he) + g + $ : 0) && (A.push(he.d, se + Ev),
                                        "auto" !== x.style.flexBasis && (x.style.flexBasis = se + Ev)),
                                        u_(A),
                                        ie && zv.forEach((function(e) {
                                            e.pin === ie && !1 !== e.vars.pinSpacing && (e._subPinOffset = !0)
                                        }
                                        )),
                                        ve && Pe(F)) : (se = Tv(Q, he)) && "auto" !== x.style.flexBasis && (x.style.flexBasis = se + Ev),
                                        ve && ((L = {
                                            top: T.top + (R ? C - l : N) + Ev,
                                            left: T.left + (R ? N : C - l) + Ev,
                                            boxSizing: "border-box",
                                            position: "fixed"
                                        })[hv] = L["max" + xv] = Math.ceil(T.width) + Ev,
                                        L[pv] = L["max" + bv] = Math.ceil(T.height) + Ev,
                                        L[yv] = L[yv + gv] = L[yv + fv] = L[yv + vv] = L[yv + mv] = "0",
                                        L[_v] = S[_v],
                                        L[_v + gv] = S[_v + gv],
                                        L[_v + fv] = S[_v + fv],
                                        L[_v + vv] = S[_v + vv],
                                        L[_v + mv] = S[_v + mv],
                                        _ = function(e, t, n) {
                                            for (var r, i = [], a = e.length, s = n ? 8 : 0; s < a; s += 2)
                                                r = e[s],
                                                i.push(r, r in t ? t[r] : e[s + 1]);
                                            return i.t = e.t,
                                            i
                                        }(v, L, oe),
                                        Ig && Pe(0)),
                                        n ? (U = n._initted,
                                        yg(1),
                                        n.render(n.duration(), !0, !0),
                                        M = E(he.a) - w + g + $,
                                        P = Math.abs(g - M) > 1,
                                        ve && P && _.splice(_.length - 2, 2),
                                        n.render(0, !0, !0),
                                        U || n.invalidate(!0),
                                        n.parent || n.totalTime(n.totalTime()),
                                        yg(0)) : M = g,
                                        H && (H.value ? H.style["overflow" + he.a.toUpperCase()] = H.value : H.style.removeProperty("overflow-" + he.a));
                                    B && B.forEach((function(e) {
                                        return e.revert(!1, !0)
                                    }
                                    )),
                                    Ee.start = l,
                                    Ee.end = c,
                                    s = o = Ig ? F : Pe(),
                                    ce || Ig || (s < F && Pe(F),
                                    Ee.scroll.rec = 0),
                                    Ee.revert(!1, !0),
                                    Ae = Fg(),
                                    k && (Te = -1,
                                    k.restart(!0)),
                                    dg = 0,
                                    n && pe && (n._initted || z) && n.progress() !== z && n.progress(z || 0, !0).render(n.time(), !0, !0),
                                    (q || Ce !== Ee.progress || ce || te) && (n && !pe && n.totalProgress(ce && l < -.001 && !Ce ? Qm.utils.normalize(l, c, 0) : Ce, !0),
                                    Ee.progress = q || (s - l) / g === Ce ? 0 : Ce),
                                    Q && ee && (x._pinOffset = Math.round(Ee.progress * M)),
                                    I && I.invalidate(),
                                    isNaN(G) || (G -= Qm.getProperty(h, he.p),
                                    V -= Qm.getProperty(p, he.p),
                                    v_(h, he, G),
                                    v_(u, he, G - (b || 0)),
                                    v_(p, he, V),
                                    v_(d, he, V - (b || 0))),
                                    q && !Ig && Ee.update(),
                                    !K || Ig || m || (m = !0,
                                    K(Ee),
                                    m = !1)
                                }
                        }
                        ,
                        Ee.getVelocity = function() {
                            return (Pe() - o) / (Fg() - cg) * 1e3 || 0
                        }
                        ,
                        Ee.endAnimation = function() {
                            sv(Ee.callbackAnimation),
                            n && (I ? I.progress(1) : n.paused() ? pe || sv(n, Ee.direction < 0, 1) : sv(n, n.reversed()))
                        }
                        ,
                        Ee.labelToScroll = function(e) {
                            return n && n.labels && (l || Ee.refresh() || l) + n.labels[e] / n.duration() * g || 0
                        }
                        ,
                        Ee.getTrailing = function(e) {
                            var t = zv.indexOf(Ee)
                              , n = Ee.direction > 0 ? zv.slice(0, t).reverse() : zv.slice(t + 1);
                            return (nv(e) ? n.filter((function(t) {
                                return t.vars.preventOverlaps === e
                            }
                            )) : n).filter((function(e) {
                                return Ee.direction > 0 ? e.end <= l : e.start >= c
                            }
                            ))
                        }
                        ,
                        Ee.update = function(e, t, i) {
                            if (!ce || i || e) {
                                var a, u, d, p, f, m, v, b = !0 === Ig ? F : Ee.scroll(), E = e ? 0 : (b - l) / g, A = E < 0 ? 0 : E > 1 ? 1 : E || 0, L = Ee.progress;
                                if (t && (o = s,
                                s = ce ? Pe() : b,
                                se && (D = O,
                                O = n && !pe ? n.totalProgress() : A)),
                                ne && Q && !dg && !kg && Bg && (!A && l < b + (b - o) / (Fg() - cg) * ne ? A = 1e-4 : 1 === A && c > b + (b - o) / (Fg() - cg) * ne && (A = .9999)),
                                A !== L && Ee.enabled) {
                                    if (p = (f = (a = Ee.isActive = !!A && A < 1) !== (!!L && L < 1)) || !!A != !!L,
                                    Ee.direction = A > L ? 1 : -1,
                                    Ee.progress = A,
                                    p && !dg && (u = A && !L ? 0 : 1 === A ? 1 : 1 === L ? 2 : 3,
                                    pe && (d = !f && "none" !== ye[u + 1] && ye[u + 1] || ye[u],
                                    v = n && ("complete" === d || "reset" === d || d in n))),
                                    de && (f || v) && (v || Z || !n) && (rv(de) ? de(Ee) : Ee.getTrailing(de).forEach((function(e) {
                                        return e.endAnimation()
                                    }
                                    ))),
                                    pe || (!I || dg || kg ? n && n.totalProgress(A, !(!dg || !Ae && !e)) : (I._dp._time - I._start !== I._time && I.render(I._dp._time - I._start),
                                    I.resetTo ? I.resetTo("totalProgress", A, n._tTime / n._tDur) : (I.vars.totalProgress = A,
                                    I.invalidate().restart()))),
                                    Q)
                                        if (e && ee && (x.style[ee + he.os2] = T),
                                        ve) {
                                            if (p) {
                                                if (m = !e && A > L && c + 1 > b && b + 1 >= ev(fe, he),
                                                oe)
                                                    if (e || !a && !m)
                                                        m_(Q, x);
                                                    else {
                                                        var N = Mv(Q, !0)
                                                          , U = b - l;
                                                        m_(Q, ig, N.top + (he === Wm ? U : 0) + Ev, N.left + (he === Wm ? 0 : U) + Ev)
                                                    }
                                                u_(a || m ? _ : y),
                                                P && A < 1 && a || S(w + (1 !== A || m ? 0 : M))
                                            }
                                        } else
                                            S(Yg(w + M * A));
                                    se && !r.tween && !dg && !kg && k.restart(!0),
                                    q && (f || ae && A && (A < 1 || !Og)) && og(q.targets).forEach((function(e) {
                                        return e.classList[a || ae ? "add" : "remove"](q.className)
                                    }
                                    )),
                                    X && !pe && !e && X(Ee),
                                    p && !dg ? (pe && (v && ("complete" === d ? n.pause().totalProgress(1) : "reset" === d ? n.restart(!0).pause() : "restart" === d ? n.restart(!0) : n[d]()),
                                    X && X(Ee)),
                                    !f && Og || ($ && f && ov(Ee, $),
                                    _e[u] && ov(Ee, _e[u]),
                                    ae && (1 === A ? Ee.kill(!1, 1) : _e[u] = 0),
                                    f || _e[u = 1 === A ? 1 : 3] && ov(Ee, _e[u])),
                                    ue && !a && Math.abs(Ee.getVelocity()) > (iv(ue) ? ue : 2500) && (sv(Ee.callbackAnimation),
                                    I ? I.progress(1) : sv(n, "reverse" === d ? 1 : !A, 1))) : pe && X && !dg && X(Ee)
                                }
                                if (R) {
                                    var z = ce ? b / ce.duration() * (ce._caScrollDist || 0) : b;
                                    C(z + (h._isFlipped ? 1 : 0)),
                                    R(z)
                                }
                                B && B(-b / ce.duration() * (ce._caScrollDist || 0))
                            }
                        }
                        ,
                        Ee.enable = function(t, n) {
                            Ee.enabled || (Ee.enabled = !0,
                            Rv(fe, "resize", Wv),
                            ge || Rv(fe, "scroll", Gv),
                            Se && Rv(e, "refreshInit", Se),
                            !1 !== t && (Ee.progress = Ce = 0,
                            s = o = Te = Pe()),
                            !1 !== n && Ee.refresh())
                        }
                        ,
                        Ee.getTween = function(e) {
                            return e && r ? r.tween : I
                        }
                        ,
                        Ee.setPositions = function(e, t, n, r) {
                            if (ce) {
                                var i = ce.scrollTrigger
                                  , a = ce.duration()
                                  , s = i.end - i.start;
                                e = i.start + s * e / a,
                                t = i.start + s * t / a
                            }
                            Ee.refresh(!1, !1, {
                                start: Vg(e, n && !!Ee._startClamp),
                                end: Vg(t, n && !!Ee._endClamp)
                            }, r),
                            Ee.update()
                        }
                        ,
                        Ee.adjustPinSpacing = function(e) {
                            if (A && e) {
                                var t = A.indexOf(he.d) + 1;
                                A[t] = parseFloat(A[t]) + e + Ev,
                                A[1] = parseFloat(A[1]) + e + Ev,
                                u_(A)
                            }
                        }
                        ,
                        Ee.disable = function(t, n) {
                            if (Ee.enabled && (!1 !== t && Ee.revert(!0, !0),
                            Ee.enabled = Ee.isActive = !1,
                            n || I && I.pause(),
                            F = 0,
                            i && (i.uncache = 1),
                            Se && Lv(e, "refreshInit", Se),
                            k && (k.pause(),
                            r.tween && r.tween.kill() && (r.tween = 0)),
                            !ge)) {
                                for (var a = zv.length; a--; )
                                    if (zv[a].scroller === fe && zv[a] !== Ee)
                                        return;
                                Lv(fe, "resize", Wv),
                                ge || Lv(fe, "scroll", Gv)
                            }
                        }
                        ,
                        Ee.kill = function(e, r) {
                            Ee.disable(e, r),
                            I && !r && I.kill(),
                            Y && delete Bv[Y];
                            var a = zv.indexOf(Ee);
                            a >= 0 && zv.splice(a, 1),
                            a === fg && i_ > 0 && fg--,
                            a = 0,
                            zv.forEach((function(e) {
                                return e.scroller === Ee.scroller && (a = 1)
                            }
                            )),
                            a || Ig || (Ee.scroll.rec = 0),
                            n && (n.scrollTrigger = null,
                            e && n.revert({
                                kill: !1
                            }),
                            r || n.kill()),
                            u && [u, d, h, p].forEach((function(e) {
                                return e.parentNode && e.parentNode.removeChild(e)
                            }
                            )),
                            Ug === Ee && (Ug = 0),
                            Q && (i && (i.uncache = 1),
                            a = 0,
                            zv.forEach((function(e) {
                                return e.pin === Q && a++
                            }
                            )),
                            a || (i.spacer = 0)),
                            t.onKill && t.onKill(Ee)
                        }
                        ,
                        zv.push(Ee),
                        Ee.enable(!1, !1),
                        H && H(Ee),
                        n && n.add && !g) {
                            var De = Ee.update;
                            Ee.update = function() {
                                Ee.update = De,
                                l || c || Ee.refresh()
                            }
                            ,
                            Qm.delayedCall(.01, Ee.update),
                            g = .01,
                            l = c = 0
                        } else
                            Ee.refresh();
                        Q && function() {
                            if (Ng !== Qv) {
                                var e = Ng = Qv;
                                requestAnimationFrame((function() {
                                    return e === Qv && n_(!0)
                                }
                                ))
                            }
                        }()
                    } else
                        this.update = this.refresh = this.kill = qg
                }
                ,
                e.register = function(t) {
                    return eg || (Qm = t || Kg(),
                    $g() && window.document && e.enable(),
                    eg = Hg),
                    eg
                }
                ,
                e.defaults = function(e) {
                    if (e)
                        for (var t in e)
                            Iv[t] = e[t];
                    return Iv
                }
                ,
                e.disable = function(e, t) {
                    Hg = 0,
                    zv.forEach((function(n) {
                        return n[t ? "kill" : "disable"](e)
                    }
                    )),
                    Lv(tg, "wheel", Gv),
                    Lv(ng, "scroll", Gv),
                    clearInterval(ug),
                    Lv(ng, "touchcancel", qg),
                    Lv(ig, "touchstart", qg),
                    Pv(Lv, ng, "pointerdown,touchstart,mousedown", jg),
                    Pv(Lv, ng, "pointerup,touchend,mouseup", Xg),
                    sg.kill(),
                    tv(Lv);
                    for (var n = 0; n < Lm.length; n += 3)
                        Ov(Lv, Lm[n], Lm[n + 1]),
                        Ov(Lv, Lm[n], Lm[n + 2])
                }
                ,
                e.enable = function() {
                    if (tg = window,
                    ng = document,
                    rg = ng.documentElement,
                    ig = ng.body,
                    Qm && (og = Qm.utils.toArray,
                    lg = Qm.utils.clamp,
                    Tg = Qm.core.context || qg,
                    yg = Qm.core.suppressOverwrites || qg,
                    Ag = tg.history.scrollRestoration || "auto",
                    r_ = tg.pageYOffset,
                    Qm.core.globals("ScrollTrigger", e),
                    ig)) {
                        Hg = 1,
                        (Cg = document.createElement("div")).style.height = "100vh",
                        Cg.style.position = "absolute",
                        e_(),
                        Wg(),
                        Jm.register(Qm),
                        e.isTouch = Jm.isTouch,
                        Mg = Jm.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent),
                        Eg = 1 === Jm.isTouch,
                        Rv(tg, "wheel", Gv),
                        ag = [tg, ng, rg, ig],
                        Qm.matchMedia ? (e.matchMedia = function(e) {
                            var t, n = Qm.matchMedia();
                            for (t in e)
                                n.add(t, e[t]);
                            return n
                        }
                        ,
                        Qm.addEventListener("matchMediaInit", (function() {
                            return Zv()
                        }
                        )),
                        Qm.addEventListener("matchMediaRevert", (function() {
                            return Kv()
                        }
                        )),
                        Qm.addEventListener("matchMedia", (function() {
                            n_(0, 1),
                            Yv("matchMedia")
                        }
                        )),
                        Qm.matchMedia("(orientation: portrait)", (function() {
                            return Vv(),
                            Vv
                        }
                        ))) : console.warn("Requires GSAP 3.11.0 or later"),
                        Vv(),
                        Rv(ng, "scroll", Gv);
                        var t, n, r = ig.style, i = r.borderTopStyle, a = Qm.core.Animation.prototype;
                        for (a.revert || Object.defineProperty(a, "revert", {
                            value: function() {
                                return this.time(-.01, !0)
                            }
                        }),
                        r.borderTopStyle = "solid",
                        t = Mv(ig),
                        Wm.m = Math.round(t.top + Wm.sc()) || 0,
                        Vm.m = Math.round(t.left + Vm.sc()) || 0,
                        i ? r.borderTopStyle = i : r.removeProperty("border-top-style"),
                        ug = setInterval(Hv, 250),
                        Qm.delayedCall(.5, (function() {
                            return kg = 0
                        }
                        )),
                        Rv(ng, "touchcancel", qg),
                        Rv(ig, "touchstart", qg),
                        Pv(Rv, ng, "pointerdown,touchstart,mousedown", jg),
                        Pv(Rv, ng, "pointerup,touchend,mouseup", Xg),
                        pg = Qm.utils.checkPrefix("transform"),
                        o_.push(pg),
                        eg = Fg(),
                        sg = Qm.delayedCall(.2, n_).pause(),
                        vg = [ng, "visibilitychange", function() {
                            var e = tg.innerWidth
                              , t = tg.innerHeight;
                            ng.hidden ? (mg = e,
                            gg = t) : mg === e && gg === t || Wv()
                        }
                        , ng, "DOMContentLoaded", n_, tg, "load", n_, tg, "resize", Wv],
                        tv(Rv),
                        zv.forEach((function(e) {
                            return e.enable(0, 1)
                        }
                        )),
                        n = 0; n < Lm.length; n += 3)
                            Ov(Lv, Lm[n], Lm[n + 1]),
                            Ov(Lv, Lm[n], Lm[n + 2])
                    }
                }
                ,
                e.config = function(t) {
                    "limitCallbacks"in t && (Og = !!t.limitCallbacks);
                    var n = t.syncInterval;
                    n && clearInterval(ug) || (ug = n) && setInterval(Hv, n),
                    "ignoreMobileResize"in t && (Eg = 1 === e.isTouch && t.ignoreMobileResize),
                    "autoRefreshEvents"in t && (tv(Lv) || tv(Rv, t.autoRefreshEvents || "none"),
                    xg = -1 === (t.autoRefreshEvents + "").indexOf("resize"))
                }
                ,
                e.scrollerProxy = function(e, t) {
                    var n = jm(e)
                      , r = Lm.indexOf(n)
                      , i = Zg(n);
                    ~r && Lm.splice(r, i ? 6 : 2),
                    t && (i ? Om.unshift(tg, t, ig, t, rg, t) : Om.unshift(n, t))
                }
                ,
                e.clearMatchMedia = function(e) {
                    zv.forEach((function(t) {
                        return t._ctx && t._ctx.query === e && t._ctx.kill(!0, !0)
                    }
                    ))
                }
                ,
                e.isInViewport = function(e, t, n) {
                    var r = (nv(e) ? jm(e) : e).getBoundingClientRect()
                      , i = r[n ? hv : pv] * t || 0;
                    return n ? r.right - i > 0 && r.left + i < tg.innerWidth : r.bottom - i > 0 && r.top + i < tg.innerHeight
                }
                ,
                e.positionInViewport = function(e, t, n) {
                    nv(e) && (e = jm(e));
                    var r = e.getBoundingClientRect()
                      , i = r[n ? hv : pv]
                      , a = null == t ? i / 2 : t in Nv ? Nv[t] * i : ~t.indexOf("%") ? parseFloat(t) * i / 100 : parseFloat(t) || 0;
                    return n ? (r.left + a) / tg.innerWidth : (r.top + a) / tg.innerHeight
                }
                ,
                e.killAll = function(e) {
                    if (zv.slice(0).forEach((function(e) {
                        return "ScrollSmoother" !== e.vars.id && e.kill()
                    }
                    )),
                    !0 !== e) {
                        var t = jv.killAll || [];
                        jv = {},
                        t.forEach((function(e) {
                            return e()
                        }
                        ))
                    }
                }
                ,
                e
            }();
            y_.version = "3.12.5",
            y_.saveStyles = function(e) {
                return e ? og(e).forEach((function(e) {
                    if (e && e.style) {
                        var t = $v.indexOf(e);
                        t >= 0 && $v.splice(t, 5),
                        $v.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), Qm.core.getCache(e), Tg())
                    }
                }
                )) : $v
            }
            ,
            y_.revert = function(e, t) {
                return Zv(!e, t)
            }
            ,
            y_.create = function(e, t) {
                return new y_(e,t)
            }
            ,
            y_.refresh = function(e) {
                return e ? Wv() : (eg || y_.register()) && n_(!0)
            }
            ,
            y_.update = function(e) {
                return ++Lm.cache && a_(!0 === e ? 2 : 0)
            }
            ,
            y_.clearScrollMemory = Jv,
            y_.maxScroll = function(e, t) {
                return ev(e, t ? Vm : Wm)
            }
            ,
            y_.getScrollFunc = function(e, t) {
                return Xm(jm(e), t ? Vm : Wm)
            }
            ,
            y_.getById = function(e) {
                return Bv[e]
            }
            ,
            y_.getAll = function() {
                return zv.filter((function(e) {
                    return "ScrollSmoother" !== e.vars.id
                }
                ))
            }
            ,
            y_.isScrolling = function() {
                return !!Bg
            }
            ,
            y_.snapDirectional = Cv,
            y_.addEventListener = function(e, t) {
                var n = jv[e] || (jv[e] = []);
                ~n.indexOf(t) || n.push(t)
            }
            ,
            y_.removeEventListener = function(e, t) {
                var n = jv[e]
                  , r = n && n.indexOf(t);
                r >= 0 && n.splice(r, 1)
            }
            ,
            y_.batch = function(e, t) {
                var n, r = [], i = {}, a = t.interval || .016, s = t.batchMax || 1e9, o = function(e, t) {
                    var n = []
                      , r = []
                      , i = Qm.delayedCall(a, (function() {
                        t(n, r),
                        n = [],
                        r = []
                    }
                    )).pause();
                    return function(e) {
                        n.length || i.restart(!0),
                        n.push(e.trigger),
                        r.push(e),
                        s <= n.length && i.progress(1)
                    }
                };
                for (n in t)
                    i[n] = "on" === n.substr(0, 2) && rv(t[n]) && "onRefreshInit" !== n ? o(0, t[n]) : t[n];
                return rv(s) && (s = s(),
                Rv(y_, "refresh", (function() {
                    return s = t.batchMax()
                }
                ))),
                og(e).forEach((function(e) {
                    var t = {};
                    for (n in i)
                        t[n] = i[n];
                    t.trigger = e,
                    r.push(y_.create(t))
                }
                )),
                r
            }
            ;
            var x_, b_ = function(e, t, n, r) {
                return t > r ? e(r) : t < 0 && e(0),
                n > r ? (r - t) / (n - t) : n < 0 ? t / (t - n) : 1
            }, E_ = function e(t, n) {
                !0 === n ? t.style.removeProperty("touch-action") : t.style.touchAction = !0 === n ? "auto" : n ? "pan-" + n + (Jm.isTouch ? " pinch-zoom" : "") : "none",
                t === rg && e(ig, n)
            }, S_ = {
                auto: 1,
                scroll: 1
            }, w_ = function(e) {
                var t, n = e.event, r = e.target, i = e.axis, a = (n.changedTouches ? n.changedTouches[0] : n).target, s = a._gsap || Qm.core.getCache(a), o = Fg();
                if (!s._isScrollT || o - s._isScrollT > 2e3) {
                    for (; a && a !== ig && (a.scrollHeight <= a.clientHeight && a.scrollWidth <= a.clientWidth || !S_[(t = Sv(a)).overflowY] && !S_[t.overflowX]); )
                        a = a.parentNode;
                    s._isScroll = a && a !== r && !Zg(a) && (S_[(t = Sv(a)).overflowY] || S_[t.overflowX]),
                    s._isScrollT = o
                }
                (s._isScroll || "x" === i) && (n.stopPropagation(),
                n._gsapAllow = !0)
            }, M_ = function(e, t, n, r) {
                return Jm.create({
                    target: e,
                    capture: !0,
                    debounce: !1,
                    lockAxis: !0,
                    type: t,
                    onWheel: r = r && w_,
                    onPress: r,
                    onDrag: r,
                    onScroll: r,
                    onEnable: function() {
                        return n && Rv(ng, Jm.eventTypes[0], A_, !1, !0)
                    },
                    onDisable: function() {
                        return Lv(ng, Jm.eventTypes[0], A_, !0)
                    }
                })
            }, T_ = /(input|label|select|textarea)/i, A_ = function(e) {
                var t = T_.test(e.target.tagName);
                (t || x_) && (e._gsapAllow = !0,
                x_ = t)
            }, C_ = function(e) {
                av(e) || (e = {}),
                e.preventDefault = e.isNormalizer = e.allowClicks = !0,
                e.type || (e.type = "wheel,touch"),
                e.debounce = !!e.debounce,
                e.id = e.id || "normalizer";
                var t, n, r, i, a, s, o, l, c = e, u = c.normalizeScrollX, d = c.momentum, h = c.allowNestedScroll, p = c.onRelease, f = jm(e.target) || rg, m = Qm.core.globals().ScrollSmoother, g = m && m.get(), v = Mg && (e.content && jm(e.content) || g && !1 !== e.content && !g.smooth() && g.content()), _ = Xm(f, Wm), y = Xm(f, Vm), x = 1, b = (Jm.isTouch && tg.visualViewport ? tg.visualViewport.scale * tg.visualViewport.width : tg.outerWidth) / tg.innerWidth, E = 0, S = rv(d) ? function() {
                    return d(t)
                }
                : function() {
                    return d || 2.8
                }
                , w = M_(f, e.type, !0, h), M = function() {
                    return i = !1
                }, T = qg, A = qg, C = function() {
                    n = ev(f, Wm),
                    A = lg(Mg ? 1 : 0, n),
                    u && (T = lg(0, ev(f, Vm))),
                    r = Qv
                }, P = function() {
                    v._gsap.y = Yg(parseFloat(v._gsap.y) + _.offset) + "px",
                    v.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(v._gsap.y) + ", 0, 1)",
                    _.offset = _.cacheID = 0
                }, R = function() {
                    C(),
                    a.isActive() && a.vars.scrollY > n && (_() > n ? a.progress(1) && _(n) : a.resetTo("scrollY", n))
                };
                return v && Qm.set(v, {
                    y: "+=0"
                }),
                e.ignoreCheck = function(e) {
                    return Mg && "touchmove" === e.type && function() {
                        if (i) {
                            requestAnimationFrame(M);
                            var e = Yg(t.deltaY / 2)
                              , n = A(_.v - e);
                            if (v && n !== _.v + _.offset) {
                                _.offset = n - _.v;
                                var r = Yg((parseFloat(v && v._gsap.y) || 0) - _.offset);
                                v.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + r + ", 0, 1)",
                                v._gsap.y = r + "px",
                                _.cacheID = Lm.cache,
                                a_()
                            }
                            return !0
                        }
                        _.offset && P(),
                        i = !0
                    }() || x > 1.05 && "touchstart" !== e.type || t.isGesturing || e.touches && e.touches.length > 1
                }
                ,
                e.onPress = function() {
                    i = !1;
                    var e = x;
                    x = Yg((tg.visualViewport && tg.visualViewport.scale || 1) / b),
                    a.pause(),
                    e !== x && E_(f, x > 1.01 || !u && "x"),
                    s = y(),
                    o = _(),
                    C(),
                    r = Qv
                }
                ,
                e.onRelease = e.onGestureStart = function(e, t) {
                    if (_.offset && P(),
                    t) {
                        Lm.cache++;
                        var r, i, s = S();
                        u && (i = (r = y()) + .05 * s * -e.velocityX / .227,
                        s *= b_(y, r, i, ev(f, Vm)),
                        a.vars.scrollX = T(i)),
                        i = (r = _()) + .05 * s * -e.velocityY / .227,
                        s *= b_(_, r, i, ev(f, Wm)),
                        a.vars.scrollY = A(i),
                        a.invalidate().duration(s).play(.01),
                        (Mg && a.vars.scrollY >= n || r >= n - 1) && Qm.to({}, {
                            onUpdate: R,
                            duration: s
                        })
                    } else
                        l.restart(!0);
                    p && p(e)
                }
                ,
                e.onWheel = function() {
                    a._ts && a.pause(),
                    Fg() - E > 1e3 && (r = 0,
                    E = Fg())
                }
                ,
                e.onChange = function(e, t, n, i, a) {
                    if (Qv !== r && C(),
                    t && u && y(T(i[2] === t ? s + (e.startX - e.x) : y() + t - i[1])),
                    n) {
                        _.offset && P();
                        var l = a[2] === n
                          , c = l ? o + e.startY - e.y : _() + n - a[1]
                          , d = A(c);
                        l && c !== d && (o += d - c),
                        _(d)
                    }
                    (n || t) && a_()
                }
                ,
                e.onEnable = function() {
                    E_(f, !u && "x"),
                    y_.addEventListener("refresh", R),
                    Rv(tg, "resize", R),
                    _.smooth && (_.target.style.scrollBehavior = "auto",
                    _.smooth = y.smooth = !1),
                    w.enable()
                }
                ,
                e.onDisable = function() {
                    E_(f, !0),
                    Lv(tg, "resize", R),
                    y_.removeEventListener("refresh", R),
                    w.kill()
                }
                ,
                e.lockAxis = !1 !== e.lockAxis,
                (t = new Jm(e)).iOS = Mg,
                Mg && !_() && _(1),
                Mg && Qm.ticker.add(qg),
                l = t._dc,
                a = Qm.to(t, {
                    ease: "power4",
                    paused: !0,
                    inherit: !1,
                    scrollX: u ? "+=0.1" : "+=0",
                    scrollY: "+=0.1",
                    modifiers: {
                        scrollY: g_(_, _(), (function() {
                            return a.pause()
                        }
                        ))
                    },
                    onUpdate: a_,
                    onComplete: l.vars.onComplete
                }),
                t
            };
            function P_(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1,
                    r.configurable = !0,
                    "value"in r && (r.writable = !0),
                    Object.defineProperty(e, r.key, r)
                }
            }
            y_.sort = function(e) {
                return zv.sort(e || function(e, t) {
                    return -1e6 * (e.vars.refreshPriority || 0) + e.start - (t.start + -1e6 * (t.vars.refreshPriority || 0))
                }
                )
            }
            ,
            y_.observe = function(e) {
                return new Jm(e)
            }
            ,
            y_.normalizeScroll = function(e) {
                if (void 0 === e)
                    return bg;
                if (!0 === e && bg)
                    return bg.enable();
                if (!1 === e)
                    return bg && bg.kill(),
                    void (bg = e);
                var t = e instanceof Jm ? e : C_(e);
                return bg && bg.target === t.target && bg.kill(),
                Zg(t.target) && (bg = t),
                t
            }
            ,
            y_.core = {
                _getVelocityProp: qm,
                _inputObserver: M_,
                _scrollers: Lm,
                _proxies: Om,
                bridge: {
                    ss: function() {
                        Bg || Yv("scrollStart"),
                        Bg = Fg()
                    },
                    ref: function() {
                        return dg
                    }
                }
            },
            Kg() && Qm.registerPlugin(y_);
            var R_, L_, O_, D_, I_, N_, U_, k_, F_, z_, B_, H_, G_, V_, W_, j_ = function() {
                return "undefined" != typeof window
            }, X_ = function() {
                return R_ || j_() && (R_ = window.gsap) && R_.registerPlugin && R_
            }, q_ = function(e) {
                return F_.maxScroll(e || O_)
            }, Y_ = function() {
                function e(t) {
                    var n = this;
                    L_ || e.register(R_) || console.warn("Please gsap.registerPlugin(ScrollSmoother)"),
                    t = this.vars = t || {},
                    z_ && z_.kill(),
                    z_ = this,
                    V_(this);
                    var r, i, a, s, o, l, c, u, d, h, p, f, m, g, v, _, y = t, x = y.smoothTouch, b = y.onUpdate, E = y.onStop, S = y.smooth, w = y.onFocusIn, M = y.normalizeScroll, T = y.wholePixels, A = this, C = t.effectsPrefix || "", P = F_.getScrollFunc(O_), R = 1 === F_.isTouch ? !0 === x ? .8 : parseFloat(x) || 0 : 0 === S || !1 === S ? 0 : parseFloat(S) || .8, L = R && +t.speed || 1, O = 0, D = 0, I = 1, N = H_(0), U = function() {
                        return N.update(-O)
                    }, k = {
                        y: 0
                    }, F = function() {
                        return r.style.overflow = "visible"
                    }, z = function(e) {
                        e.update();
                        var t = e.getTween();
                        t && (t.pause(),
                        t._time = t._dur,
                        t._tTime = t._tDur),
                        v = !1,
                        e.animation.progress(e.progress, !0)
                    }, B = function(t, n) {
                        (t !== O && !h || n) && (T && (t = Math.round(t)),
                        R && (r.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + t + ", 0, 1)",
                        r._gsap.y = t + "px"),
                        D = t - O,
                        O = t,
                        F_.isUpdating || e.isRefreshing || F_.update())
                    }, H = function(e) {
                        return arguments.length ? (e < 0 && (e = 0),
                        k.y = -e,
                        v = !0,
                        h ? O = -e : B(-e),
                        F_.isRefreshing ? s.update() : P(e / L),
                        this) : -O
                    }, G = "undefined" != typeof ResizeObserver && !1 !== t.autoResize && new ResizeObserver((function() {
                        if (!F_.isRefreshing) {
                            var e = q_(i) * L;
                            e < -O && H(e),
                            W_.restart(!0)
                        }
                    }
                    )), V = function(e) {
                        i.scrollTop = 0,
                        e.target.contains && e.target.contains(i) || w && !1 === w(n, e) || (F_.isInViewport(e.target) || e.target === _ || n.scrollTo(e.target, !1, "center center"),
                        _ = e.target)
                    }, W = function(e, t) {
                        if (e < t.start)
                            return e;
                        var n = isNaN(t.ratio) ? 1 : t.ratio
                          , r = t.end - t.start
                          , i = e - t.start
                          , a = t.offset || 0
                          , s = t.pins || []
                          , o = s.offset || 0
                          , l = t._startClamp && t.start <= 0 || t.pins && t.pins.offset ? 0 : t._endClamp && t.end === q_() ? 1 : .5;
                        return s.forEach((function(t) {
                            r -= t.distance,
                            t.nativeStart <= e && (i -= t.distance)
                        }
                        )),
                        o && (i *= (r - o / n) / r),
                        e + (i - a * l) / n - i
                    }, j = function e(t, n, r) {
                        r || (t.pins.length = t.pins.offset = 0);
                        var i, a, s, o, l, c, u, d, h = t.pins, p = t.markers;
                        for (u = 0; u < n.length; u++)
                            if (d = n[u],
                            t.trigger && d.trigger && t !== d && (d.trigger === t.trigger || d.pinnedContainer === t.trigger || t.trigger.contains(d.trigger)) && (l = d._startNative || d._startClamp || d.start,
                            c = d._endNative || d._endClamp || d.end,
                            s = W(l, t),
                            o = d.pin && c > 0 ? s + (c - l) : W(c, t),
                            d.setPositions(s, o, !0, (d._startClamp ? Math.max(0, s) : s) - l),
                            d.markerStart && p.push(R_.quickSetter([d.markerStart, d.markerEnd], "y", "px")),
                            d.pin && d.end > 0 && !r)) {
                                if (i = d.end - d.start,
                                a = t._startClamp && d.start < 0) {
                                    if (t.start > 0)
                                        return t.setPositions(0, t.end + (t._startNative - t.start), !0),
                                        void e(t, n);
                                    i += d.start,
                                    h.offset = -d.start
                                }
                                h.push({
                                    start: d.start,
                                    nativeStart: l,
                                    end: d.end,
                                    distance: i,
                                    trig: d
                                }),
                                t.setPositions(t.start, t.end + (a ? -d.start : i), !0)
                            }
                    }, X = function(e, t) {
                        o.forEach((function(n) {
                            return j(n, e, t)
                        }
                        ))
                    }, q = function() {
                        F(),
                        requestAnimationFrame(F),
                        o && (F_.getAll().forEach((function(e) {
                            e._startNative = e.start,
                            e._endNative = e.end
                        }
                        )),
                        o.forEach((function(e) {
                            var t = e._startClamp || e.start
                              , n = e.autoSpeed ? Math.min(q_(), e.end) : t + Math.abs((e.end - t) / e.ratio)
                              , r = n - e.end;
                            if ((t -= r / 2) > (n -= r / 2)) {
                                var i = t;
                                t = n,
                                n = i
                            }
                            e._startClamp && t < 0 ? (r = (n = e.ratio < 0 ? q_() : e.end / e.ratio) - e.end,
                            t = 0) : (e.ratio < 0 || e._endClamp && n >= q_()) && (r = ((n = q_()) - (t = e.ratio < 0 || e.ratio > 1 ? 0 : n - (n - e.start) / e.ratio)) * e.ratio - (e.end - e.start)),
                            e.offset = r || 1e-4,
                            e.pins.length = e.pins.offset = 0,
                            e.setPositions(t, n, !0)
                        }
                        )),
                        X(F_.sort())),
                        N.reset()
                    }, Y = function() {
                        return F_.addEventListener("refresh", q)
                    }, $ = function() {
                        return o && o.forEach((function(e) {
                            return e.vars.onRefresh(e)
                        }
                        ))
                    }, K = function() {
                        return o && o.forEach((function(e) {
                            return e.vars.onRefreshInit(e)
                        }
                        )),
                        $
                    }, Z = function(e, t, n, r) {
                        return function() {
                            var i = "function" == typeof t ? t(n, r) : t;
                            i || 0 === i || (i = r.getAttribute("data-" + C + e) || ("speed" === e ? 1 : 0)),
                            r.setAttribute("data-" + C + e, i);
                            var a = "clamp(" === (i + "").substr(0, 6);
                            return {
                                clamp: a,
                                value: a ? i.substr(6, i.length - 7) : i
                            }
                        }
                    }, J = function(e, t, n, r, a) {
                        a = ("function" == typeof a ? a(r, e) : a) || 0;
                        var s, l, c, u, d, h, p = Z("speed", t, r, e), f = Z("lag", n, r, e), m = R_.getProperty(e, "y"), g = e._gsap, v = [], _ = function() {
                            t = p(),
                            n = parseFloat(f().value),
                            s = parseFloat(t.value) || 1,
                            c = "auto" === t.value,
                            d = c || l && l._startClamp && l.start <= 0 || v.offset ? 0 : l && l._endClamp && l.end === q_() ? 1 : .5,
                            u && u.kill(),
                            u = n && R_.to(e, {
                                ease: B_,
                                overwrite: !1,
                                y: "+=0",
                                duration: n
                            }),
                            l && (l.ratio = s,
                            l.autoSpeed = c)
                        }, y = function() {
                            g.y = m + "px",
                            g.renderTransform(1),
                            _()
                        }, x = [], b = 0, E = function(t) {
                            if (c) {
                                y();
                                var n = function(e, t) {
                                    var n, r, i = e.parentNode || I_, a = e.getBoundingClientRect(), s = i.getBoundingClientRect(), o = s.top - a.top, l = s.bottom - a.bottom, c = (Math.abs(o) > Math.abs(l) ? o : l) / (1 - t), u = -c * t;
                                    return c > 0 && (r = .5 == (n = s.height / (O_.innerHeight + s.height)) ? 2 * s.height : 2 * Math.min(s.height, Math.abs(-c * n / (2 * n - 1))) * (t || 1),
                                    u += t ? -r * t : -r / 2,
                                    c += r),
                                    {
                                        change: c,
                                        offset: u
                                    }
                                }(e, k_(0, 1, -t.start / (t.end - t.start)));
                                b = n.change,
                                h = n.offset
                            } else
                                h = v.offset || 0,
                                b = (t.end - t.start - h) * (1 - s);
                            v.forEach((function(e) {
                                return b -= e.distance * (1 - s)
                            }
                            )),
                            t.offset = b || .001,
                            t.vars.onUpdate(t),
                            u && u.progress(1)
                        };
                        return _(),
                        (1 !== s || c || u) && (l = F_.create({
                            trigger: c ? e.parentNode : e,
                            start: function() {
                                return t.clamp ? "clamp(top bottom+=" + a + ")" : "top bottom+=" + a
                            },
                            end: function() {
                                return t.value < 0 ? "max" : t.clamp ? "clamp(bottom top-=" + a + ")" : "bottom top-=" + a
                            },
                            scroller: i,
                            scrub: !0,
                            refreshPriority: -999,
                            onRefreshInit: y,
                            onRefresh: E,
                            onKill: function(e) {
                                var t = o.indexOf(e);
                                t >= 0 && o.splice(t, 1),
                                y()
                            },
                            onUpdate: function(e) {
                                var t, n, r, i, a = m + b * (e.progress - d), s = v.length, o = 0;
                                if (e.offset) {
                                    if (s) {
                                        for (n = -O,
                                        r = e.end; s--; ) {
                                            if ((t = v[s]).trig.isActive || n >= t.start && n <= t.end)
                                                return void (u && (t.trig.progress += t.trig.direction < 0 ? .001 : -.001,
                                                t.trig.update(0, 0, 1),
                                                u.resetTo("y", parseFloat(g.y), -D, !0),
                                                I && u.progress(1)));
                                            n > t.end && (o += t.distance),
                                            r -= t.distance
                                        }
                                        a = m + o + b * ((R_.utils.clamp(e.start, e.end, n) - e.start - o) / (r - e.start) - d)
                                    }
                                    x.length && !c && x.forEach((function(e) {
                                        return e(a - o)
                                    }
                                    )),
                                    i = a + h,
                                    a = Math.round(1e5 * i) / 1e5 || 0,
                                    u ? (u.resetTo("y", a, -D, !0),
                                    I && u.progress(1)) : (g.y = a + "px",
                                    g.renderTransform(1))
                                }
                            }
                        }),
                        E(l),
                        R_.core.getCache(l.trigger).stRevert = K,
                        l.startY = m,
                        l.pins = v,
                        l.markers = x,
                        l.ratio = s,
                        l.autoSpeed = c,
                        e.style.willChange = "transform"),
                        l
                    };
                    function Q() {
                        return a = r.clientHeight,
                        r.style.overflow = "visible",
                        N_.style.height = O_.innerHeight + (a - O_.innerHeight) / L + "px",
                        a - O_.innerHeight
                    }
                    Y(),
                    F_.addEventListener("killAll", Y),
                    R_.delayedCall(.5, (function() {
                        return I = 0
                    }
                    )),
                    this.scrollTop = H,
                    this.scrollTo = function(e, t, r) {
                        var i = R_.utils.clamp(0, q_(), isNaN(e) ? n.offset(e, r, !!t && !h) : +e);
                        t ? h ? R_.to(n, {
                            duration: R,
                            scrollTop: i,
                            overwrite: "auto",
                            ease: B_
                        }) : P(i) : H(i)
                    }
                    ,
                    this.offset = function(e, t, n) {
                        var r, i = (e = U_(e)[0]).style.cssText, a = F_.create({
                            trigger: e,
                            start: t || "top top"
                        });
                        return o && (I ? F_.refresh() : X([a], !0)),
                        r = a.start / (n ? L : 1),
                        a.kill(!1),
                        e.style.cssText = i,
                        R_.core.getCache(e).uncache = 1,
                        r
                    }
                    ,
                    this.content = function(e) {
                        if (arguments.length) {
                            var t = U_(e || "#smooth-content")[0] || console.warn("ScrollSmoother needs a valid content element.") || N_.children[0];
                            return t !== r && (d = (r = t).getAttribute("style") || "",
                            G && G.observe(r),
                            R_.set(r, {
                                overflow: "visible",
                                width: "100%",
                                boxSizing: "border-box",
                                y: "+=0"
                            }),
                            R || R_.set(r, {
                                clearProps: "transform"
                            })),
                            this
                        }
                        return r
                    }
                    ,
                    this.wrapper = function(e) {
                        return arguments.length ? (i = U_(e || "#smooth-wrapper")[0] || function(e) {
                            var t = D_.querySelector(".ScrollSmoother-wrapper");
                            return t || ((t = D_.createElement("div")).classList.add("ScrollSmoother-wrapper"),
                            e.parentNode.insertBefore(t, e),
                            t.appendChild(e)),
                            t
                        }(r),
                        u = i.getAttribute("style") || "",
                        Q(),
                        R_.set(i, R ? {
                            overflow: "hidden",
                            position: "fixed",
                            height: "100%",
                            width: "100%",
                            top: 0,
                            left: 0,
                            right: 0,
                            bottom: 0
                        } : {
                            overflow: "visible",
                            position: "relative",
                            width: "100%",
                            height: "auto",
                            top: "auto",
                            bottom: "auto",
                            left: "auto",
                            right: "auto"
                        }),
                        this) : i
                    }
                    ,
                    this.effects = function(e, t) {
                        var n;
                        if (o || (o = []),
                        !e)
                            return o.slice(0);
                        (e = U_(e)).forEach((function(e) {
                            for (var t = o.length; t--; )
                                o[t].trigger === e && o[t].kill()
                        }
                        ));
                        var r, i, a = t = t || {}, s = a.speed, l = a.lag, c = a.effectsPadding, u = [];
                        for (r = 0; r < e.length; r++)
                            (i = J(e[r], s, l, r, c)) && u.push(i);
                        return (n = o).push.apply(n, u),
                        !1 !== t.refresh && F_.refresh(),
                        u
                    }
                    ,
                    this.sections = function(e, t) {
                        var n;
                        if (l || (l = []),
                        !e)
                            return l.slice(0);
                        var r = U_(e).map((function(e) {
                            return F_.create({
                                trigger: e,
                                start: "top 120%",
                                end: "bottom -20%",
                                onToggle: function(t) {
                                    e.style.opacity = t.isActive ? "1" : "0",
                                    e.style.pointerEvents = t.isActive ? "all" : "none"
                                }
                            })
                        }
                        ));
                        return t && t.add ? (n = l).push.apply(n, r) : l = r.slice(0),
                        r
                    }
                    ,
                    this.content(t.content),
                    this.wrapper(t.wrapper),
                    this.render = function(e) {
                        return B(e || 0 === e ? e : O)
                    }
                    ,
                    this.getVelocity = function() {
                        return N.getVelocity(-O)
                    }
                    ,
                    F_.scrollerProxy(i, {
                        scrollTop: H,
                        scrollHeight: function() {
                            return Q() && N_.scrollHeight
                        },
                        fixedMarkers: !1 !== t.fixedMarkers && !!R,
                        content: r,
                        getBoundingClientRect: function() {
                            return {
                                top: 0,
                                left: 0,
                                width: O_.innerWidth,
                                height: O_.innerHeight
                            }
                        }
                    }),
                    F_.defaults({
                        scroller: i
                    });
                    var ee = F_.getAll().filter((function(e) {
                        return e.scroller === O_ || e.scroller === i
                    }
                    ));
                    ee.forEach((function(e) {
                        return e.revert(!0, !0)
                    }
                    )),
                    s = F_.create({
                        animation: R_.fromTo(k, {
                            y: function() {
                                return g = 0,
                                0
                            }
                        }, {
                            y: function() {
                                return g = 1,
                                -Q()
                            },
                            immediateRender: !1,
                            ease: "none",
                            data: "ScrollSmoother",
                            duration: 100,
                            onUpdate: function() {
                                if (g) {
                                    var e = v;
                                    e && (z(s),
                                    k.y = O),
                                    B(k.y, e),
                                    U(),
                                    b && !h && b(A)
                                }
                            }
                        }),
                        onRefreshInit: function(t) {
                            if (!e.isRefreshing) {
                                if (e.isRefreshing = !0,
                                o) {
                                    var n = F_.getAll().filter((function(e) {
                                        return !!e.pin
                                    }
                                    ));
                                    o.forEach((function(e) {
                                        e.vars.pinnedContainer || n.forEach((function(t) {
                                            if (t.pin.contains(e.trigger)) {
                                                var n = e.vars;
                                                n.pinnedContainer = t.pin,
                                                e.vars = null,
                                                e.init(n, e.animation)
                                            }
                                        }
                                        ))
                                    }
                                    ))
                                }
                                var r = t.getTween();
                                m = r && r._end > r._dp._time,
                                f = O,
                                k.y = 0,
                                R && (1 === F_.isTouch && (i.style.position = "absolute"),
                                i.scrollTop = 0,
                                1 === F_.isTouch && (i.style.position = "fixed"))
                            }
                        },
                        onRefresh: function(t) {
                            t.animation.invalidate(),
                            t.setPositions(t.start, Q() / L),
                            m || z(t),
                            k.y = -P() * L,
                            B(k.y),
                            I || (m && (v = !1),
                            t.animation.progress(R_.utils.clamp(0, 1, f / L / -t.end))),
                            m && (t.progress -= .001,
                            t.update()),
                            e.isRefreshing = !1
                        },
                        id: "ScrollSmoother",
                        scroller: O_,
                        invalidateOnRefresh: !0,
                        start: 0,
                        refreshPriority: -9999,
                        end: function() {
                            return Q() / L
                        },
                        onScrubComplete: function() {
                            N.reset(),
                            E && E(n)
                        },
                        scrub: R || !0
                    }),
                    this.smooth = function(e) {
                        return arguments.length && (L = (R = e || 0) && +t.speed || 1,
                        s.scrubDuration(e)),
                        s.getTween() ? s.getTween().duration() : 0
                    }
                    ,
                    s.getTween() && (s.getTween().vars.ease = t.ease || B_),
                    this.scrollTrigger = s,
                    t.effects && this.effects(!0 === t.effects ? "[data-" + C + "speed], [data-" + C + "lag]" : t.effects, {
                        effectsPadding: t.effectsPadding,
                        refresh: !1
                    }),
                    t.sections && this.sections(!0 === t.sections ? "[data-section]" : t.sections),
                    ee.forEach((function(e) {
                        e.vars.scroller = i,
                        e.revert(!1, !0),
                        e.init(e.vars, e.animation)
                    }
                    )),
                    this.paused = function(e, t) {
                        return arguments.length ? (!!h !== e && (e ? (s.getTween() && s.getTween().pause(),
                        P(-O / L),
                        N.reset(),
                        (p = F_.normalizeScroll()) && p.disable(),
                        (h = F_.observe({
                            preventDefault: !0,
                            type: "wheel,touch,scroll",
                            debounce: !1,
                            allowClicks: !0,
                            onChangeY: function() {
                                return H(-O)
                            }
                        })).nested = G_(I_, "wheel,touch,scroll", !0, !1 !== t)) : (h.nested.kill(),
                        h.kill(),
                        h = 0,
                        p && p.enable(),
                        s.progress = (-O / L - s.start) / (s.end - s.start),
                        z(s))),
                        this) : !!h
                    }
                    ,
                    this.kill = this.revert = function() {
                        n.paused(!1),
                        z(s),
                        s.kill();
                        for (var e = (o || []).concat(l || []), t = e.length; t--; )
                            e[t].kill();
                        F_.scrollerProxy(i),
                        F_.removeEventListener("killAll", Y),
                        F_.removeEventListener("refresh", q),
                        i.style.cssText = u,
                        r.style.cssText = d;
                        var a = F_.defaults({});
                        a && a.scroller === i && F_.defaults({
                            scroller: O_
                        }),
                        n.normalizer && F_.normalizeScroll(!1),
                        clearInterval(c),
                        z_ = null,
                        G && G.disconnect(),
                        N_.style.removeProperty("height"),
                        O_.removeEventListener("focusin", V)
                    }
                    ,
                    this.refresh = function(e, t) {
                        return s.refresh(e, t)
                    }
                    ,
                    M && (this.normalizer = F_.normalizeScroll(!0 === M ? {
                        debounce: !0,
                        content: !R && r
                    } : M)),
                    F_.config(t),
                    "overscrollBehavior"in O_.getComputedStyle(N_) && R_.set([N_, I_], {
                        overscrollBehavior: "none"
                    }),
                    "scrollBehavior"in O_.getComputedStyle(N_) && R_.set([N_, I_], {
                        scrollBehavior: "auto"
                    }),
                    O_.addEventListener("focusin", V),
                    c = setInterval(U, 250),
                    "loading" === D_.readyState || requestAnimationFrame((function() {
                        return F_.refresh()
                    }
                    ))
                }
                var t, n, r;
                return e.register = function(t) {
                    return L_ || (R_ = t || X_(),
                    j_() && window.document && (O_ = window,
                    D_ = document,
                    I_ = D_.documentElement,
                    N_ = D_.body),
                    R_ && (U_ = R_.utils.toArray,
                    k_ = R_.utils.clamp,
                    B_ = R_.parseEase("expo"),
                    V_ = R_.core.context || function() {}
                    ,
                    F_ = R_.core.globals().ScrollTrigger,
                    R_.core.globals("ScrollSmoother", e),
                    N_ && F_ && (W_ = R_.delayedCall(.2, (function() {
                        return F_.isRefreshing || z_ && z_.refresh()
                    }
                    )).pause(),
                    [O_, D_, I_, N_],
                    H_ = F_.core._getVelocityProp,
                    G_ = F_.core._inputObserver,
                    e.refresh = F_.refresh,
                    L_ = 1))),
                    L_
                }
                ,
                t = e,
                (n = [{
                    key: "progress",
                    get: function() {
                        return this.scrollTrigger ? this.scrollTrigger.animation._time / 100 : 0
                    }
                }]) && P_(t.prototype, n),
                r && P_(t, r),
                e
            }();
            function $_(e) {
                return $_ = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                }
                : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }
                ,
                $_(e)
            }
            function K_(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1,
                    r.configurable = !0,
                    "value"in r && (r.writable = !0),
                    Object.defineProperty(e, Z_(r.key), r)
                }
            }
            function Z_(e) {
                var t = function(e, t) {
                    if ("object" != $_(e) || !e)
                        return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var r = n.call(e, t || "default");
                        if ("object" != $_(r))
                            return r;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return ("string" === t ? String : Number)(e)
                }(e, "string");
                return "symbol" == $_(t) ? t : String(t)
            }
            function J_(e, t, n) {
                return t = ey(t),
                function(e, t) {
                    if (t && ("object" === $_(t) || "function" == typeof t))
                        return t;
                    if (void 0 !== t)
                        throw new TypeError("Derived constructors may only return object or undefined");
                    return function(e) {
                        if (void 0 === e)
                            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return e
                    }(e)
                }(e, Q_() ? Reflect.construct(t, n || [], ey(e).constructor) : t.apply(e, n))
            }
            function Q_() {
                try {
                    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
                    )))
                } catch (e) {}
                return (Q_ = function() {
                    return !!e
                }
                )()
            }
            function ey(e) {
                return ey = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                }
                ,
                ey(e)
            }
            function ty(e, t) {
                return ty = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
                    return e.__proto__ = t,
                    e
                }
                ,
                ty(e, t)
            }
            Y_.version = "3.12.5",
            Y_.create = function(e) {
                return z_ && e && z_.content() === U_(e.content)[0] ? z_ : new Y_(e)
            }
            ,
            Y_.get = function() {
                return z_
            }
            ,
            X_() && R_.registerPlugin(Y_);
            var ny = function(e) {
                function t(e) {
                    var n;
                    return function(e, t) {
                        if (!(e instanceof t))
                            throw new TypeError("Cannot call a class as a function")
                    }(this, t),
                    (n = J_(this, t, [e])).scroller = null,
                    n.scrollContent = null,
                    n.scrollProgress = 0,
                    n.scrollingBackgrounds = [],
                    n
                }
                var n, r, i;
                return function(e, t) {
                    if ("function" != typeof t && null !== t)
                        throw new TypeError("Super expression must either be null or a function");
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            writable: !0,
                            configurable: !0
                        }
                    }),
                    Object.defineProperty(e, "prototype", {
                        writable: !1
                    }),
                    t && ty(e, t)
                }(t, e),
                n = t,
                r = [{
                    key: "init",
                    value: function() {
                        var e = this;
                        y.IS_REDUCED_MOTION ? g.classList.add(x.REDUCED_MOTION) : (y.IS_DESKTOP && g.classList.add("has-smooth-scroll"),
                        this.scrollProgressBar = g.querySelector("[data-scroll-progress]"),
                        this.scrollContent = this.el.querySelector("[data-scroll-content]"),
                        Si.registerPlugin(y_, Y_),
                        y.IS_DESKTOP ? this.scroller = Y_.create({
                            content: this.scrollContent,
                            smooth: 1,
                            effects: !0,
                            effectsPrefix: "scroll-",
                            normalizeScroll: {
                                allowNestedScroll: !0
                            },
                            wrapper: this.el,
                            onUpdate: function(t) {
                                e.scrollProgress = 100 * t.progress,
                                e.setScrollProgress()
                            }
                        }) : this.el.addEventListener("scroll", (function() {
                            if (e.scrollContent) {
                                var t = e.el.scrollY || e.el.scrollTop
                                  , n = e.scrollContent.clientHeight - e.el.clientHeight;
                                e.scrollProgress = t / n * 100,
                                e.setScrollProgress()
                            }
                        }
                        )),
                        this.items = this.el.querySelectorAll("[data-scroll]"),
                        this.items.forEach((function(t, n) {
                            var r = e.el
                              , i = t
                              , a = !y.IS_DESKTOP || "2"
                              , s = null !== t.getAttribute("data-scroll-repeat");
                            if (t.hasAttribute("data-scroll-pin-section") && y.IS_DESKTOP) {
                                var o = t.querySelectorAll("[data-scroll-pin-item]")
                                  , l = y_.create({
                                    trigger: o[o.length - 1],
                                    start: "center center"
                                });
                                o.forEach((function(e, t) {
                                    y_.create({
                                        trigger: e,
                                        start: "center center",
                                        end: function() {
                                            return l.start
                                        },
                                        pin: !0,
                                        pinSpacing: !1
                                    })
                                }
                                ))
                            }
                            t.hasAttribute("data-scroll-background-scroll") && y.IS_DESKTOP && e.scrollingBackgrounds.push(t),
                            y_.create({
                                scroller: r,
                                trigger: i,
                                start: "top 98%",
                                end: "top 2%",
                                scrub: a,
                                onEnter: function() {
                                    i.classList.add("is-inview")
                                },
                                onEnterBack: function() {
                                    s && i.classList.add("is-inview")
                                },
                                onLeave: function() {
                                    s && i.classList.remove("is-inview")
                                },
                                onLeaveBack: function() {
                                    s && i.classList.remove("is-inview")
                                }
                            })
                        }
                        )),
                        window.addEventListener("resize", (function() {
                            e.setScrollProgress(),
                            e.screenSpecificParallax()
                        }
                        )),
                        this.screenSpecificParallax(),
                        y.IS_DEV && console.log("Scroll: Initiated"))
                    }
                }, {
                    key: "screenSpecificParallax",
                    value: function() {
                        if (y.IS_DESKTOP) {
                            var e = this.el.querySelectorAll("[data-scroll-parallax-minimum-width]");
                            e.forEach((function(e, t) {
                                var n = e.getAttribute("data-scroll-parallax-minimum-width");
                                window.innerWidth < n ? (!e.hasAttribute("data-scroll-speed-clone") && e.hasAttribute("data-scroll-speed") && (e.setAttribute("data-scroll-speed-clone", e.getAttribute("data-scroll-speed")),
                                e.removeAttribute("data-scroll-speed")),
                                !e.hasAttribute("data-scroll-lag-clone") && e.hasAttribute("data-scroll-lag") && (e.setAttribute("data-scroll-lag-clone", e.getAttribute("data-scroll-lag")),
                                e.removeAttribute("data-scroll-lag"))) : (e.hasAttribute("data-scroll-speed-clone") && (e.setAttribute("data-scroll-speed", e.getAttribute("data-scroll-speed-clone")),
                                e.removeAttribute("data-scroll-speed-clone")),
                                e.hasAttribute("data-scroll-lag-clone") && (e.setAttribute("data-scroll-lag", e.getAttribute("data-scroll-lag-clone")),
                                e.removeAttribute("data-scroll-lag-clone")))
                            }
                            )),
                            e.length && this.refresh()
                        }
                    }
                }, {
                    key: "refresh",
                    value: function() {
                        y_.refresh()
                    }
                }, {
                    key: "setScrollProgress",
                    value: function(e) {
                        var t = e || this.scrollProgress;
                        this.scrollProgressBar && (this.scrollProgressBar.style.height = t + "vh")
                    }
                }, {
                    key: "scrollTo",
                    value: function() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
                          , t = 0
                          , n = this.el
                          , r = this.scrollContent
                          , i = e || null;
                        if (r.offsetHeight > n.offsetHeight) {
                            if (i) {
                                var a = n.querySelector(i).offsetTop;
                                a < 70 && (t = a),
                                a > n.offsetHeight && (t = r.offsetHeight - n.offsetHeight)
                            }
                            this.scroller.scrollTo(t, !0)
                        }
                    }
                }, {
                    key: "pauseScroll",
                    value: function() {
                        var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                        y.IS_DESKTOP && !y.IS_REDUCED_MOTION && this.scroller.paused(e)
                    }
                }, {
                    key: "scrollBackgrounds",
                    value: function() {
                        var e = this;
                        this.scrollingBackgrounds.forEach((function(t, n) {
                            t.style.backgroundPosition = "0 " + 20 * e.scrollProgress + "%"
                        }
                        ))
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        y.IS_DESKTOP && !y.IS_REDUCED_MOTION && (this.scroller.kill(),
                        y_.killAll()),
                        this.scrollProgress = 0,
                        this.setScrollProgress(0),
                        y.IS_DEV && console.log("Scroll: Destroyed")
                    }
                }],
                r && K_(n.prototype, r),
                i && K_(n, i),
                Object.defineProperty(n, "prototype", {
                    writable: !1
                }),
                t
            }(p);
            function ry(e) {
                return null !== e && "object" == typeof e && "constructor"in e && e.constructor === Object
            }
            function iy(e, t) {
                void 0 === e && (e = {}),
                void 0 === t && (t = {}),
                Object.keys(t).forEach((n => {
                    void 0 === e[n] ? e[n] = t[n] : ry(t[n]) && ry(e[n]) && Object.keys(t[n]).length > 0 && iy(e[n], t[n])
                }
                ))
            }
            const ay = {
                body: {},
                addEventListener() {},
                removeEventListener() {},
                activeElement: {
                    blur() {},
                    nodeName: ""
                },
                querySelector() {
                    return null
                },
                querySelectorAll() {
                    return []
                },
                getElementById() {
                    return null
                },
                createEvent() {
                    return {
                        initEvent() {}
                    }
                },
                createElement() {
                    return {
                        children: [],
                        childNodes: [],
                        style: {},
                        setAttribute() {},
                        getElementsByTagName() {
                            return []
                        }
                    }
                },
                createElementNS() {
                    return {}
                },
                importNode() {
                    return null
                },
                location: {
                    hash: "",
                    host: "",
                    hostname: "",
                    href: "",
                    origin: "",
                    pathname: "",
                    protocol: "",
                    search: ""
                }
            };
            function sy() {
                const e = "undefined" != typeof document ? document : {};
                return iy(e, ay),
                e
            }
            const oy = {
                document: ay,
                navigator: {
                    userAgent: ""
                },
                location: {
                    hash: "",
                    host: "",
                    hostname: "",
                    href: "",
                    origin: "",
                    pathname: "",
                    protocol: "",
                    search: ""
                },
                history: {
                    replaceState() {},
                    pushState() {},
                    go() {},
                    back() {}
                },
                CustomEvent: function() {
                    return this
                },
                addEventListener() {},
                removeEventListener() {},
                getComputedStyle() {
                    return {
                        getPropertyValue() {
                            return ""
                        }
                    }
                },
                Image() {},
                Date() {},
                screen: {},
                setTimeout() {},
                clearTimeout() {},
                matchMedia() {
                    return {}
                },
                requestAnimationFrame(e) {
                    return "undefined" == typeof setTimeout ? (e(),
                    null) : setTimeout(e, 0)
                },
                cancelAnimationFrame(e) {
                    "undefined" != typeof setTimeout && clearTimeout(e)
                }
            };
            function ly() {
                const e = "undefined" != typeof window ? window : {};
                return iy(e, oy),
                e
            }
            function cy(e) {
                return void 0 === e && (e = ""),
                e.trim().split(" ").filter((e => !!e.trim()))
            }
            function uy(e, t) {
                return void 0 === t && (t = 0),
                setTimeout(e, t)
            }
            function dy() {
                return Date.now()
            }
            function hy(e, t) {
                void 0 === t && (t = "x");
                const n = ly();
                let r, i, a;
                const s = function(e) {
                    const t = ly();
                    let n;
                    return t.getComputedStyle && (n = t.getComputedStyle(e, null)),
                    !n && e.currentStyle && (n = e.currentStyle),
                    n || (n = e.style),
                    n
                }(e);
                return n.WebKitCSSMatrix ? (i = s.transform || s.webkitTransform,
                i.split(",").length > 6 && (i = i.split(", ").map((e => e.replace(",", "."))).join(", ")),
                a = new n.WebKitCSSMatrix("none" === i ? "" : i)) : (a = s.MozTransform || s.OTransform || s.MsTransform || s.msTransform || s.transform || s.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"),
                r = a.toString().split(",")),
                "x" === t && (i = n.WebKitCSSMatrix ? a.m41 : 16 === r.length ? parseFloat(r[12]) : parseFloat(r[4])),
                "y" === t && (i = n.WebKitCSSMatrix ? a.m42 : 16 === r.length ? parseFloat(r[13]) : parseFloat(r[5])),
                i || 0
            }
            function py(e) {
                return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1)
            }
            function fy() {
                const e = Object(arguments.length <= 0 ? void 0 : arguments[0])
                  , t = ["__proto__", "constructor", "prototype"];
                for (let r = 1; r < arguments.length; r += 1) {
                    const i = r < 0 || arguments.length <= r ? void 0 : arguments[r];
                    if (null != i && (n = i,
                    !("undefined" != typeof window && void 0 !== window.HTMLElement ? n instanceof HTMLElement : n && (1 === n.nodeType || 11 === n.nodeType)))) {
                        const n = Object.keys(Object(i)).filter((e => t.indexOf(e) < 0));
                        for (let t = 0, r = n.length; t < r; t += 1) {
                            const r = n[t]
                              , a = Object.getOwnPropertyDescriptor(i, r);
                            void 0 !== a && a.enumerable && (py(e[r]) && py(i[r]) ? i[r].__swiper__ ? e[r] = i[r] : fy(e[r], i[r]) : !py(e[r]) && py(i[r]) ? (e[r] = {},
                            i[r].__swiper__ ? e[r] = i[r] : fy(e[r], i[r])) : e[r] = i[r])
                        }
                    }
                }
                var n;
                return e
            }
            function my(e, t, n) {
                e.style.setProperty(t, n)
            }
            function gy(e) {
                let {swiper: t, targetPosition: n, side: r} = e;
                const i = ly()
                  , a = -t.translate;
                let s, o = null;
                const l = t.params.speed;
                t.wrapperEl.style.scrollSnapType = "none",
                i.cancelAnimationFrame(t.cssModeFrameID);
                const c = n > a ? "next" : "prev"
                  , u = (e, t) => "next" === c && e >= t || "prev" === c && e <= t
                  , d = () => {
                    s = (new Date).getTime(),
                    null === o && (o = s);
                    const e = Math.max(Math.min((s - o) / l, 1), 0)
                      , c = .5 - Math.cos(e * Math.PI) / 2;
                    let h = a + c * (n - a);
                    if (u(h, n) && (h = n),
                    t.wrapperEl.scrollTo({
                        [r]: h
                    }),
                    u(h, n))
                        return t.wrapperEl.style.overflow = "hidden",
                        t.wrapperEl.style.scrollSnapType = "",
                        setTimeout(( () => {
                            t.wrapperEl.style.overflow = "",
                            t.wrapperEl.scrollTo({
                                [r]: h
                            })
                        }
                        )),
                        void i.cancelAnimationFrame(t.cssModeFrameID);
                    t.cssModeFrameID = i.requestAnimationFrame(d)
                }
                ;
                d()
            }
            function vy(e) {
                return e.querySelector(".swiper-slide-transform") || e.shadowRoot && e.shadowRoot.querySelector(".swiper-slide-transform") || e
            }
            function _y(e, t) {
                void 0 === t && (t = "");
                const n = [...e.children];
                return e instanceof HTMLSlotElement && n.push(...e.assignedElements()),
                t ? n.filter((e => e.matches(t))) : n
            }
            function yy(e) {
                try {
                    return void console.warn(e)
                } catch (e) {}
            }
            function xy(e, t) {
                void 0 === t && (t = []);
                const n = document.createElement(e);
                return n.classList.add(...Array.isArray(t) ? t : cy(t)),
                n
            }
            function by(e) {
                const t = ly()
                  , n = sy()
                  , r = e.getBoundingClientRect()
                  , i = n.body
                  , a = e.clientTop || i.clientTop || 0
                  , s = e.clientLeft || i.clientLeft || 0
                  , o = e === t ? t.scrollY : e.scrollTop
                  , l = e === t ? t.scrollX : e.scrollLeft;
                return {
                    top: r.top + o - a,
                    left: r.left + l - s
                }
            }
            function Ey(e, t) {
                return ly().getComputedStyle(e, null).getPropertyValue(t)
            }
            function Sy(e) {
                let t, n = e;
                if (n) {
                    for (t = 0; null !== (n = n.previousSibling); )
                        1 === n.nodeType && (t += 1);
                    return t
                }
            }
            function wy(e, t) {
                const n = [];
                let r = e.parentElement;
                for (; r; )
                    t ? r.matches(t) && n.push(r) : n.push(r),
                    r = r.parentElement;
                return n
            }
            function My(e, t) {
                t && e.addEventListener("transitionend", (function n(r) {
                    r.target === e && (t.call(e, r),
                    e.removeEventListener("transitionend", n))
                }
                ))
            }
            function Ty(e, t, n) {
                const r = ly();
                return n ? e["width" === t ? "offsetWidth" : "offsetHeight"] + parseFloat(r.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-right" : "margin-top")) + parseFloat(r.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-left" : "margin-bottom")) : e.offsetWidth
            }
            function Ay(e) {
                return (Array.isArray(e) ? e : [e]).filter((e => !!e))
            }
            function Cy(e) {
                return t => Math.abs(t) > 0 && e.browser && e.browser.need3dFix && Math.abs(t) % 90 == 0 ? t + .001 : t
            }
            let Py, Ry, Ly;
            function Oy() {
                return Py || (Py = function() {
                    const e = ly()
                      , t = sy();
                    return {
                        smoothScroll: t.documentElement && t.documentElement.style && "scrollBehavior"in t.documentElement.style,
                        touch: !!("ontouchstart"in e || e.DocumentTouch && t instanceof e.DocumentTouch)
                    }
                }()),
                Py
            }
            function Dy(e) {
                return void 0 === e && (e = {}),
                Ry || (Ry = function(e) {
                    let {userAgent: t} = void 0 === e ? {} : e;
                    const n = Oy()
                      , r = ly()
                      , i = r.navigator.platform
                      , a = t || r.navigator.userAgent
                      , s = {
                        ios: !1,
                        android: !1
                    }
                      , o = r.screen.width
                      , l = r.screen.height
                      , c = a.match(/(Android);?[\s\/]+([\d.]+)?/);
                    let u = a.match(/(iPad).*OS\s([\d_]+)/);
                    const d = a.match(/(iPod)(.*OS\s([\d_]+))?/)
                      , h = !u && a.match(/(iPhone\sOS|iOS)\s([\d_]+)/)
                      , p = "Win32" === i;
                    let f = "MacIntel" === i;
                    return !u && f && n.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${o}x${l}`) >= 0 && (u = a.match(/(Version)\/([\d.]+)/),
                    u || (u = [0, 1, "13_0_0"]),
                    f = !1),
                    c && !p && (s.os = "android",
                    s.android = !0),
                    (u || h || d) && (s.os = "ios",
                    s.ios = !0),
                    s
                }(e)),
                Ry
            }
            function Iy() {
                return Ly || (Ly = function() {
                    const e = ly()
                      , t = Dy();
                    let n = !1;
                    function r() {
                        const t = e.navigator.userAgent.toLowerCase();
                        return t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0
                    }
                    if (r()) {
                        const t = String(e.navigator.userAgent);
                        if (t.includes("Version/")) {
                            const [e,r] = t.split("Version/")[1].split(" ")[0].split(".").map((e => Number(e)));
                            n = e < 16 || 16 === e && r < 2
                        }
                    }
                    const i = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent)
                      , a = r();
                    return {
                        isSafari: n || a,
                        needPerspectiveFix: n,
                        need3dFix: a || i && t.ios,
                        isWebView: i
                    }
                }()),
                Ly
            }
            var Ny = {
                on(e, t, n) {
                    const r = this;
                    if (!r.eventsListeners || r.destroyed)
                        return r;
                    if ("function" != typeof t)
                        return r;
                    const i = n ? "unshift" : "push";
                    return e.split(" ").forEach((e => {
                        r.eventsListeners[e] || (r.eventsListeners[e] = []),
                        r.eventsListeners[e][i](t)
                    }
                    )),
                    r
                },
                once(e, t, n) {
                    const r = this;
                    if (!r.eventsListeners || r.destroyed)
                        return r;
                    if ("function" != typeof t)
                        return r;
                    function i() {
                        r.off(e, i),
                        i.__emitterProxy && delete i.__emitterProxy;
                        for (var n = arguments.length, a = new Array(n), s = 0; s < n; s++)
                            a[s] = arguments[s];
                        t.apply(r, a)
                    }
                    return i.__emitterProxy = t,
                    r.on(e, i, n)
                },
                onAny(e, t) {
                    const n = this;
                    if (!n.eventsListeners || n.destroyed)
                        return n;
                    if ("function" != typeof e)
                        return n;
                    const r = t ? "unshift" : "push";
                    return n.eventsAnyListeners.indexOf(e) < 0 && n.eventsAnyListeners[r](e),
                    n
                },
                offAny(e) {
                    const t = this;
                    if (!t.eventsListeners || t.destroyed)
                        return t;
                    if (!t.eventsAnyListeners)
                        return t;
                    const n = t.eventsAnyListeners.indexOf(e);
                    return n >= 0 && t.eventsAnyListeners.splice(n, 1),
                    t
                },
                off(e, t) {
                    const n = this;
                    return !n.eventsListeners || n.destroyed ? n : n.eventsListeners ? (e.split(" ").forEach((e => {
                        void 0 === t ? n.eventsListeners[e] = [] : n.eventsListeners[e] && n.eventsListeners[e].forEach(( (r, i) => {
                            (r === t || r.__emitterProxy && r.__emitterProxy === t) && n.eventsListeners[e].splice(i, 1)
                        }
                        ))
                    }
                    )),
                    n) : n
                },
                emit() {
                    const e = this;
                    if (!e.eventsListeners || e.destroyed)
                        return e;
                    if (!e.eventsListeners)
                        return e;
                    let t, n, r;
                    for (var i = arguments.length, a = new Array(i), s = 0; s < i; s++)
                        a[s] = arguments[s];
                    "string" == typeof a[0] || Array.isArray(a[0]) ? (t = a[0],
                    n = a.slice(1, a.length),
                    r = e) : (t = a[0].events,
                    n = a[0].data,
                    r = a[0].context || e),
                    n.unshift(r);
                    return (Array.isArray(t) ? t : t.split(" ")).forEach((t => {
                        e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach((e => {
                            e.apply(r, [t, ...n])
                        }
                        )),
                        e.eventsListeners && e.eventsListeners[t] && e.eventsListeners[t].forEach((e => {
                            e.apply(r, n)
                        }
                        ))
                    }
                    )),
                    e
                }
            };
            const Uy = (e, t, n) => {
                t && !e.classList.contains(n) ? e.classList.add(n) : !t && e.classList.contains(n) && e.classList.remove(n)
            }
            ;
            const ky = (e, t, n) => {
                t && !e.classList.contains(n) ? e.classList.add(n) : !t && e.classList.contains(n) && e.classList.remove(n)
            }
            ;
            const Fy = (e, t) => {
                if (!e || e.destroyed || !e.params)
                    return;
                const n = t.closest(e.isElement ? "swiper-slide" : `.${e.params.slideClass}`);
                if (n) {
                    let t = n.querySelector(`.${e.params.lazyPreloaderClass}`);
                    !t && e.isElement && (n.shadowRoot ? t = n.shadowRoot.querySelector(`.${e.params.lazyPreloaderClass}`) : requestAnimationFrame(( () => {
                        n.shadowRoot && (t = n.shadowRoot.querySelector(`.${e.params.lazyPreloaderClass}`),
                        t && t.remove())
                    }
                    ))),
                    t && t.remove()
                }
            }
              , zy = (e, t) => {
                if (!e.slides[t])
                    return;
                const n = e.slides[t].querySelector('[loading="lazy"]');
                n && n.removeAttribute("loading")
            }
              , By = e => {
                if (!e || e.destroyed || !e.params)
                    return;
                let t = e.params.lazyPreloadPrevNext;
                const n = e.slides.length;
                if (!n || !t || t < 0)
                    return;
                t = Math.min(t, n);
                const r = "auto" === e.params.slidesPerView ? e.slidesPerViewDynamic() : Math.ceil(e.params.slidesPerView)
                  , i = e.activeIndex;
                if (e.params.grid && e.params.grid.rows > 1) {
                    const n = i
                      , a = [n - t];
                    return a.push(...Array.from({
                        length: t
                    }).map(( (e, t) => n + r + t))),
                    void e.slides.forEach(( (t, n) => {
                        a.includes(t.column) && zy(e, n)
                    }
                    ))
                }
                const a = i + r - 1;
                if (e.params.rewind || e.params.loop)
                    for (let r = i - t; r <= a + t; r += 1) {
                        const t = (r % n + n) % n;
                        (t < i || t > a) && zy(e, t)
                    }
                else
                    for (let r = Math.max(i - t, 0); r <= Math.min(a + t, n - 1); r += 1)
                        r !== i && (r > a || r < i) && zy(e, r)
            }
            ;
            var Hy = {
                updateSize: function() {
                    const e = this;
                    let t, n;
                    const r = e.el;
                    t = void 0 !== e.params.width && null !== e.params.width ? e.params.width : r.clientWidth,
                    n = void 0 !== e.params.height && null !== e.params.height ? e.params.height : r.clientHeight,
                    0 === t && e.isHorizontal() || 0 === n && e.isVertical() || (t = t - parseInt(Ey(r, "padding-left") || 0, 10) - parseInt(Ey(r, "padding-right") || 0, 10),
                    n = n - parseInt(Ey(r, "padding-top") || 0, 10) - parseInt(Ey(r, "padding-bottom") || 0, 10),
                    Number.isNaN(t) && (t = 0),
                    Number.isNaN(n) && (n = 0),
                    Object.assign(e, {
                        width: t,
                        height: n,
                        size: e.isHorizontal() ? t : n
                    }))
                },
                updateSlides: function() {
                    const e = this;
                    function t(t, n) {
                        return parseFloat(t.getPropertyValue(e.getDirectionLabel(n)) || 0)
                    }
                    const n = e.params
                      , {wrapperEl: r, slidesEl: i, size: a, rtlTranslate: s, wrongRTL: o} = e
                      , l = e.virtual && n.virtual.enabled
                      , c = l ? e.virtual.slides.length : e.slides.length
                      , u = _y(i, `.${e.params.slideClass}, swiper-slide`)
                      , d = l ? e.virtual.slides.length : u.length;
                    let h = [];
                    const p = []
                      , f = [];
                    let m = n.slidesOffsetBefore;
                    "function" == typeof m && (m = n.slidesOffsetBefore.call(e));
                    let g = n.slidesOffsetAfter;
                    "function" == typeof g && (g = n.slidesOffsetAfter.call(e));
                    const v = e.snapGrid.length
                      , _ = e.slidesGrid.length;
                    let y = n.spaceBetween
                      , x = -m
                      , b = 0
                      , E = 0;
                    if (void 0 === a)
                        return;
                    "string" == typeof y && y.indexOf("%") >= 0 ? y = parseFloat(y.replace("%", "")) / 100 * a : "string" == typeof y && (y = parseFloat(y)),
                    e.virtualSize = -y,
                    u.forEach((e => {
                        s ? e.style.marginLeft = "" : e.style.marginRight = "",
                        e.style.marginBottom = "",
                        e.style.marginTop = ""
                    }
                    )),
                    n.centeredSlides && n.cssMode && (my(r, "--swiper-centered-offset-before", ""),
                    my(r, "--swiper-centered-offset-after", ""));
                    const S = n.grid && n.grid.rows > 1 && e.grid;
                    let w;
                    S ? e.grid.initSlides(u) : e.grid && e.grid.unsetSlides();
                    const M = "auto" === n.slidesPerView && n.breakpoints && Object.keys(n.breakpoints).filter((e => void 0 !== n.breakpoints[e].slidesPerView)).length > 0;
                    for (let r = 0; r < d; r += 1) {
                        let i;
                        if (w = 0,
                        u[r] && (i = u[r]),
                        S && e.grid.updateSlide(r, i, u),
                        !u[r] || "none" !== Ey(i, "display")) {
                            if ("auto" === n.slidesPerView) {
                                M && (u[r].style[e.getDirectionLabel("width")] = "");
                                const a = getComputedStyle(i)
                                  , s = i.style.transform
                                  , o = i.style.webkitTransform;
                                if (s && (i.style.transform = "none"),
                                o && (i.style.webkitTransform = "none"),
                                n.roundLengths)
                                    w = e.isHorizontal() ? Ty(i, "width", !0) : Ty(i, "height", !0);
                                else {
                                    const e = t(a, "width")
                                      , n = t(a, "padding-left")
                                      , r = t(a, "padding-right")
                                      , s = t(a, "margin-left")
                                      , o = t(a, "margin-right")
                                      , l = a.getPropertyValue("box-sizing");
                                    if (l && "border-box" === l)
                                        w = e + s + o;
                                    else {
                                        const {clientWidth: t, offsetWidth: a} = i;
                                        w = e + n + r + s + o + (a - t)
                                    }
                                }
                                s && (i.style.transform = s),
                                o && (i.style.webkitTransform = o),
                                n.roundLengths && (w = Math.floor(w))
                            } else
                                w = (a - (n.slidesPerView - 1) * y) / n.slidesPerView,
                                n.roundLengths && (w = Math.floor(w)),
                                u[r] && (u[r].style[e.getDirectionLabel("width")] = `${w}px`);
                            u[r] && (u[r].swiperSlideSize = w),
                            f.push(w),
                            n.centeredSlides ? (x = x + w / 2 + b / 2 + y,
                            0 === b && 0 !== r && (x = x - a / 2 - y),
                            0 === r && (x = x - a / 2 - y),
                            Math.abs(x) < .001 && (x = 0),
                            n.roundLengths && (x = Math.floor(x)),
                            E % n.slidesPerGroup == 0 && h.push(x),
                            p.push(x)) : (n.roundLengths && (x = Math.floor(x)),
                            (E - Math.min(e.params.slidesPerGroupSkip, E)) % e.params.slidesPerGroup == 0 && h.push(x),
                            p.push(x),
                            x = x + w + y),
                            e.virtualSize += w + y,
                            b = w,
                            E += 1
                        }
                    }
                    if (e.virtualSize = Math.max(e.virtualSize, a) + g,
                    s && o && ("slide" === n.effect || "coverflow" === n.effect) && (r.style.width = `${e.virtualSize + y}px`),
                    n.setWrapperSize && (r.style[e.getDirectionLabel("width")] = `${e.virtualSize + y}px`),
                    S && e.grid.updateWrapperSize(w, h),
                    !n.centeredSlides) {
                        const t = [];
                        for (let r = 0; r < h.length; r += 1) {
                            let i = h[r];
                            n.roundLengths && (i = Math.floor(i)),
                            h[r] <= e.virtualSize - a && t.push(i)
                        }
                        h = t,
                        Math.floor(e.virtualSize - a) - Math.floor(h[h.length - 1]) > 1 && h.push(e.virtualSize - a)
                    }
                    if (l && n.loop) {
                        const t = f[0] + y;
                        if (n.slidesPerGroup > 1) {
                            const r = Math.ceil((e.virtual.slidesBefore + e.virtual.slidesAfter) / n.slidesPerGroup)
                              , i = t * n.slidesPerGroup;
                            for (let e = 0; e < r; e += 1)
                                h.push(h[h.length - 1] + i)
                        }
                        for (let r = 0; r < e.virtual.slidesBefore + e.virtual.slidesAfter; r += 1)
                            1 === n.slidesPerGroup && h.push(h[h.length - 1] + t),
                            p.push(p[p.length - 1] + t),
                            e.virtualSize += t
                    }
                    if (0 === h.length && (h = [0]),
                    0 !== y) {
                        const t = e.isHorizontal() && s ? "marginLeft" : e.getDirectionLabel("marginRight");
                        u.filter(( (e, t) => !(n.cssMode && !n.loop) || t !== u.length - 1)).forEach((e => {
                            e.style[t] = `${y}px`
                        }
                        ))
                    }
                    if (n.centeredSlides && n.centeredSlidesBounds) {
                        let e = 0;
                        f.forEach((t => {
                            e += t + (y || 0)
                        }
                        )),
                        e -= y;
                        const t = e > a ? e - a : 0;
                        h = h.map((e => e <= 0 ? -m : e > t ? t + g : e))
                    }
                    if (n.centerInsufficientSlides) {
                        let e = 0;
                        f.forEach((t => {
                            e += t + (y || 0)
                        }
                        )),
                        e -= y;
                        const t = (n.slidesOffsetBefore || 0) + (n.slidesOffsetAfter || 0);
                        if (e + t < a) {
                            const n = (a - e - t) / 2;
                            h.forEach(( (e, t) => {
                                h[t] = e - n
                            }
                            )),
                            p.forEach(( (e, t) => {
                                p[t] = e + n
                            }
                            ))
                        }
                    }
                    if (Object.assign(e, {
                        slides: u,
                        snapGrid: h,
                        slidesGrid: p,
                        slidesSizesGrid: f
                    }),
                    n.centeredSlides && n.cssMode && !n.centeredSlidesBounds) {
                        my(r, "--swiper-centered-offset-before", -h[0] + "px"),
                        my(r, "--swiper-centered-offset-after", e.size / 2 - f[f.length - 1] / 2 + "px");
                        const t = -e.snapGrid[0]
                          , n = -e.slidesGrid[0];
                        e.snapGrid = e.snapGrid.map((e => e + t)),
                        e.slidesGrid = e.slidesGrid.map((e => e + n))
                    }
                    if (d !== c && e.emit("slidesLengthChange"),
                    h.length !== v && (e.params.watchOverflow && e.checkOverflow(),
                    e.emit("snapGridLengthChange")),
                    p.length !== _ && e.emit("slidesGridLengthChange"),
                    n.watchSlidesProgress && e.updateSlidesOffset(),
                    e.emit("slidesUpdated"),
                    !(l || n.cssMode || "slide" !== n.effect && "fade" !== n.effect)) {
                        const t = `${n.containerModifierClass}backface-hidden`
                          , r = e.el.classList.contains(t);
                        d <= n.maxBackfaceHiddenSlides ? r || e.el.classList.add(t) : r && e.el.classList.remove(t)
                    }
                },
                updateAutoHeight: function(e) {
                    const t = this
                      , n = []
                      , r = t.virtual && t.params.virtual.enabled;
                    let i, a = 0;
                    "number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed);
                    const s = e => r ? t.slides[t.getSlideIndexByData(e)] : t.slides[e];
                    if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1)
                        if (t.params.centeredSlides)
                            (t.visibleSlides || []).forEach((e => {
                                n.push(e)
                            }
                            ));
                        else
                            for (i = 0; i < Math.ceil(t.params.slidesPerView); i += 1) {
                                const e = t.activeIndex + i;
                                if (e > t.slides.length && !r)
                                    break;
                                n.push(s(e))
                            }
                    else
                        n.push(s(t.activeIndex));
                    for (i = 0; i < n.length; i += 1)
                        if (void 0 !== n[i]) {
                            const e = n[i].offsetHeight;
                            a = e > a ? e : a
                        }
                    (a || 0 === a) && (t.wrapperEl.style.height = `${a}px`)
                },
                updateSlidesOffset: function() {
                    const e = this
                      , t = e.slides
                      , n = e.isElement ? e.isHorizontal() ? e.wrapperEl.offsetLeft : e.wrapperEl.offsetTop : 0;
                    for (let r = 0; r < t.length; r += 1)
                        t[r].swiperSlideOffset = (e.isHorizontal() ? t[r].offsetLeft : t[r].offsetTop) - n - e.cssOverflowAdjustment()
                },
                updateSlidesProgress: function(e) {
                    void 0 === e && (e = this && this.translate || 0);
                    const t = this
                      , n = t.params
                      , {slides: r, rtlTranslate: i, snapGrid: a} = t;
                    if (0 === r.length)
                        return;
                    void 0 === r[0].swiperSlideOffset && t.updateSlidesOffset();
                    let s = -e;
                    i && (s = e),
                    t.visibleSlidesIndexes = [],
                    t.visibleSlides = [];
                    let o = n.spaceBetween;
                    "string" == typeof o && o.indexOf("%") >= 0 ? o = parseFloat(o.replace("%", "")) / 100 * t.size : "string" == typeof o && (o = parseFloat(o));
                    for (let e = 0; e < r.length; e += 1) {
                        const l = r[e];
                        let c = l.swiperSlideOffset;
                        n.cssMode && n.centeredSlides && (c -= r[0].swiperSlideOffset);
                        const u = (s + (n.centeredSlides ? t.minTranslate() : 0) - c) / (l.swiperSlideSize + o)
                          , d = (s - a[0] + (n.centeredSlides ? t.minTranslate() : 0) - c) / (l.swiperSlideSize + o)
                          , h = -(s - c)
                          , p = h + t.slidesSizesGrid[e]
                          , f = h >= 0 && h <= t.size - t.slidesSizesGrid[e]
                          , m = h >= 0 && h < t.size - 1 || p > 1 && p <= t.size || h <= 0 && p >= t.size;
                        m && (t.visibleSlides.push(l),
                        t.visibleSlidesIndexes.push(e)),
                        Uy(l, m, n.slideVisibleClass),
                        Uy(l, f, n.slideFullyVisibleClass),
                        l.progress = i ? -u : u,
                        l.originalProgress = i ? -d : d
                    }
                },
                updateProgress: function(e) {
                    const t = this;
                    if (void 0 === e) {
                        const n = t.rtlTranslate ? -1 : 1;
                        e = t && t.translate && t.translate * n || 0
                    }
                    const n = t.params
                      , r = t.maxTranslate() - t.minTranslate();
                    let {progress: i, isBeginning: a, isEnd: s, progressLoop: o} = t;
                    const l = a
                      , c = s;
                    if (0 === r)
                        i = 0,
                        a = !0,
                        s = !0;
                    else {
                        i = (e - t.minTranslate()) / r;
                        const n = Math.abs(e - t.minTranslate()) < 1
                          , o = Math.abs(e - t.maxTranslate()) < 1;
                        a = n || i <= 0,
                        s = o || i >= 1,
                        n && (i = 0),
                        o && (i = 1)
                    }
                    if (n.loop) {
                        const n = t.getSlideIndexByData(0)
                          , r = t.getSlideIndexByData(t.slides.length - 1)
                          , i = t.slidesGrid[n]
                          , a = t.slidesGrid[r]
                          , s = t.slidesGrid[t.slidesGrid.length - 1]
                          , l = Math.abs(e);
                        o = l >= i ? (l - i) / s : (l + s - a) / s,
                        o > 1 && (o -= 1)
                    }
                    Object.assign(t, {
                        progress: i,
                        progressLoop: o,
                        isBeginning: a,
                        isEnd: s
                    }),
                    (n.watchSlidesProgress || n.centeredSlides && n.autoHeight) && t.updateSlidesProgress(e),
                    a && !l && t.emit("reachBeginning toEdge"),
                    s && !c && t.emit("reachEnd toEdge"),
                    (l && !a || c && !s) && t.emit("fromEdge"),
                    t.emit("progress", i)
                },
                updateSlidesClasses: function() {
                    const e = this
                      , {slides: t, params: n, slidesEl: r, activeIndex: i} = e
                      , a = e.virtual && n.virtual.enabled
                      , s = e.grid && n.grid && n.grid.rows > 1
                      , o = e => _y(r, `.${n.slideClass}${e}, swiper-slide${e}`)[0];
                    let l, c, u;
                    if (a)
                        if (n.loop) {
                            let t = i - e.virtual.slidesBefore;
                            t < 0 && (t = e.virtual.slides.length + t),
                            t >= e.virtual.slides.length && (t -= e.virtual.slides.length),
                            l = o(`[data-swiper-slide-index="${t}"]`)
                        } else
                            l = o(`[data-swiper-slide-index="${i}"]`);
                    else
                        s ? (l = t.filter((e => e.column === i))[0],
                        u = t.filter((e => e.column === i + 1))[0],
                        c = t.filter((e => e.column === i - 1))[0]) : l = t[i];
                    l && (s || (u = function(e, t) {
                        const n = [];
                        for (; e.nextElementSibling; ) {
                            const r = e.nextElementSibling;
                            t ? r.matches(t) && n.push(r) : n.push(r),
                            e = r
                        }
                        return n
                    }(l, `.${n.slideClass}, swiper-slide`)[0],
                    n.loop && !u && (u = t[0]),
                    c = function(e, t) {
                        const n = [];
                        for (; e.previousElementSibling; ) {
                            const r = e.previousElementSibling;
                            t ? r.matches(t) && n.push(r) : n.push(r),
                            e = r
                        }
                        return n
                    }(l, `.${n.slideClass}, swiper-slide`)[0],
                    n.loop && 0 === !c && (c = t[t.length - 1]))),
                    t.forEach((e => {
                        ky(e, e === l, n.slideActiveClass),
                        ky(e, e === u, n.slideNextClass),
                        ky(e, e === c, n.slidePrevClass)
                    }
                    )),
                    e.emitSlidesClasses()
                },
                updateActiveIndex: function(e) {
                    const t = this
                      , n = t.rtlTranslate ? t.translate : -t.translate
                      , {snapGrid: r, params: i, activeIndex: a, realIndex: s, snapIndex: o} = t;
                    let l, c = e;
                    const u = e => {
                        let n = e - t.virtual.slidesBefore;
                        return n < 0 && (n = t.virtual.slides.length + n),
                        n >= t.virtual.slides.length && (n -= t.virtual.slides.length),
                        n
                    }
                    ;
                    if (void 0 === c && (c = function(e) {
                        const {slidesGrid: t, params: n} = e
                          , r = e.rtlTranslate ? e.translate : -e.translate;
                        let i;
                        for (let e = 0; e < t.length; e += 1)
                            void 0 !== t[e + 1] ? r >= t[e] && r < t[e + 1] - (t[e + 1] - t[e]) / 2 ? i = e : r >= t[e] && r < t[e + 1] && (i = e + 1) : r >= t[e] && (i = e);
                        return n.normalizeSlideIndex && (i < 0 || void 0 === i) && (i = 0),
                        i
                    }(t)),
                    r.indexOf(n) >= 0)
                        l = r.indexOf(n);
                    else {
                        const e = Math.min(i.slidesPerGroupSkip, c);
                        l = e + Math.floor((c - e) / i.slidesPerGroup)
                    }
                    if (l >= r.length && (l = r.length - 1),
                    c === a && !t.params.loop)
                        return void (l !== o && (t.snapIndex = l,
                        t.emit("snapIndexChange")));
                    if (c === a && t.params.loop && t.virtual && t.params.virtual.enabled)
                        return void (t.realIndex = u(c));
                    const d = t.grid && i.grid && i.grid.rows > 1;
                    let h;
                    if (t.virtual && i.virtual.enabled && i.loop)
                        h = u(c);
                    else if (d) {
                        const e = t.slides.filter((e => e.column === c))[0];
                        let n = parseInt(e.getAttribute("data-swiper-slide-index"), 10);
                        Number.isNaN(n) && (n = Math.max(t.slides.indexOf(e), 0)),
                        h = Math.floor(n / i.grid.rows)
                    } else if (t.slides[c]) {
                        const e = t.slides[c].getAttribute("data-swiper-slide-index");
                        h = e ? parseInt(e, 10) : c
                    } else
                        h = c;
                    Object.assign(t, {
                        previousSnapIndex: o,
                        snapIndex: l,
                        previousRealIndex: s,
                        realIndex: h,
                        previousIndex: a,
                        activeIndex: c
                    }),
                    t.initialized && By(t),
                    t.emit("activeIndexChange"),
                    t.emit("snapIndexChange"),
                    (t.initialized || t.params.runCallbacksOnInit) && (s !== h && t.emit("realIndexChange"),
                    t.emit("slideChange"))
                },
                updateClickedSlide: function(e, t) {
                    const n = this
                      , r = n.params;
                    let i = e.closest(`.${r.slideClass}, swiper-slide`);
                    !i && n.isElement && t && t.length > 1 && t.includes(e) && [...t.slice(t.indexOf(e) + 1, t.length)].forEach((e => {
                        !i && e.matches && e.matches(`.${r.slideClass}, swiper-slide`) && (i = e)
                    }
                    ));
                    let a, s = !1;
                    if (i)
                        for (let e = 0; e < n.slides.length; e += 1)
                            if (n.slides[e] === i) {
                                s = !0,
                                a = e;
                                break
                            }
                    if (!i || !s)
                        return n.clickedSlide = void 0,
                        void (n.clickedIndex = void 0);
                    n.clickedSlide = i,
                    n.virtual && n.params.virtual.enabled ? n.clickedIndex = parseInt(i.getAttribute("data-swiper-slide-index"), 10) : n.clickedIndex = a,
                    r.slideToClickedSlide && void 0 !== n.clickedIndex && n.clickedIndex !== n.activeIndex && n.slideToClickedSlide()
                }
            };
            var Gy = {
                getTranslate: function(e) {
                    void 0 === e && (e = this.isHorizontal() ? "x" : "y");
                    const {params: t, rtlTranslate: n, translate: r, wrapperEl: i} = this;
                    if (t.virtualTranslate)
                        return n ? -r : r;
                    if (t.cssMode)
                        return r;
                    let a = hy(i, e);
                    return a += this.cssOverflowAdjustment(),
                    n && (a = -a),
                    a || 0
                },
                setTranslate: function(e, t) {
                    const n = this
                      , {rtlTranslate: r, params: i, wrapperEl: a, progress: s} = n;
                    let o, l = 0, c = 0;
                    n.isHorizontal() ? l = r ? -e : e : c = e,
                    i.roundLengths && (l = Math.floor(l),
                    c = Math.floor(c)),
                    n.previousTranslate = n.translate,
                    n.translate = n.isHorizontal() ? l : c,
                    i.cssMode ? a[n.isHorizontal() ? "scrollLeft" : "scrollTop"] = n.isHorizontal() ? -l : -c : i.virtualTranslate || (n.isHorizontal() ? l -= n.cssOverflowAdjustment() : c -= n.cssOverflowAdjustment(),
                    a.style.transform = `translate3d(${l}px, ${c}px, 0px)`);
                    const u = n.maxTranslate() - n.minTranslate();
                    o = 0 === u ? 0 : (e - n.minTranslate()) / u,
                    o !== s && n.updateProgress(e),
                    n.emit("setTranslate", n.translate, t)
                },
                minTranslate: function() {
                    return -this.snapGrid[0]
                },
                maxTranslate: function() {
                    return -this.snapGrid[this.snapGrid.length - 1]
                },
                translateTo: function(e, t, n, r, i) {
                    void 0 === e && (e = 0),
                    void 0 === t && (t = this.params.speed),
                    void 0 === n && (n = !0),
                    void 0 === r && (r = !0);
                    const a = this
                      , {params: s, wrapperEl: o} = a;
                    if (a.animating && s.preventInteractionOnTransition)
                        return !1;
                    const l = a.minTranslate()
                      , c = a.maxTranslate();
                    let u;
                    if (u = r && e > l ? l : r && e < c ? c : e,
                    a.updateProgress(u),
                    s.cssMode) {
                        const e = a.isHorizontal();
                        if (0 === t)
                            o[e ? "scrollLeft" : "scrollTop"] = -u;
                        else {
                            if (!a.support.smoothScroll)
                                return gy({
                                    swiper: a,
                                    targetPosition: -u,
                                    side: e ? "left" : "top"
                                }),
                                !0;
                            o.scrollTo({
                                [e ? "left" : "top"]: -u,
                                behavior: "smooth"
                            })
                        }
                        return !0
                    }
                    return 0 === t ? (a.setTransition(0),
                    a.setTranslate(u),
                    n && (a.emit("beforeTransitionStart", t, i),
                    a.emit("transitionEnd"))) : (a.setTransition(t),
                    a.setTranslate(u),
                    n && (a.emit("beforeTransitionStart", t, i),
                    a.emit("transitionStart")),
                    a.animating || (a.animating = !0,
                    a.onTranslateToWrapperTransitionEnd || (a.onTranslateToWrapperTransitionEnd = function(e) {
                        a && !a.destroyed && e.target === this && (a.wrapperEl.removeEventListener("transitionend", a.onTranslateToWrapperTransitionEnd),
                        a.onTranslateToWrapperTransitionEnd = null,
                        delete a.onTranslateToWrapperTransitionEnd,
                        a.animating = !1,
                        n && a.emit("transitionEnd"))
                    }
                    ),
                    a.wrapperEl.addEventListener("transitionend", a.onTranslateToWrapperTransitionEnd))),
                    !0
                }
            };
            function Vy(e) {
                let {swiper: t, runCallbacks: n, direction: r, step: i} = e;
                const {activeIndex: a, previousIndex: s} = t;
                let o = r;
                if (o || (o = a > s ? "next" : a < s ? "prev" : "reset"),
                t.emit(`transition${i}`),
                n && a !== s) {
                    if ("reset" === o)
                        return void t.emit(`slideResetTransition${i}`);
                    t.emit(`slideChangeTransition${i}`),
                    "next" === o ? t.emit(`slideNextTransition${i}`) : t.emit(`slidePrevTransition${i}`)
                }
            }
            var Wy = {
                slideTo: function(e, t, n, r, i) {
                    void 0 === e && (e = 0),
                    void 0 === n && (n = !0),
                    "string" == typeof e && (e = parseInt(e, 10));
                    const a = this;
                    let s = e;
                    s < 0 && (s = 0);
                    const {params: o, snapGrid: l, slidesGrid: c, previousIndex: u, activeIndex: d, rtlTranslate: h, wrapperEl: p, enabled: f} = a;
                    if (!f && !r && !i || a.destroyed || a.animating && o.preventInteractionOnTransition)
                        return !1;
                    void 0 === t && (t = a.params.speed);
                    const m = Math.min(a.params.slidesPerGroupSkip, s);
                    let g = m + Math.floor((s - m) / a.params.slidesPerGroup);
                    g >= l.length && (g = l.length - 1);
                    const v = -l[g];
                    if (o.normalizeSlideIndex)
                        for (let e = 0; e < c.length; e += 1) {
                            const t = -Math.floor(100 * v)
                              , n = Math.floor(100 * c[e])
                              , r = Math.floor(100 * c[e + 1]);
                            void 0 !== c[e + 1] ? t >= n && t < r - (r - n) / 2 ? s = e : t >= n && t < r && (s = e + 1) : t >= n && (s = e)
                        }
                    if (a.initialized && s !== d) {
                        if (!a.allowSlideNext && (h ? v > a.translate && v > a.minTranslate() : v < a.translate && v < a.minTranslate()))
                            return !1;
                        if (!a.allowSlidePrev && v > a.translate && v > a.maxTranslate() && (d || 0) !== s)
                            return !1
                    }
                    let _;
                    s !== (u || 0) && n && a.emit("beforeSlideChangeStart"),
                    a.updateProgress(v),
                    _ = s > d ? "next" : s < d ? "prev" : "reset";
                    const y = a.virtual && a.params.virtual.enabled;
                    if (!(y && i) && (h && -v === a.translate || !h && v === a.translate))
                        return a.updateActiveIndex(s),
                        o.autoHeight && a.updateAutoHeight(),
                        a.updateSlidesClasses(),
                        "slide" !== o.effect && a.setTranslate(v),
                        "reset" !== _ && (a.transitionStart(n, _),
                        a.transitionEnd(n, _)),
                        !1;
                    if (o.cssMode) {
                        const e = a.isHorizontal()
                          , n = h ? v : -v;
                        if (0 === t)
                            y && (a.wrapperEl.style.scrollSnapType = "none",
                            a._immediateVirtual = !0),
                            y && !a._cssModeVirtualInitialSet && a.params.initialSlide > 0 ? (a._cssModeVirtualInitialSet = !0,
                            requestAnimationFrame(( () => {
                                p[e ? "scrollLeft" : "scrollTop"] = n
                            }
                            ))) : p[e ? "scrollLeft" : "scrollTop"] = n,
                            y && requestAnimationFrame(( () => {
                                a.wrapperEl.style.scrollSnapType = "",
                                a._immediateVirtual = !1
                            }
                            ));
                        else {
                            if (!a.support.smoothScroll)
                                return gy({
                                    swiper: a,
                                    targetPosition: n,
                                    side: e ? "left" : "top"
                                }),
                                !0;
                            p.scrollTo({
                                [e ? "left" : "top"]: n,
                                behavior: "smooth"
                            })
                        }
                        return !0
                    }
                    return a.setTransition(t),
                    a.setTranslate(v),
                    a.updateActiveIndex(s),
                    a.updateSlidesClasses(),
                    a.emit("beforeTransitionStart", t, r),
                    a.transitionStart(n, _),
                    0 === t ? a.transitionEnd(n, _) : a.animating || (a.animating = !0,
                    a.onSlideToWrapperTransitionEnd || (a.onSlideToWrapperTransitionEnd = function(e) {
                        a && !a.destroyed && e.target === this && (a.wrapperEl.removeEventListener("transitionend", a.onSlideToWrapperTransitionEnd),
                        a.onSlideToWrapperTransitionEnd = null,
                        delete a.onSlideToWrapperTransitionEnd,
                        a.transitionEnd(n, _))
                    }
                    ),
                    a.wrapperEl.addEventListener("transitionend", a.onSlideToWrapperTransitionEnd)),
                    !0
                },
                slideToLoop: function(e, t, n, r) {
                    if (void 0 === e && (e = 0),
                    void 0 === n && (n = !0),
                    "string" == typeof e) {
                        e = parseInt(e, 10)
                    }
                    const i = this;
                    if (i.destroyed)
                        return;
                    void 0 === t && (t = i.params.speed);
                    const a = i.grid && i.params.grid && i.params.grid.rows > 1;
                    let s = e;
                    if (i.params.loop)
                        if (i.virtual && i.params.virtual.enabled)
                            s += i.virtual.slidesBefore;
                        else {
                            let e;
                            if (a) {
                                const t = s * i.params.grid.rows;
                                e = i.slides.filter((e => 1 * e.getAttribute("data-swiper-slide-index") === t))[0].column
                            } else
                                e = i.getSlideIndexByData(s);
                            const t = a ? Math.ceil(i.slides.length / i.params.grid.rows) : i.slides.length
                              , {centeredSlides: n} = i.params;
                            let o = i.params.slidesPerView;
                            "auto" === o ? o = i.slidesPerViewDynamic() : (o = Math.ceil(parseFloat(i.params.slidesPerView, 10)),
                            n && o % 2 == 0 && (o += 1));
                            let l = t - e < o;
                            if (n && (l = l || e < Math.ceil(o / 2)),
                            r && n && "auto" !== i.params.slidesPerView && !a && (l = !1),
                            l) {
                                const r = n ? e < i.activeIndex ? "prev" : "next" : e - i.activeIndex - 1 < i.params.slidesPerView ? "next" : "prev";
                                i.loopFix({
                                    direction: r,
                                    slideTo: !0,
                                    activeSlideIndex: "next" === r ? e + 1 : e - t + 1,
                                    slideRealIndex: "next" === r ? i.realIndex : void 0
                                })
                            }
                            if (a) {
                                const e = s * i.params.grid.rows;
                                s = i.slides.filter((t => 1 * t.getAttribute("data-swiper-slide-index") === e))[0].column
                            } else
                                s = i.getSlideIndexByData(s)
                        }
                    return requestAnimationFrame(( () => {
                        i.slideTo(s, t, n, r)
                    }
                    )),
                    i
                },
                slideNext: function(e, t, n) {
                    void 0 === t && (t = !0);
                    const r = this
                      , {enabled: i, params: a, animating: s} = r;
                    if (!i || r.destroyed)
                        return r;
                    void 0 === e && (e = r.params.speed);
                    let o = a.slidesPerGroup;
                    "auto" === a.slidesPerView && 1 === a.slidesPerGroup && a.slidesPerGroupAuto && (o = Math.max(r.slidesPerViewDynamic("current", !0), 1));
                    const l = r.activeIndex < a.slidesPerGroupSkip ? 1 : o
                      , c = r.virtual && a.virtual.enabled;
                    if (a.loop) {
                        if (s && !c && a.loopPreventsSliding)
                            return !1;
                        if (r.loopFix({
                            direction: "next"
                        }),
                        r._clientLeft = r.wrapperEl.clientLeft,
                        r.activeIndex === r.slides.length - 1 && a.cssMode)
                            return requestAnimationFrame(( () => {
                                r.slideTo(r.activeIndex + l, e, t, n)
                            }
                            )),
                            !0
                    }
                    return a.rewind && r.isEnd ? r.slideTo(0, e, t, n) : r.slideTo(r.activeIndex + l, e, t, n)
                },
                slidePrev: function(e, t, n) {
                    void 0 === t && (t = !0);
                    const r = this
                      , {params: i, snapGrid: a, slidesGrid: s, rtlTranslate: o, enabled: l, animating: c} = r;
                    if (!l || r.destroyed)
                        return r;
                    void 0 === e && (e = r.params.speed);
                    const u = r.virtual && i.virtual.enabled;
                    if (i.loop) {
                        if (c && !u && i.loopPreventsSliding)
                            return !1;
                        r.loopFix({
                            direction: "prev"
                        }),
                        r._clientLeft = r.wrapperEl.clientLeft
                    }
                    function d(e) {
                        return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e)
                    }
                    const h = d(o ? r.translate : -r.translate)
                      , p = a.map((e => d(e)));
                    let f = a[p.indexOf(h) - 1];
                    if (void 0 === f && i.cssMode) {
                        let e;
                        a.forEach(( (t, n) => {
                            h >= t && (e = n)
                        }
                        )),
                        void 0 !== e && (f = a[e > 0 ? e - 1 : e])
                    }
                    let m = 0;
                    if (void 0 !== f && (m = s.indexOf(f),
                    m < 0 && (m = r.activeIndex - 1),
                    "auto" === i.slidesPerView && 1 === i.slidesPerGroup && i.slidesPerGroupAuto && (m = m - r.slidesPerViewDynamic("previous", !0) + 1,
                    m = Math.max(m, 0))),
                    i.rewind && r.isBeginning) {
                        const i = r.params.virtual && r.params.virtual.enabled && r.virtual ? r.virtual.slides.length - 1 : r.slides.length - 1;
                        return r.slideTo(i, e, t, n)
                    }
                    return i.loop && 0 === r.activeIndex && i.cssMode ? (requestAnimationFrame(( () => {
                        r.slideTo(m, e, t, n)
                    }
                    )),
                    !0) : r.slideTo(m, e, t, n)
                },
                slideReset: function(e, t, n) {
                    void 0 === t && (t = !0);
                    const r = this;
                    if (!r.destroyed)
                        return void 0 === e && (e = r.params.speed),
                        r.slideTo(r.activeIndex, e, t, n)
                },
                slideToClosest: function(e, t, n, r) {
                    void 0 === t && (t = !0),
                    void 0 === r && (r = .5);
                    const i = this;
                    if (i.destroyed)
                        return;
                    void 0 === e && (e = i.params.speed);
                    let a = i.activeIndex;
                    const s = Math.min(i.params.slidesPerGroupSkip, a)
                      , o = s + Math.floor((a - s) / i.params.slidesPerGroup)
                      , l = i.rtlTranslate ? i.translate : -i.translate;
                    if (l >= i.snapGrid[o]) {
                        const e = i.snapGrid[o];
                        l - e > (i.snapGrid[o + 1] - e) * r && (a += i.params.slidesPerGroup)
                    } else {
                        const e = i.snapGrid[o - 1];
                        l - e <= (i.snapGrid[o] - e) * r && (a -= i.params.slidesPerGroup)
                    }
                    return a = Math.max(a, 0),
                    a = Math.min(a, i.slidesGrid.length - 1),
                    i.slideTo(a, e, t, n)
                },
                slideToClickedSlide: function() {
                    const e = this;
                    if (e.destroyed)
                        return;
                    const {params: t, slidesEl: n} = e
                      , r = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView;
                    let i, a = e.clickedIndex;
                    const s = e.isElement ? "swiper-slide" : `.${t.slideClass}`;
                    if (t.loop) {
                        if (e.animating)
                            return;
                        i = parseInt(e.clickedSlide.getAttribute("data-swiper-slide-index"), 10),
                        t.centeredSlides ? a < e.loopedSlides - r / 2 || a > e.slides.length - e.loopedSlides + r / 2 ? (e.loopFix(),
                        a = e.getSlideIndex(_y(n, `${s}[data-swiper-slide-index="${i}"]`)[0]),
                        uy(( () => {
                            e.slideTo(a)
                        }
                        ))) : e.slideTo(a) : a > e.slides.length - r ? (e.loopFix(),
                        a = e.getSlideIndex(_y(n, `${s}[data-swiper-slide-index="${i}"]`)[0]),
                        uy(( () => {
                            e.slideTo(a)
                        }
                        ))) : e.slideTo(a)
                    } else
                        e.slideTo(a)
                }
            };
            var jy = {
                loopCreate: function(e) {
                    const t = this
                      , {params: n, slidesEl: r} = t;
                    if (!n.loop || t.virtual && t.params.virtual.enabled)
                        return;
                    const i = () => {
                        _y(r, `.${n.slideClass}, swiper-slide`).forEach(( (e, t) => {
                            e.setAttribute("data-swiper-slide-index", t)
                        }
                        ))
                    }
                      , a = t.grid && n.grid && n.grid.rows > 1
                      , s = n.slidesPerGroup * (a ? n.grid.rows : 1)
                      , o = t.slides.length % s != 0
                      , l = a && t.slides.length % n.grid.rows != 0
                      , c = e => {
                        for (let r = 0; r < e; r += 1) {
                            const e = t.isElement ? xy("swiper-slide", [n.slideBlankClass]) : xy("div", [n.slideClass, n.slideBlankClass]);
                            t.slidesEl.append(e)
                        }
                    }
                    ;
                    if (o) {
                        if (n.loopAddBlankSlides) {
                            c(s - t.slides.length % s),
                            t.recalcSlides(),
                            t.updateSlides()
                        } else
                            yy("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
                        i()
                    } else if (l) {
                        if (n.loopAddBlankSlides) {
                            c(n.grid.rows - t.slides.length % n.grid.rows),
                            t.recalcSlides(),
                            t.updateSlides()
                        } else
                            yy("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
                        i()
                    } else
                        i();
                    t.loopFix({
                        slideRealIndex: e,
                        direction: n.centeredSlides ? void 0 : "next"
                    })
                },
                loopFix: function(e) {
                    let {slideRealIndex: t, slideTo: n=!0, direction: r, setTranslate: i, activeSlideIndex: a, byController: s, byMousewheel: o} = void 0 === e ? {} : e;
                    const l = this;
                    if (!l.params.loop)
                        return;
                    l.emit("beforeLoopFix");
                    const {slides: c, allowSlidePrev: u, allowSlideNext: d, slidesEl: h, params: p} = l
                      , {centeredSlides: f} = p;
                    if (l.allowSlidePrev = !0,
                    l.allowSlideNext = !0,
                    l.virtual && p.virtual.enabled)
                        return n && (p.centeredSlides || 0 !== l.snapIndex ? p.centeredSlides && l.snapIndex < p.slidesPerView ? l.slideTo(l.virtual.slides.length + l.snapIndex, 0, !1, !0) : l.snapIndex === l.snapGrid.length - 1 && l.slideTo(l.virtual.slidesBefore, 0, !1, !0) : l.slideTo(l.virtual.slides.length, 0, !1, !0)),
                        l.allowSlidePrev = u,
                        l.allowSlideNext = d,
                        void l.emit("loopFix");
                    let m = p.slidesPerView;
                    "auto" === m ? m = l.slidesPerViewDynamic() : (m = Math.ceil(parseFloat(p.slidesPerView, 10)),
                    f && m % 2 == 0 && (m += 1));
                    const g = p.slidesPerGroupAuto ? m : p.slidesPerGroup;
                    let v = g;
                    v % g != 0 && (v += g - v % g),
                    v += p.loopAdditionalSlides,
                    l.loopedSlides = v;
                    const _ = l.grid && p.grid && p.grid.rows > 1;
                    c.length < m + v ? yy("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : _ && "row" === p.grid.fill && yy("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
                    const y = []
                      , x = [];
                    let b = l.activeIndex;
                    void 0 === a ? a = l.getSlideIndex(c.filter((e => e.classList.contains(p.slideActiveClass)))[0]) : b = a;
                    const E = "next" === r || !r
                      , S = "prev" === r || !r;
                    let w = 0
                      , M = 0;
                    const T = _ ? Math.ceil(c.length / p.grid.rows) : c.length
                      , A = (_ ? c[a].column : a) + (f && void 0 === i ? -m / 2 + .5 : 0);
                    if (A < v) {
                        w = Math.max(v - A, g);
                        for (let e = 0; e < v - A; e += 1) {
                            const t = e - Math.floor(e / T) * T;
                            if (_) {
                                const e = T - t - 1;
                                for (let t = c.length - 1; t >= 0; t -= 1)
                                    c[t].column === e && y.push(t)
                            } else
                                y.push(T - t - 1)
                        }
                    } else if (A + m > T - v) {
                        M = Math.max(A - (T - 2 * v), g);
                        for (let e = 0; e < M; e += 1) {
                            const t = e - Math.floor(e / T) * T;
                            _ ? c.forEach(( (e, n) => {
                                e.column === t && x.push(n)
                            }
                            )) : x.push(t)
                        }
                    }
                    if (l.__preventObserver__ = !0,
                    requestAnimationFrame(( () => {
                        l.__preventObserver__ = !1
                    }
                    )),
                    S && y.forEach((e => {
                        c[e].swiperLoopMoveDOM = !0,
                        h.prepend(c[e]),
                        c[e].swiperLoopMoveDOM = !1
                    }
                    )),
                    E && x.forEach((e => {
                        c[e].swiperLoopMoveDOM = !0,
                        h.append(c[e]),
                        c[e].swiperLoopMoveDOM = !1
                    }
                    )),
                    l.recalcSlides(),
                    "auto" === p.slidesPerView ? l.updateSlides() : _ && (y.length > 0 && S || x.length > 0 && E) && l.slides.forEach(( (e, t) => {
                        l.grid.updateSlide(t, e, l.slides)
                    }
                    )),
                    p.watchSlidesProgress && l.updateSlidesOffset(),
                    n)
                        if (y.length > 0 && S) {
                            if (void 0 === t) {
                                const e = l.slidesGrid[b]
                                  , t = l.slidesGrid[b + w] - e;
                                o ? l.setTranslate(l.translate - t) : (l.slideTo(b + Math.ceil(w), 0, !1, !0),
                                i && (l.touchEventsData.startTranslate = l.touchEventsData.startTranslate - t,
                                l.touchEventsData.currentTranslate = l.touchEventsData.currentTranslate - t))
                            } else if (i) {
                                const e = _ ? y.length / p.grid.rows : y.length;
                                l.slideTo(l.activeIndex + e, 0, !1, !0),
                                l.touchEventsData.currentTranslate = l.translate
                            }
                        } else if (x.length > 0 && E)
                            if (void 0 === t) {
                                const e = l.slidesGrid[b]
                                  , t = l.slidesGrid[b - M] - e;
                                o ? l.setTranslate(l.translate - t) : (l.slideTo(b - M, 0, !1, !0),
                                i && (l.touchEventsData.startTranslate = l.touchEventsData.startTranslate - t,
                                l.touchEventsData.currentTranslate = l.touchEventsData.currentTranslate - t))
                            } else {
                                const e = _ ? x.length / p.grid.rows : x.length;
                                l.slideTo(l.activeIndex - e, 0, !1, !0)
                            }
                    if (l.allowSlidePrev = u,
                    l.allowSlideNext = d,
                    l.controller && l.controller.control && !s) {
                        const e = {
                            slideRealIndex: t,
                            direction: r,
                            setTranslate: i,
                            activeSlideIndex: a,
                            byController: !0
                        };
                        Array.isArray(l.controller.control) ? l.controller.control.forEach((t => {
                            !t.destroyed && t.params.loop && t.loopFix({
                                ...e,
                                slideTo: t.params.slidesPerView === p.slidesPerView && n
                            })
                        }
                        )) : l.controller.control instanceof l.constructor && l.controller.control.params.loop && l.controller.control.loopFix({
                            ...e,
                            slideTo: l.controller.control.params.slidesPerView === p.slidesPerView && n
                        })
                    }
                    l.emit("loopFix")
                },
                loopDestroy: function() {
                    const e = this
                      , {params: t, slidesEl: n} = e;
                    if (!t.loop || e.virtual && e.params.virtual.enabled)
                        return;
                    e.recalcSlides();
                    const r = [];
                    e.slides.forEach((e => {
                        const t = void 0 === e.swiperSlideIndex ? 1 * e.getAttribute("data-swiper-slide-index") : e.swiperSlideIndex;
                        r[t] = e
                    }
                    )),
                    e.slides.forEach((e => {
                        e.removeAttribute("data-swiper-slide-index")
                    }
                    )),
                    r.forEach((e => {
                        n.append(e)
                    }
                    )),
                    e.recalcSlides(),
                    e.slideTo(e.realIndex, 0)
                }
            };
            function Xy(e, t, n) {
                const r = ly()
                  , {params: i} = e
                  , a = i.edgeSwipeDetection
                  , s = i.edgeSwipeThreshold;
                return !a || !(n <= s || n >= r.innerWidth - s) || "prevent" === a && (t.preventDefault(),
                !0)
            }
            function qy(e) {
                const t = this
                  , n = sy();
                let r = e;
                r.originalEvent && (r = r.originalEvent);
                const i = t.touchEventsData;
                if ("pointerdown" === r.type) {
                    if (null !== i.pointerId && i.pointerId !== r.pointerId)
                        return;
                    i.pointerId = r.pointerId
                } else
                    "touchstart" === r.type && 1 === r.targetTouches.length && (i.touchId = r.targetTouches[0].identifier);
                if ("touchstart" === r.type)
                    return void Xy(t, r, r.targetTouches[0].pageX);
                const {params: a, touches: s, enabled: o} = t;
                if (!o)
                    return;
                if (!a.simulateTouch && "mouse" === r.pointerType)
                    return;
                if (t.animating && a.preventInteractionOnTransition)
                    return;
                !t.animating && a.cssMode && a.loop && t.loopFix();
                let l = r.target;
                if ("wrapper" === a.touchEventsTarget && !function(e, t) {
                    const n = t.contains(e);
                    if (!n && t instanceof HTMLSlotElement)
                        return [...t.assignedElements()].includes(e);
                    return n
                }(l, t.wrapperEl))
                    return;
                if ("which"in r && 3 === r.which)
                    return;
                if ("button"in r && r.button > 0)
                    return;
                if (i.isTouched && i.isMoved)
                    return;
                const c = !!a.noSwipingClass && "" !== a.noSwipingClass
                  , u = r.composedPath ? r.composedPath() : r.path;
                c && r.target && r.target.shadowRoot && u && (l = u[0]);
                const d = a.noSwipingSelector ? a.noSwipingSelector : `.${a.noSwipingClass}`
                  , h = !(!r.target || !r.target.shadowRoot);
                if (a.noSwiping && (h ? function(e, t) {
                    return void 0 === t && (t = this),
                    function t(n) {
                        if (!n || n === sy() || n === ly())
                            return null;
                        n.assignedSlot && (n = n.assignedSlot);
                        const r = n.closest(e);
                        return r || n.getRootNode ? r || t(n.getRootNode().host) : null
                    }(t)
                }(d, l) : l.closest(d)))
                    return void (t.allowClick = !0);
                if (a.swipeHandler && !l.closest(a.swipeHandler))
                    return;
                s.currentX = r.pageX,
                s.currentY = r.pageY;
                const p = s.currentX
                  , f = s.currentY;
                if (!Xy(t, r, p))
                    return;
                Object.assign(i, {
                    isTouched: !0,
                    isMoved: !1,
                    allowTouchCallbacks: !0,
                    isScrolling: void 0,
                    startMoving: void 0
                }),
                s.startX = p,
                s.startY = f,
                i.touchStartTime = dy(),
                t.allowClick = !0,
                t.updateSize(),
                t.swipeDirection = void 0,
                a.threshold > 0 && (i.allowThresholdMove = !1);
                let m = !0;
                l.matches(i.focusableElements) && (m = !1,
                "SELECT" === l.nodeName && (i.isTouched = !1)),
                n.activeElement && n.activeElement.matches(i.focusableElements) && n.activeElement !== l && ("mouse" === r.pointerType || "mouse" !== r.pointerType && !l.matches(i.focusableElements)) && n.activeElement.blur();
                const g = m && t.allowTouchMove && a.touchStartPreventDefault;
                !a.touchStartForcePreventDefault && !g || l.isContentEditable || r.preventDefault(),
                a.freeMode && a.freeMode.enabled && t.freeMode && t.animating && !a.cssMode && t.freeMode.onTouchStart(),
                t.emit("touchStart", r)
            }
            function Yy(e) {
                const t = sy()
                  , n = this
                  , r = n.touchEventsData
                  , {params: i, touches: a, rtlTranslate: s, enabled: o} = n;
                if (!o)
                    return;
                if (!i.simulateTouch && "mouse" === e.pointerType)
                    return;
                let l, c = e;
                if (c.originalEvent && (c = c.originalEvent),
                "pointermove" === c.type) {
                    if (null !== r.touchId)
                        return;
                    if (c.pointerId !== r.pointerId)
                        return
                }
                if ("touchmove" === c.type) {
                    if (l = [...c.changedTouches].filter((e => e.identifier === r.touchId))[0],
                    !l || l.identifier !== r.touchId)
                        return
                } else
                    l = c;
                if (!r.isTouched)
                    return void (r.startMoving && r.isScrolling && n.emit("touchMoveOpposite", c));
                const u = l.pageX
                  , d = l.pageY;
                if (c.preventedByNestedSwiper)
                    return a.startX = u,
                    void (a.startY = d);
                if (!n.allowTouchMove)
                    return c.target.matches(r.focusableElements) || (n.allowClick = !1),
                    void (r.isTouched && (Object.assign(a, {
                        startX: u,
                        startY: d,
                        currentX: u,
                        currentY: d
                    }),
                    r.touchStartTime = dy()));
                if (i.touchReleaseOnEdges && !i.loop)
                    if (n.isVertical()) {
                        if (d < a.startY && n.translate <= n.maxTranslate() || d > a.startY && n.translate >= n.minTranslate())
                            return r.isTouched = !1,
                            void (r.isMoved = !1)
                    } else if (u < a.startX && n.translate <= n.maxTranslate() || u > a.startX && n.translate >= n.minTranslate())
                        return;
                if (t.activeElement && t.activeElement.matches(r.focusableElements) && t.activeElement !== c.target && "mouse" !== c.pointerType && t.activeElement.blur(),
                t.activeElement && c.target === t.activeElement && c.target.matches(r.focusableElements))
                    return r.isMoved = !0,
                    void (n.allowClick = !1);
                r.allowTouchCallbacks && n.emit("touchMove", c),
                a.previousX = a.currentX,
                a.previousY = a.currentY,
                a.currentX = u,
                a.currentY = d;
                const h = a.currentX - a.startX
                  , p = a.currentY - a.startY;
                if (n.params.threshold && Math.sqrt(h ** 2 + p ** 2) < n.params.threshold)
                    return;
                if (void 0 === r.isScrolling) {
                    let e;
                    n.isHorizontal() && a.currentY === a.startY || n.isVertical() && a.currentX === a.startX ? r.isScrolling = !1 : h * h + p * p >= 25 && (e = 180 * Math.atan2(Math.abs(p), Math.abs(h)) / Math.PI,
                    r.isScrolling = n.isHorizontal() ? e > i.touchAngle : 90 - e > i.touchAngle)
                }
                if (r.isScrolling && n.emit("touchMoveOpposite", c),
                void 0 === r.startMoving && (a.currentX === a.startX && a.currentY === a.startY || (r.startMoving = !0)),
                r.isScrolling || "touchmove" === c.type && r.preventTouchMoveFromPointerMove)
                    return void (r.isTouched = !1);
                if (!r.startMoving)
                    return;
                n.allowClick = !1,
                !i.cssMode && c.cancelable && c.preventDefault(),
                i.touchMoveStopPropagation && !i.nested && c.stopPropagation();
                let f = n.isHorizontal() ? h : p
                  , m = n.isHorizontal() ? a.currentX - a.previousX : a.currentY - a.previousY;
                i.oneWayMovement && (f = Math.abs(f) * (s ? 1 : -1),
                m = Math.abs(m) * (s ? 1 : -1)),
                a.diff = f,
                f *= i.touchRatio,
                s && (f = -f,
                m = -m);
                const g = n.touchesDirection;
                n.swipeDirection = f > 0 ? "prev" : "next",
                n.touchesDirection = m > 0 ? "prev" : "next";
                const v = n.params.loop && !i.cssMode
                  , _ = "next" === n.touchesDirection && n.allowSlideNext || "prev" === n.touchesDirection && n.allowSlidePrev;
                if (!r.isMoved) {
                    if (v && _ && n.loopFix({
                        direction: n.swipeDirection
                    }),
                    r.startTranslate = n.getTranslate(),
                    n.setTransition(0),
                    n.animating) {
                        const e = new window.CustomEvent("transitionend",{
                            bubbles: !0,
                            cancelable: !0,
                            detail: {
                                bySwiperTouchMove: !0
                            }
                        });
                        n.wrapperEl.dispatchEvent(e)
                    }
                    r.allowMomentumBounce = !1,
                    !i.grabCursor || !0 !== n.allowSlideNext && !0 !== n.allowSlidePrev || n.setGrabCursor(!0),
                    n.emit("sliderFirstMove", c)
                }
                if ((new Date).getTime(),
                r.isMoved && r.allowThresholdMove && g !== n.touchesDirection && v && _ && Math.abs(f) >= 1)
                    return Object.assign(a, {
                        startX: u,
                        startY: d,
                        currentX: u,
                        currentY: d,
                        startTranslate: r.currentTranslate
                    }),
                    r.loopSwapReset = !0,
                    void (r.startTranslate = r.currentTranslate);
                n.emit("sliderMove", c),
                r.isMoved = !0,
                r.currentTranslate = f + r.startTranslate;
                let y = !0
                  , x = i.resistanceRatio;
                if (i.touchReleaseOnEdges && (x = 0),
                f > 0 ? (v && _ && r.allowThresholdMove && r.currentTranslate > (i.centeredSlides ? n.minTranslate() - n.slidesSizesGrid[n.activeIndex + 1] - ("auto" !== i.slidesPerView && n.slides.length - i.slidesPerView >= 2 ? n.slidesSizesGrid[n.activeIndex + 1] + n.params.spaceBetween : 0) - n.params.spaceBetween : n.minTranslate()) && n.loopFix({
                    direction: "prev",
                    setTranslate: !0,
                    activeSlideIndex: 0
                }),
                r.currentTranslate > n.minTranslate() && (y = !1,
                i.resistance && (r.currentTranslate = n.minTranslate() - 1 + (-n.minTranslate() + r.startTranslate + f) ** x))) : f < 0 && (v && _ && r.allowThresholdMove && r.currentTranslate < (i.centeredSlides ? n.maxTranslate() + n.slidesSizesGrid[n.slidesSizesGrid.length - 1] + n.params.spaceBetween + ("auto" !== i.slidesPerView && n.slides.length - i.slidesPerView >= 2 ? n.slidesSizesGrid[n.slidesSizesGrid.length - 1] + n.params.spaceBetween : 0) : n.maxTranslate()) && n.loopFix({
                    direction: "next",
                    setTranslate: !0,
                    activeSlideIndex: n.slides.length - ("auto" === i.slidesPerView ? n.slidesPerViewDynamic() : Math.ceil(parseFloat(i.slidesPerView, 10)))
                }),
                r.currentTranslate < n.maxTranslate() && (y = !1,
                i.resistance && (r.currentTranslate = n.maxTranslate() + 1 - (n.maxTranslate() - r.startTranslate - f) ** x))),
                y && (c.preventedByNestedSwiper = !0),
                !n.allowSlideNext && "next" === n.swipeDirection && r.currentTranslate < r.startTranslate && (r.currentTranslate = r.startTranslate),
                !n.allowSlidePrev && "prev" === n.swipeDirection && r.currentTranslate > r.startTranslate && (r.currentTranslate = r.startTranslate),
                n.allowSlidePrev || n.allowSlideNext || (r.currentTranslate = r.startTranslate),
                i.threshold > 0) {
                    if (!(Math.abs(f) > i.threshold || r.allowThresholdMove))
                        return void (r.currentTranslate = r.startTranslate);
                    if (!r.allowThresholdMove)
                        return r.allowThresholdMove = !0,
                        a.startX = a.currentX,
                        a.startY = a.currentY,
                        r.currentTranslate = r.startTranslate,
                        void (a.diff = n.isHorizontal() ? a.currentX - a.startX : a.currentY - a.startY)
                }
                i.followFinger && !i.cssMode && ((i.freeMode && i.freeMode.enabled && n.freeMode || i.watchSlidesProgress) && (n.updateActiveIndex(),
                n.updateSlidesClasses()),
                i.freeMode && i.freeMode.enabled && n.freeMode && n.freeMode.onTouchMove(),
                n.updateProgress(r.currentTranslate),
                n.setTranslate(r.currentTranslate))
            }
            function $y(e) {
                const t = this
                  , n = t.touchEventsData;
                let r, i = e;
                i.originalEvent && (i = i.originalEvent);
                if ("touchend" === i.type || "touchcancel" === i.type) {
                    if (r = [...i.changedTouches].filter((e => e.identifier === n.touchId))[0],
                    !r || r.identifier !== n.touchId)
                        return
                } else {
                    if (null !== n.touchId)
                        return;
                    if (i.pointerId !== n.pointerId)
                        return;
                    r = i
                }
                if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(i.type)) {
                    if (!(["pointercancel", "contextmenu"].includes(i.type) && (t.browser.isSafari || t.browser.isWebView)))
                        return
                }
                n.pointerId = null,
                n.touchId = null;
                const {params: a, touches: s, rtlTranslate: o, slidesGrid: l, enabled: c} = t;
                if (!c)
                    return;
                if (!a.simulateTouch && "mouse" === i.pointerType)
                    return;
                if (n.allowTouchCallbacks && t.emit("touchEnd", i),
                n.allowTouchCallbacks = !1,
                !n.isTouched)
                    return n.isMoved && a.grabCursor && t.setGrabCursor(!1),
                    n.isMoved = !1,
                    void (n.startMoving = !1);
                a.grabCursor && n.isMoved && n.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1);
                const u = dy()
                  , d = u - n.touchStartTime;
                if (t.allowClick) {
                    const e = i.path || i.composedPath && i.composedPath();
                    t.updateClickedSlide(e && e[0] || i.target, e),
                    t.emit("tap click", i),
                    d < 300 && u - n.lastClickTime < 300 && t.emit("doubleTap doubleClick", i)
                }
                if (n.lastClickTime = dy(),
                uy(( () => {
                    t.destroyed || (t.allowClick = !0)
                }
                )),
                !n.isTouched || !n.isMoved || !t.swipeDirection || 0 === s.diff && !n.loopSwapReset || n.currentTranslate === n.startTranslate && !n.loopSwapReset)
                    return n.isTouched = !1,
                    n.isMoved = !1,
                    void (n.startMoving = !1);
                let h;
                if (n.isTouched = !1,
                n.isMoved = !1,
                n.startMoving = !1,
                h = a.followFinger ? o ? t.translate : -t.translate : -n.currentTranslate,
                a.cssMode)
                    return;
                if (a.freeMode && a.freeMode.enabled)
                    return void t.freeMode.onTouchEnd({
                        currentPos: h
                    });
                const p = h >= -t.maxTranslate() && !t.params.loop;
                let f = 0
                  , m = t.slidesSizesGrid[0];
                for (let e = 0; e < l.length; e += e < a.slidesPerGroupSkip ? 1 : a.slidesPerGroup) {
                    const t = e < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup;
                    void 0 !== l[e + t] ? (p || h >= l[e] && h < l[e + t]) && (f = e,
                    m = l[e + t] - l[e]) : (p || h >= l[e]) && (f = e,
                    m = l[l.length - 1] - l[l.length - 2])
                }
                let g = null
                  , v = null;
                a.rewind && (t.isBeginning ? v = a.virtual && a.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (g = 0));
                const _ = (h - l[f]) / m
                  , y = f < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup;
                if (d > a.longSwipesMs) {
                    if (!a.longSwipes)
                        return void t.slideTo(t.activeIndex);
                    "next" === t.swipeDirection && (_ >= a.longSwipesRatio ? t.slideTo(a.rewind && t.isEnd ? g : f + y) : t.slideTo(f)),
                    "prev" === t.swipeDirection && (_ > 1 - a.longSwipesRatio ? t.slideTo(f + y) : null !== v && _ < 0 && Math.abs(_) > a.longSwipesRatio ? t.slideTo(v) : t.slideTo(f))
                } else {
                    if (!a.shortSwipes)
                        return void t.slideTo(t.activeIndex);
                    t.navigation && (i.target === t.navigation.nextEl || i.target === t.navigation.prevEl) ? i.target === t.navigation.nextEl ? t.slideTo(f + y) : t.slideTo(f) : ("next" === t.swipeDirection && t.slideTo(null !== g ? g : f + y),
                    "prev" === t.swipeDirection && t.slideTo(null !== v ? v : f))
                }
            }
            function Ky() {
                const e = this
                  , {params: t, el: n} = e;
                if (n && 0 === n.offsetWidth)
                    return;
                t.breakpoints && e.setBreakpoint();
                const {allowSlideNext: r, allowSlidePrev: i, snapGrid: a} = e
                  , s = e.virtual && e.params.virtual.enabled;
                e.allowSlideNext = !0,
                e.allowSlidePrev = !0,
                e.updateSize(),
                e.updateSlides(),
                e.updateSlidesClasses();
                const o = s && t.loop;
                !("auto" === t.slidesPerView || t.slidesPerView > 1) || !e.isEnd || e.isBeginning || e.params.centeredSlides || o ? e.params.loop && !s ? e.slideToLoop(e.realIndex, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0) : e.slideTo(e.slides.length - 1, 0, !1, !0),
                e.autoplay && e.autoplay.running && e.autoplay.paused && (clearTimeout(e.autoplay.resizeTimeout),
                e.autoplay.resizeTimeout = setTimeout(( () => {
                    e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.resume()
                }
                ), 500)),
                e.allowSlidePrev = i,
                e.allowSlideNext = r,
                e.params.watchOverflow && a !== e.snapGrid && e.checkOverflow()
            }
            function Zy(e) {
                const t = this;
                t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(),
                t.params.preventClicksPropagation && t.animating && (e.stopPropagation(),
                e.stopImmediatePropagation())))
            }
            function Jy() {
                const e = this
                  , {wrapperEl: t, rtlTranslate: n, enabled: r} = e;
                if (!r)
                    return;
                let i;
                e.previousTranslate = e.translate,
                e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop,
                0 === e.translate && (e.translate = 0),
                e.updateActiveIndex(),
                e.updateSlidesClasses();
                const a = e.maxTranslate() - e.minTranslate();
                i = 0 === a ? 0 : (e.translate - e.minTranslate()) / a,
                i !== e.progress && e.updateProgress(n ? -e.translate : e.translate),
                e.emit("setTranslate", e.translate, !1)
            }
            function Qy(e) {
                const t = this;
                Fy(t, e.target),
                t.params.cssMode || "auto" !== t.params.slidesPerView && !t.params.autoHeight || t.update()
            }
            function ex() {
                const e = this;
                e.documentTouchHandlerProceeded || (e.documentTouchHandlerProceeded = !0,
                e.params.touchReleaseOnEdges && (e.el.style.touchAction = "auto"))
            }
            const tx = (e, t) => {
                const n = sy()
                  , {params: r, el: i, wrapperEl: a, device: s} = e
                  , o = !!r.nested
                  , l = "on" === t ? "addEventListener" : "removeEventListener"
                  , c = t;
                i && "string" != typeof i && (n[l]("touchstart", e.onDocumentTouchStart, {
                    passive: !1,
                    capture: o
                }),
                i[l]("touchstart", e.onTouchStart, {
                    passive: !1
                }),
                i[l]("pointerdown", e.onTouchStart, {
                    passive: !1
                }),
                n[l]("touchmove", e.onTouchMove, {
                    passive: !1,
                    capture: o
                }),
                n[l]("pointermove", e.onTouchMove, {
                    passive: !1,
                    capture: o
                }),
                n[l]("touchend", e.onTouchEnd, {
                    passive: !0
                }),
                n[l]("pointerup", e.onTouchEnd, {
                    passive: !0
                }),
                n[l]("pointercancel", e.onTouchEnd, {
                    passive: !0
                }),
                n[l]("touchcancel", e.onTouchEnd, {
                    passive: !0
                }),
                n[l]("pointerout", e.onTouchEnd, {
                    passive: !0
                }),
                n[l]("pointerleave", e.onTouchEnd, {
                    passive: !0
                }),
                n[l]("contextmenu", e.onTouchEnd, {
                    passive: !0
                }),
                (r.preventClicks || r.preventClicksPropagation) && i[l]("click", e.onClick, !0),
                r.cssMode && a[l]("scroll", e.onScroll),
                r.updateOnWindowResize ? e[c](s.ios || s.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", Ky, !0) : e[c]("observerUpdate", Ky, !0),
                i[l]("load", e.onLoad, {
                    capture: !0
                }))
            }
            ;
            const nx = (e, t) => e.grid && t.grid && t.grid.rows > 1;
            var rx = {
                init: !0,
                direction: "horizontal",
                oneWayMovement: !1,
                swiperElementNodeName: "SWIPER-CONTAINER",
                touchEventsTarget: "wrapper",
                initialSlide: 0,
                speed: 300,
                cssMode: !1,
                updateOnWindowResize: !0,
                resizeObserver: !0,
                nested: !1,
                createElements: !1,
                eventsPrefix: "swiper",
                enabled: !0,
                focusableElements: "input, select, option, textarea, button, video, label",
                width: null,
                height: null,
                preventInteractionOnTransition: !1,
                userAgent: null,
                url: null,
                edgeSwipeDetection: !1,
                edgeSwipeThreshold: 20,
                autoHeight: !1,
                setWrapperSize: !1,
                virtualTranslate: !1,
                effect: "slide",
                breakpoints: void 0,
                breakpointsBase: "window",
                spaceBetween: 0,
                slidesPerView: 1,
                slidesPerGroup: 1,
                slidesPerGroupSkip: 0,
                slidesPerGroupAuto: !1,
                centeredSlides: !1,
                centeredSlidesBounds: !1,
                slidesOffsetBefore: 0,
                slidesOffsetAfter: 0,
                normalizeSlideIndex: !0,
                centerInsufficientSlides: !1,
                watchOverflow: !0,
                roundLengths: !1,
                touchRatio: 1,
                touchAngle: 45,
                simulateTouch: !0,
                shortSwipes: !0,
                longSwipes: !0,
                longSwipesRatio: .5,
                longSwipesMs: 300,
                followFinger: !0,
                allowTouchMove: !0,
                threshold: 5,
                touchMoveStopPropagation: !1,
                touchStartPreventDefault: !0,
                touchStartForcePreventDefault: !1,
                touchReleaseOnEdges: !1,
                uniqueNavElements: !0,
                resistance: !0,
                resistanceRatio: .85,
                watchSlidesProgress: !1,
                grabCursor: !1,
                preventClicks: !0,
                preventClicksPropagation: !0,
                slideToClickedSlide: !1,
                loop: !1,
                loopAddBlankSlides: !0,
                loopAdditionalSlides: 0,
                loopPreventsSliding: !0,
                rewind: !1,
                allowSlidePrev: !0,
                allowSlideNext: !0,
                swipeHandler: null,
                noSwiping: !0,
                noSwipingClass: "swiper-no-swiping",
                noSwipingSelector: null,
                passiveListeners: !0,
                maxBackfaceHiddenSlides: 10,
                containerModifierClass: "swiper-",
                slideClass: "swiper-slide",
                slideBlankClass: "swiper-slide-blank",
                slideActiveClass: "swiper-slide-active",
                slideVisibleClass: "swiper-slide-visible",
                slideFullyVisibleClass: "swiper-slide-fully-visible",
                slideNextClass: "swiper-slide-next",
                slidePrevClass: "swiper-slide-prev",
                wrapperClass: "swiper-wrapper",
                lazyPreloaderClass: "swiper-lazy-preloader",
                lazyPreloadPrevNext: 0,
                runCallbacksOnInit: !0,
                _emitClasses: !1
            };
            function ix(e, t) {
                return function(n) {
                    void 0 === n && (n = {});
                    const r = Object.keys(n)[0]
                      , i = n[r];
                    "object" == typeof i && null !== i ? (!0 === e[r] && (e[r] = {
                        enabled: !0
                    }),
                    "navigation" === r && e[r] && e[r].enabled && !e[r].prevEl && !e[r].nextEl && (e[r].auto = !0),
                    ["pagination", "scrollbar"].indexOf(r) >= 0 && e[r] && e[r].enabled && !e[r].el && (e[r].auto = !0),
                    r in e && "enabled"in i ? ("object" != typeof e[r] || "enabled"in e[r] || (e[r].enabled = !0),
                    e[r] || (e[r] = {
                        enabled: !1
                    }),
                    fy(t, n)) : fy(t, n)) : fy(t, n)
                }
            }
            const ax = {
                eventsEmitter: Ny,
                update: Hy,
                translate: Gy,
                transition: {
                    setTransition: function(e, t) {
                        const n = this;
                        n.params.cssMode || (n.wrapperEl.style.transitionDuration = `${e}ms`,
                        n.wrapperEl.style.transitionDelay = 0 === e ? "0ms" : ""),
                        n.emit("setTransition", e, t)
                    },
                    transitionStart: function(e, t) {
                        void 0 === e && (e = !0);
                        const n = this
                          , {params: r} = n;
                        r.cssMode || (r.autoHeight && n.updateAutoHeight(),
                        Vy({
                            swiper: n,
                            runCallbacks: e,
                            direction: t,
                            step: "Start"
                        }))
                    },
                    transitionEnd: function(e, t) {
                        void 0 === e && (e = !0);
                        const n = this
                          , {params: r} = n;
                        n.animating = !1,
                        r.cssMode || (n.setTransition(0),
                        Vy({
                            swiper: n,
                            runCallbacks: e,
                            direction: t,
                            step: "End"
                        }))
                    }
                },
                slide: Wy,
                loop: jy,
                grabCursor: {
                    setGrabCursor: function(e) {
                        const t = this;
                        if (!t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode)
                            return;
                        const n = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl;
                        t.isElement && (t.__preventObserver__ = !0),
                        n.style.cursor = "move",
                        n.style.cursor = e ? "grabbing" : "grab",
                        t.isElement && requestAnimationFrame(( () => {
                            t.__preventObserver__ = !1
                        }
                        ))
                    },
                    unsetGrabCursor: function() {
                        const e = this;
                        e.params.watchOverflow && e.isLocked || e.params.cssMode || (e.isElement && (e.__preventObserver__ = !0),
                        e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "",
                        e.isElement && requestAnimationFrame(( () => {
                            e.__preventObserver__ = !1
                        }
                        )))
                    }
                },
                events: {
                    attachEvents: function() {
                        const e = this
                          , {params: t} = e;
                        e.onTouchStart = qy.bind(e),
                        e.onTouchMove = Yy.bind(e),
                        e.onTouchEnd = $y.bind(e),
                        e.onDocumentTouchStart = ex.bind(e),
                        t.cssMode && (e.onScroll = Jy.bind(e)),
                        e.onClick = Zy.bind(e),
                        e.onLoad = Qy.bind(e),
                        tx(e, "on")
                    },
                    detachEvents: function() {
                        tx(this, "off")
                    }
                },
                breakpoints: {
                    setBreakpoint: function() {
                        const e = this
                          , {realIndex: t, initialized: n, params: r, el: i} = e
                          , a = r.breakpoints;
                        if (!a || a && 0 === Object.keys(a).length)
                            return;
                        const s = e.getBreakpoint(a, e.params.breakpointsBase, e.el);
                        if (!s || e.currentBreakpoint === s)
                            return;
                        const o = (s in a ? a[s] : void 0) || e.originalParams
                          , l = nx(e, r)
                          , c = nx(e, o)
                          , u = e.params.grabCursor
                          , d = o.grabCursor
                          , h = r.enabled;
                        l && !c ? (i.classList.remove(`${r.containerModifierClass}grid`, `${r.containerModifierClass}grid-column`),
                        e.emitContainerClasses()) : !l && c && (i.classList.add(`${r.containerModifierClass}grid`),
                        (o.grid.fill && "column" === o.grid.fill || !o.grid.fill && "column" === r.grid.fill) && i.classList.add(`${r.containerModifierClass}grid-column`),
                        e.emitContainerClasses()),
                        u && !d ? e.unsetGrabCursor() : !u && d && e.setGrabCursor(),
                        ["navigation", "pagination", "scrollbar"].forEach((t => {
                            if (void 0 === o[t])
                                return;
                            const n = r[t] && r[t].enabled
                              , i = o[t] && o[t].enabled;
                            n && !i && e[t].disable(),
                            !n && i && e[t].enable()
                        }
                        ));
                        const p = o.direction && o.direction !== r.direction
                          , f = r.loop && (o.slidesPerView !== r.slidesPerView || p)
                          , m = r.loop;
                        p && n && e.changeDirection(),
                        fy(e.params, o);
                        const g = e.params.enabled
                          , v = e.params.loop;
                        Object.assign(e, {
                            allowTouchMove: e.params.allowTouchMove,
                            allowSlideNext: e.params.allowSlideNext,
                            allowSlidePrev: e.params.allowSlidePrev
                        }),
                        h && !g ? e.disable() : !h && g && e.enable(),
                        e.currentBreakpoint = s,
                        e.emit("_beforeBreakpoint", o),
                        n && (f ? (e.loopDestroy(),
                        e.loopCreate(t),
                        e.updateSlides()) : !m && v ? (e.loopCreate(t),
                        e.updateSlides()) : m && !v && e.loopDestroy()),
                        e.emit("breakpoint", o)
                    },
                    getBreakpoint: function(e, t, n) {
                        if (void 0 === t && (t = "window"),
                        !e || "container" === t && !n)
                            return;
                        let r = !1;
                        const i = ly()
                          , a = "window" === t ? i.innerHeight : n.clientHeight
                          , s = Object.keys(e).map((e => {
                            if ("string" == typeof e && 0 === e.indexOf("@")) {
                                const t = parseFloat(e.substr(1));
                                return {
                                    value: a * t,
                                    point: e
                                }
                            }
                            return {
                                value: e,
                                point: e
                            }
                        }
                        ));
                        s.sort(( (e, t) => parseInt(e.value, 10) - parseInt(t.value, 10)));
                        for (let e = 0; e < s.length; e += 1) {
                            const {point: a, value: o} = s[e];
                            "window" === t ? i.matchMedia(`(min-width: ${o}px)`).matches && (r = a) : o <= n.clientWidth && (r = a)
                        }
                        return r || "max"
                    }
                },
                checkOverflow: {
                    checkOverflow: function() {
                        const e = this
                          , {isLocked: t, params: n} = e
                          , {slidesOffsetBefore: r} = n;
                        if (r) {
                            const t = e.slides.length - 1
                              , n = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * r;
                            e.isLocked = e.size > n
                        } else
                            e.isLocked = 1 === e.snapGrid.length;
                        !0 === n.allowSlideNext && (e.allowSlideNext = !e.isLocked),
                        !0 === n.allowSlidePrev && (e.allowSlidePrev = !e.isLocked),
                        t && t !== e.isLocked && (e.isEnd = !1),
                        t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock")
                    }
                },
                classes: {
                    addClasses: function() {
                        const e = this
                          , {classNames: t, params: n, rtl: r, el: i, device: a} = e
                          , s = function(e, t) {
                            const n = [];
                            return e.forEach((e => {
                                "object" == typeof e ? Object.keys(e).forEach((r => {
                                    e[r] && n.push(t + r)
                                }
                                )) : "string" == typeof e && n.push(t + e)
                            }
                            )),
                            n
                        }(["initialized", n.direction, {
                            "free-mode": e.params.freeMode && n.freeMode.enabled
                        }, {
                            autoheight: n.autoHeight
                        }, {
                            rtl: r
                        }, {
                            grid: n.grid && n.grid.rows > 1
                        }, {
                            "grid-column": n.grid && n.grid.rows > 1 && "column" === n.grid.fill
                        }, {
                            android: a.android
                        }, {
                            ios: a.ios
                        }, {
                            "css-mode": n.cssMode
                        }, {
                            centered: n.cssMode && n.centeredSlides
                        }, {
                            "watch-progress": n.watchSlidesProgress
                        }], n.containerModifierClass);
                        t.push(...s),
                        i.classList.add(...t),
                        e.emitContainerClasses()
                    },
                    removeClasses: function() {
                        const {el: e, classNames: t} = this;
                        e && "string" != typeof e && (e.classList.remove(...t),
                        this.emitContainerClasses())
                    }
                }
            }
              , sx = {};
            class ox {
                constructor() {
                    let e, t;
                    for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++)
                        r[i] = arguments[i];
                    1 === r.length && r[0].constructor && "Object" === Object.prototype.toString.call(r[0]).slice(8, -1) ? t = r[0] : [e,t] = r,
                    t || (t = {}),
                    t = fy({}, t),
                    e && !t.el && (t.el = e);
                    const a = sy();
                    if (t.el && "string" == typeof t.el && a.querySelectorAll(t.el).length > 1) {
                        const e = [];
                        return a.querySelectorAll(t.el).forEach((n => {
                            const r = fy({}, t, {
                                el: n
                            });
                            e.push(new ox(r))
                        }
                        )),
                        e
                    }
                    const s = this;
                    s.__swiper__ = !0,
                    s.support = Oy(),
                    s.device = Dy({
                        userAgent: t.userAgent
                    }),
                    s.browser = Iy(),
                    s.eventsListeners = {},
                    s.eventsAnyListeners = [],
                    s.modules = [...s.__modules__],
                    t.modules && Array.isArray(t.modules) && s.modules.push(...t.modules);
                    const o = {};
                    s.modules.forEach((e => {
                        e({
                            params: t,
                            swiper: s,
                            extendParams: ix(t, o),
                            on: s.on.bind(s),
                            once: s.once.bind(s),
                            off: s.off.bind(s),
                            emit: s.emit.bind(s)
                        })
                    }
                    ));
                    const l = fy({}, rx, o);
                    return s.params = fy({}, l, sx, t),
                    s.originalParams = fy({}, s.params),
                    s.passedParams = fy({}, t),
                    s.params && s.params.on && Object.keys(s.params.on).forEach((e => {
                        s.on(e, s.params.on[e])
                    }
                    )),
                    s.params && s.params.onAny && s.onAny(s.params.onAny),
                    Object.assign(s, {
                        enabled: s.params.enabled,
                        el: e,
                        classNames: [],
                        slides: [],
                        slidesGrid: [],
                        snapGrid: [],
                        slidesSizesGrid: [],
                        isHorizontal() {
                            return "horizontal" === s.params.direction
                        },
                        isVertical() {
                            return "vertical" === s.params.direction
                        },
                        activeIndex: 0,
                        realIndex: 0,
                        isBeginning: !0,
                        isEnd: !1,
                        translate: 0,
                        previousTranslate: 0,
                        progress: 0,
                        velocity: 0,
                        animating: !1,
                        cssOverflowAdjustment() {
                            return Math.trunc(this.translate / 2 ** 23) * 2 ** 23
                        },
                        allowSlideNext: s.params.allowSlideNext,
                        allowSlidePrev: s.params.allowSlidePrev,
                        touchEventsData: {
                            isTouched: void 0,
                            isMoved: void 0,
                            allowTouchCallbacks: void 0,
                            touchStartTime: void 0,
                            isScrolling: void 0,
                            currentTranslate: void 0,
                            startTranslate: void 0,
                            allowThresholdMove: void 0,
                            focusableElements: s.params.focusableElements,
                            lastClickTime: 0,
                            clickTimeout: void 0,
                            velocities: [],
                            allowMomentumBounce: void 0,
                            startMoving: void 0,
                            pointerId: null,
                            touchId: null
                        },
                        allowClick: !0,
                        allowTouchMove: s.params.allowTouchMove,
                        touches: {
                            startX: 0,
                            startY: 0,
                            currentX: 0,
                            currentY: 0,
                            diff: 0
                        },
                        imagesToLoad: [],
                        imagesLoaded: 0
                    }),
                    s.emit("_swiper"),
                    s.params.init && s.init(),
                    s
                }
                getDirectionLabel(e) {
                    return this.isHorizontal() ? e : {
                        width: "height",
                        "margin-top": "margin-left",
                        "margin-bottom ": "margin-right",
                        "margin-left": "margin-top",
                        "margin-right": "margin-bottom",
                        "padding-left": "padding-top",
                        "padding-right": "padding-bottom",
                        marginRight: "marginBottom"
                    }[e]
                }
                getSlideIndex(e) {
                    const {slidesEl: t, params: n} = this
                      , r = Sy(_y(t, `.${n.slideClass}, swiper-slide`)[0]);
                    return Sy(e) - r
                }
                getSlideIndexByData(e) {
                    return this.getSlideIndex(this.slides.filter((t => 1 * t.getAttribute("data-swiper-slide-index") === e))[0])
                }
                recalcSlides() {
                    const {slidesEl: e, params: t} = this;
                    this.slides = _y(e, `.${t.slideClass}, swiper-slide`)
                }
                enable() {
                    const e = this;
                    e.enabled || (e.enabled = !0,
                    e.params.grabCursor && e.setGrabCursor(),
                    e.emit("enable"))
                }
                disable() {
                    const e = this;
                    e.enabled && (e.enabled = !1,
                    e.params.grabCursor && e.unsetGrabCursor(),
                    e.emit("disable"))
                }
                setProgress(e, t) {
                    const n = this;
                    e = Math.min(Math.max(e, 0), 1);
                    const r = n.minTranslate()
                      , i = (n.maxTranslate() - r) * e + r;
                    n.translateTo(i, void 0 === t ? 0 : t),
                    n.updateActiveIndex(),
                    n.updateSlidesClasses()
                }
                emitContainerClasses() {
                    const e = this;
                    if (!e.params._emitClasses || !e.el)
                        return;
                    const t = e.el.className.split(" ").filter((t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass)));
                    e.emit("_containerClasses", t.join(" "))
                }
                getSlideClasses(e) {
                    const t = this;
                    return t.destroyed ? "" : e.className.split(" ").filter((e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass))).join(" ")
                }
                emitSlidesClasses() {
                    const e = this;
                    if (!e.params._emitClasses || !e.el)
                        return;
                    const t = [];
                    e.slides.forEach((n => {
                        const r = e.getSlideClasses(n);
                        t.push({
                            slideEl: n,
                            classNames: r
                        }),
                        e.emit("_slideClass", n, r)
                    }
                    )),
                    e.emit("_slideClasses", t)
                }
                slidesPerViewDynamic(e, t) {
                    void 0 === e && (e = "current"),
                    void 0 === t && (t = !1);
                    const {params: n, slides: r, slidesGrid: i, slidesSizesGrid: a, size: s, activeIndex: o} = this;
                    let l = 1;
                    if ("number" == typeof n.slidesPerView)
                        return n.slidesPerView;
                    if (n.centeredSlides) {
                        let e, t = r[o] ? Math.ceil(r[o].swiperSlideSize) : 0;
                        for (let n = o + 1; n < r.length; n += 1)
                            r[n] && !e && (t += Math.ceil(r[n].swiperSlideSize),
                            l += 1,
                            t > s && (e = !0));
                        for (let n = o - 1; n >= 0; n -= 1)
                            r[n] && !e && (t += r[n].swiperSlideSize,
                            l += 1,
                            t > s && (e = !0))
                    } else if ("current" === e)
                        for (let e = o + 1; e < r.length; e += 1) {
                            (t ? i[e] + a[e] - i[o] < s : i[e] - i[o] < s) && (l += 1)
                        }
                    else
                        for (let e = o - 1; e >= 0; e -= 1) {
                            i[o] - i[e] < s && (l += 1)
                        }
                    return l
                }
                update() {
                    const e = this;
                    if (!e || e.destroyed)
                        return;
                    const {snapGrid: t, params: n} = e;
                    function r() {
                        const t = e.rtlTranslate ? -1 * e.translate : e.translate
                          , n = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate());
                        e.setTranslate(n),
                        e.updateActiveIndex(),
                        e.updateSlidesClasses()
                    }
                    let i;
                    if (n.breakpoints && e.setBreakpoint(),
                    [...e.el.querySelectorAll('[loading="lazy"]')].forEach((t => {
                        t.complete && Fy(e, t)
                    }
                    )),
                    e.updateSize(),
                    e.updateSlides(),
                    e.updateProgress(),
                    e.updateSlidesClasses(),
                    n.freeMode && n.freeMode.enabled && !n.cssMode)
                        r(),
                        n.autoHeight && e.updateAutoHeight();
                    else {
                        if (("auto" === n.slidesPerView || n.slidesPerView > 1) && e.isEnd && !n.centeredSlides) {
                            const t = e.virtual && n.virtual.enabled ? e.virtual.slides : e.slides;
                            i = e.slideTo(t.length - 1, 0, !1, !0)
                        } else
                            i = e.slideTo(e.activeIndex, 0, !1, !0);
                        i || r()
                    }
                    n.watchOverflow && t !== e.snapGrid && e.checkOverflow(),
                    e.emit("update")
                }
                changeDirection(e, t) {
                    void 0 === t && (t = !0);
                    const n = this
                      , r = n.params.direction;
                    return e || (e = "horizontal" === r ? "vertical" : "horizontal"),
                    e === r || "horizontal" !== e && "vertical" !== e || (n.el.classList.remove(`${n.params.containerModifierClass}${r}`),
                    n.el.classList.add(`${n.params.containerModifierClass}${e}`),
                    n.emitContainerClasses(),
                    n.params.direction = e,
                    n.slides.forEach((t => {
                        "vertical" === e ? t.style.width = "" : t.style.height = ""
                    }
                    )),
                    n.emit("changeDirection"),
                    t && n.update()),
                    n
                }
                changeLanguageDirection(e) {
                    const t = this;
                    t.rtl && "rtl" === e || !t.rtl && "ltr" === e || (t.rtl = "rtl" === e,
                    t.rtlTranslate = "horizontal" === t.params.direction && t.rtl,
                    t.rtl ? (t.el.classList.add(`${t.params.containerModifierClass}rtl`),
                    t.el.dir = "rtl") : (t.el.classList.remove(`${t.params.containerModifierClass}rtl`),
                    t.el.dir = "ltr"),
                    t.update())
                }
                mount(e) {
                    const t = this;
                    if (t.mounted)
                        return !0;
                    let n = e || t.params.el;
                    if ("string" == typeof n && (n = document.querySelector(n)),
                    !n)
                        return !1;
                    n.swiper = t,
                    n.parentNode && n.parentNode.host && n.parentNode.host.nodeName === t.params.swiperElementNodeName.toUpperCase() && (t.isElement = !0);
                    const r = () => `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`;
                    let i = ( () => {
                        if (n && n.shadowRoot && n.shadowRoot.querySelector) {
                            return n.shadowRoot.querySelector(r())
                        }
                        return _y(n, r())[0]
                    }
                    )();
                    return !i && t.params.createElements && (i = xy("div", t.params.wrapperClass),
                    n.append(i),
                    _y(n, `.${t.params.slideClass}`).forEach((e => {
                        i.append(e)
                    }
                    ))),
                    Object.assign(t, {
                        el: n,
                        wrapperEl: i,
                        slidesEl: t.isElement && !n.parentNode.host.slideSlots ? n.parentNode.host : i,
                        hostEl: t.isElement ? n.parentNode.host : n,
                        mounted: !0,
                        rtl: "rtl" === n.dir.toLowerCase() || "rtl" === Ey(n, "direction"),
                        rtlTranslate: "horizontal" === t.params.direction && ("rtl" === n.dir.toLowerCase() || "rtl" === Ey(n, "direction")),
                        wrongRTL: "-webkit-box" === Ey(i, "display")
                    }),
                    !0
                }
                init(e) {
                    const t = this;
                    if (t.initialized)
                        return t;
                    if (!1 === t.mount(e))
                        return t;
                    t.emit("beforeInit"),
                    t.params.breakpoints && t.setBreakpoint(),
                    t.addClasses(),
                    t.updateSize(),
                    t.updateSlides(),
                    t.params.watchOverflow && t.checkOverflow(),
                    t.params.grabCursor && t.enabled && t.setGrabCursor(),
                    t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0),
                    t.params.loop && t.loopCreate(),
                    t.attachEvents();
                    const n = [...t.el.querySelectorAll('[loading="lazy"]')];
                    return t.isElement && n.push(...t.hostEl.querySelectorAll('[loading="lazy"]')),
                    n.forEach((e => {
                        e.complete ? Fy(t, e) : e.addEventListener("load", (e => {
                            Fy(t, e.target)
                        }
                        ))
                    }
                    )),
                    By(t),
                    t.initialized = !0,
                    By(t),
                    t.emit("init"),
                    t.emit("afterInit"),
                    t
                }
                destroy(e, t) {
                    void 0 === e && (e = !0),
                    void 0 === t && (t = !0);
                    const n = this
                      , {params: r, el: i, wrapperEl: a, slides: s} = n;
                    return void 0 === n.params || n.destroyed || (n.emit("beforeDestroy"),
                    n.initialized = !1,
                    n.detachEvents(),
                    r.loop && n.loopDestroy(),
                    t && (n.removeClasses(),
                    i && "string" != typeof i && i.removeAttribute("style"),
                    a && a.removeAttribute("style"),
                    s && s.length && s.forEach((e => {
                        e.classList.remove(r.slideVisibleClass, r.slideFullyVisibleClass, r.slideActiveClass, r.slideNextClass, r.slidePrevClass),
                        e.removeAttribute("style"),
                        e.removeAttribute("data-swiper-slide-index")
                    }
                    ))),
                    n.emit("destroy"),
                    Object.keys(n.eventsListeners).forEach((e => {
                        n.off(e)
                    }
                    )),
                    !1 !== e && (n.el && "string" != typeof n.el && (n.el.swiper = null),
                    function(e) {
                        const t = e;
                        Object.keys(t).forEach((e => {
                            try {
                                t[e] = null
                            } catch (e) {}
                            try {
                                delete t[e]
                            } catch (e) {}
                        }
                        ))
                    }(n)),
                    n.destroyed = !0),
                    null
                }
                static extendDefaults(e) {
                    fy(sx, e)
                }
                static get extendedDefaults() {
                    return sx
                }
                static get defaults() {
                    return rx
                }
                static installModule(e) {
                    ox.prototype.__modules__ || (ox.prototype.__modules__ = []);
                    const t = ox.prototype.__modules__;
                    "function" == typeof e && t.indexOf(e) < 0 && t.push(e)
                }
                static use(e) {
                    return Array.isArray(e) ? (e.forEach((e => ox.installModule(e))),
                    ox) : (ox.installModule(e),
                    ox)
                }
            }
            function lx(e, t, n, r) {
                return e.params.createElements && Object.keys(r).forEach((i => {
                    if (!n[i] && !0 === n.auto) {
                        let a = _y(e.el, `.${r[i]}`)[0];
                        a || (a = xy("div", r[i]),
                        a.className = r[i],
                        e.el.append(a)),
                        n[i] = a,
                        t[i] = a
                    }
                }
                )),
                n
            }
            function cx(e) {
                return void 0 === e && (e = ""),
                `.${e.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")}`
            }
            function ux(e) {
                const t = this
                  , {params: n, slidesEl: r} = t;
                n.loop && t.loopDestroy();
                const i = e => {
                    if ("string" == typeof e) {
                        const t = document.createElement("div");
                        t.innerHTML = e,
                        r.append(t.children[0]),
                        t.innerHTML = ""
                    } else
                        r.append(e)
                }
                ;
                if ("object" == typeof e && "length"in e)
                    for (let t = 0; t < e.length; t += 1)
                        e[t] && i(e[t]);
                else
                    i(e);
                t.recalcSlides(),
                n.loop && t.loopCreate(),
                n.observer && !t.isElement || t.update()
            }
            function dx(e) {
                const t = this
                  , {params: n, activeIndex: r, slidesEl: i} = t;
                n.loop && t.loopDestroy();
                let a = r + 1;
                const s = e => {
                    if ("string" == typeof e) {
                        const t = document.createElement("div");
                        t.innerHTML = e,
                        i.prepend(t.children[0]),
                        t.innerHTML = ""
                    } else
                        i.prepend(e)
                }
                ;
                if ("object" == typeof e && "length"in e) {
                    for (let t = 0; t < e.length; t += 1)
                        e[t] && s(e[t]);
                    a = r + e.length
                } else
                    s(e);
                t.recalcSlides(),
                n.loop && t.loopCreate(),
                n.observer && !t.isElement || t.update(),
                t.slideTo(a, 0, !1)
            }
            function hx(e, t) {
                const n = this
                  , {params: r, activeIndex: i, slidesEl: a} = n;
                let s = i;
                r.loop && (s -= n.loopedSlides,
                n.loopDestroy(),
                n.recalcSlides());
                const o = n.slides.length;
                if (e <= 0)
                    return void n.prependSlide(t);
                if (e >= o)
                    return void n.appendSlide(t);
                let l = s > e ? s + 1 : s;
                const c = [];
                for (let t = o - 1; t >= e; t -= 1) {
                    const e = n.slides[t];
                    e.remove(),
                    c.unshift(e)
                }
                if ("object" == typeof t && "length"in t) {
                    for (let e = 0; e < t.length; e += 1)
                        t[e] && a.append(t[e]);
                    l = s > e ? s + t.length : s
                } else
                    a.append(t);
                for (let e = 0; e < c.length; e += 1)
                    a.append(c[e]);
                n.recalcSlides(),
                r.loop && n.loopCreate(),
                r.observer && !n.isElement || n.update(),
                r.loop ? n.slideTo(l + n.loopedSlides, 0, !1) : n.slideTo(l, 0, !1)
            }
            function px(e) {
                const t = this
                  , {params: n, activeIndex: r} = t;
                let i = r;
                n.loop && (i -= t.loopedSlides,
                t.loopDestroy());
                let a, s = i;
                if ("object" == typeof e && "length"in e) {
                    for (let n = 0; n < e.length; n += 1)
                        a = e[n],
                        t.slides[a] && t.slides[a].remove(),
                        a < s && (s -= 1);
                    s = Math.max(s, 0)
                } else
                    a = e,
                    t.slides[a] && t.slides[a].remove(),
                    a < s && (s -= 1),
                    s = Math.max(s, 0);
                t.recalcSlides(),
                n.loop && t.loopCreate(),
                n.observer && !t.isElement || t.update(),
                n.loop ? t.slideTo(s + t.loopedSlides, 0, !1) : t.slideTo(s, 0, !1)
            }
            function fx() {
                const e = this
                  , t = [];
                for (let n = 0; n < e.slides.length; n += 1)
                    t.push(n);
                e.removeSlide(t)
            }
            function mx(e) {
                const {effect: t, swiper: n, on: r, setTranslate: i, setTransition: a, overwriteParams: s, perspective: o, recreateShadows: l, getEffectParams: c} = e;
                let u;
                r("beforeInit", ( () => {
                    if (n.params.effect !== t)
                        return;
                    n.classNames.push(`${n.params.containerModifierClass}${t}`),
                    o && o() && n.classNames.push(`${n.params.containerModifierClass}3d`);
                    const e = s ? s() : {};
                    Object.assign(n.params, e),
                    Object.assign(n.originalParams, e)
                }
                )),
                r("setTranslate", ( () => {
                    n.params.effect === t && i()
                }
                )),
                r("setTransition", ( (e, r) => {
                    n.params.effect === t && a(r)
                }
                )),
                r("transitionEnd", ( () => {
                    if (n.params.effect === t && l) {
                        if (!c || !c().slideShadows)
                            return;
                        n.slides.forEach((e => {
                            e.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((e => e.remove()))
                        }
                        )),
                        l()
                    }
                }
                )),
                r("virtualUpdate", ( () => {
                    n.params.effect === t && (n.slides.length || (u = !0),
                    requestAnimationFrame(( () => {
                        u && n.slides && n.slides.length && (i(),
                        u = !1)
                    }
                    )))
                }
                ))
            }
            function gx(e, t) {
                const n = vy(t);
                return n !== t && (n.style.backfaceVisibility = "hidden",
                n.style["-webkit-backface-visibility"] = "hidden"),
                n
            }
            function vx(e) {
                let {swiper: t, duration: n, transformElements: r, allSlides: i} = e;
                const {activeIndex: a} = t;
                if (t.params.virtualTranslate && 0 !== n) {
                    let e, n = !1;
                    e = i ? r : r.filter((e => {
                        const n = e.classList.contains("swiper-slide-transform") ? (e => {
                            if (!e.parentElement)
                                return t.slides.filter((t => t.shadowRoot && t.shadowRoot === e.parentNode))[0];
                            return e.parentElement
                        }
                        )(e) : e;
                        return t.getSlideIndex(n) === a
                    }
                    )),
                    e.forEach((e => {
                        My(e, ( () => {
                            if (n)
                                return;
                            if (!t || t.destroyed)
                                return;
                            n = !0,
                            t.animating = !1;
                            const e = new window.CustomEvent("transitionend",{
                                bubbles: !0,
                                cancelable: !0
                            });
                            t.wrapperEl.dispatchEvent(e)
                        }
                        ))
                    }
                    ))
                }
            }
            function _x(e, t, n) {
                const r = `swiper-slide-shadow${n ? `-${n}` : ""}${e ? ` swiper-slide-shadow-${e}` : ""}`
                  , i = vy(t);
                let a = i.querySelector(`.${r.split(" ").join(".")}`);
                return a || (a = xy("div", r.split(" ")),
                i.append(a)),
                a
            }
            Object.keys(ax).forEach((e => {
                Object.keys(ax[e]).forEach((t => {
                    ox.prototype[t] = ax[e][t]
                }
                ))
            }
            )),
            ox.use([function(e) {
                let {swiper: t, on: n, emit: r} = e;
                const i = ly();
                let a = null
                  , s = null;
                const o = () => {
                    t && !t.destroyed && t.initialized && (r("beforeResize"),
                    r("resize"))
                }
                  , l = () => {
                    t && !t.destroyed && t.initialized && r("orientationchange")
                }
                ;
                n("init", ( () => {
                    t.params.resizeObserver && void 0 !== i.ResizeObserver ? t && !t.destroyed && t.initialized && (a = new ResizeObserver((e => {
                        s = i.requestAnimationFrame(( () => {
                            const {width: n, height: r} = t;
                            let i = n
                              , a = r;
                            e.forEach((e => {
                                let {contentBoxSize: n, contentRect: r, target: s} = e;
                                s && s !== t.el || (i = r ? r.width : (n[0] || n).inlineSize,
                                a = r ? r.height : (n[0] || n).blockSize)
                            }
                            )),
                            i === n && a === r || o()
                        }
                        ))
                    }
                    )),
                    a.observe(t.el)) : (i.addEventListener("resize", o),
                    i.addEventListener("orientationchange", l))
                }
                )),
                n("destroy", ( () => {
                    s && i.cancelAnimationFrame(s),
                    a && a.unobserve && t.el && (a.unobserve(t.el),
                    a = null),
                    i.removeEventListener("resize", o),
                    i.removeEventListener("orientationchange", l)
                }
                ))
            }
            , function(e) {
                let {swiper: t, extendParams: n, on: r, emit: i} = e;
                const a = []
                  , s = ly()
                  , o = function(e, n) {
                    void 0 === n && (n = {});
                    const r = new (s.MutationObserver || s.WebkitMutationObserver)((e => {
                        if (t.__preventObserver__)
                            return;
                        if (1 === e.length)
                            return void i("observerUpdate", e[0]);
                        const n = function() {
                            i("observerUpdate", e[0])
                        };
                        s.requestAnimationFrame ? s.requestAnimationFrame(n) : s.setTimeout(n, 0)
                    }
                    ));
                    r.observe(e, {
                        attributes: void 0 === n.attributes || n.attributes,
                        childList: t.isElement || (void 0 === n.childList || n).childList,
                        characterData: void 0 === n.characterData || n.characterData
                    }),
                    a.push(r)
                };
                n({
                    observer: !1,
                    observeParents: !1,
                    observeSlideChildren: !1
                }),
                r("init", ( () => {
                    if (t.params.observer) {
                        if (t.params.observeParents) {
                            const e = wy(t.hostEl);
                            for (let t = 0; t < e.length; t += 1)
                                o(e[t])
                        }
                        o(t.hostEl, {
                            childList: t.params.observeSlideChildren
                        }),
                        o(t.wrapperEl, {
                            attributes: !1
                        })
                    }
                }
                )),
                r("destroy", ( () => {
                    a.forEach((e => {
                        e.disconnect()
                    }
                    )),
                    a.splice(0, a.length)
                }
                ))
            }
            ]);
            const yx = [function(e) {
                let t, {swiper: n, extendParams: r, on: i, emit: a} = e;
                r({
                    virtual: {
                        enabled: !1,
                        slides: [],
                        cache: !0,
                        renderSlide: null,
                        renderExternal: null,
                        renderExternalUpdate: !0,
                        addSlidesBefore: 0,
                        addSlidesAfter: 0
                    }
                });
                const s = sy();
                n.virtual = {
                    cache: {},
                    from: void 0,
                    to: void 0,
                    slides: [],
                    offset: 0,
                    slidesGrid: []
                };
                const o = s.createElement("div");
                function l(e, t) {
                    const r = n.params.virtual;
                    if (r.cache && n.virtual.cache[t])
                        return n.virtual.cache[t];
                    let i;
                    return r.renderSlide ? (i = r.renderSlide.call(n, e, t),
                    "string" == typeof i && (o.innerHTML = i,
                    i = o.children[0])) : i = n.isElement ? xy("swiper-slide") : xy("div", n.params.slideClass),
                    i.setAttribute("data-swiper-slide-index", t),
                    r.renderSlide || (i.innerHTML = e),
                    r.cache && (n.virtual.cache[t] = i),
                    i
                }
                function c(e, t) {
                    const {slidesPerView: r, slidesPerGroup: i, centeredSlides: s, loop: o, initialSlide: c} = n.params;
                    if (t && !o && c > 0)
                        return;
                    const {addSlidesBefore: u, addSlidesAfter: d} = n.params.virtual
                      , {from: h, to: p, slides: f, slidesGrid: m, offset: g} = n.virtual;
                    n.params.cssMode || n.updateActiveIndex();
                    const v = n.activeIndex || 0;
                    let _, y, x;
                    _ = n.rtlTranslate ? "right" : n.isHorizontal() ? "left" : "top",
                    s ? (y = Math.floor(r / 2) + i + d,
                    x = Math.floor(r / 2) + i + u) : (y = r + (i - 1) + d,
                    x = (o ? r : i) + u);
                    let b = v - x
                      , E = v + y;
                    o || (b = Math.max(b, 0),
                    E = Math.min(E, f.length - 1));
                    let S = (n.slidesGrid[b] || 0) - (n.slidesGrid[0] || 0);
                    function w() {
                        n.updateSlides(),
                        n.updateProgress(),
                        n.updateSlidesClasses(),
                        a("virtualUpdate")
                    }
                    if (o && v >= x ? (b -= x,
                    s || (S += n.slidesGrid[0])) : o && v < x && (b = -x,
                    s && (S += n.slidesGrid[0])),
                    Object.assign(n.virtual, {
                        from: b,
                        to: E,
                        offset: S,
                        slidesGrid: n.slidesGrid,
                        slidesBefore: x,
                        slidesAfter: y
                    }),
                    h === b && p === E && !e)
                        return n.slidesGrid !== m && S !== g && n.slides.forEach((e => {
                            e.style[_] = S - Math.abs(n.cssOverflowAdjustment()) + "px"
                        }
                        )),
                        n.updateProgress(),
                        void a("virtualUpdate");
                    if (n.params.virtual.renderExternal)
                        return n.params.virtual.renderExternal.call(n, {
                            offset: S,
                            from: b,
                            to: E,
                            slides: function() {
                                const e = [];
                                for (let t = b; t <= E; t += 1)
                                    e.push(f[t]);
                                return e
                            }()
                        }),
                        void (n.params.virtual.renderExternalUpdate ? w() : a("virtualUpdate"));
                    const M = []
                      , T = []
                      , A = e => {
                        let t = e;
                        return e < 0 ? t = f.length + e : t >= f.length && (t -= f.length),
                        t
                    }
                    ;
                    if (e)
                        n.slides.filter((e => e.matches(`.${n.params.slideClass}, swiper-slide`))).forEach((e => {
                            e.remove()
                        }
                        ));
                    else
                        for (let e = h; e <= p; e += 1)
                            if (e < b || e > E) {
                                const t = A(e);
                                n.slides.filter((e => e.matches(`.${n.params.slideClass}[data-swiper-slide-index="${t}"], swiper-slide[data-swiper-slide-index="${t}"]`))).forEach((e => {
                                    e.remove()
                                }
                                ))
                            }
                    const C = o ? -f.length : 0
                      , P = o ? 2 * f.length : f.length;
                    for (let t = C; t < P; t += 1)
                        if (t >= b && t <= E) {
                            const n = A(t);
                            void 0 === p || e ? T.push(n) : (t > p && T.push(n),
                            t < h && M.push(n))
                        }
                    if (T.forEach((e => {
                        n.slidesEl.append(l(f[e], e))
                    }
                    )),
                    o)
                        for (let e = M.length - 1; e >= 0; e -= 1) {
                            const t = M[e];
                            n.slidesEl.prepend(l(f[t], t))
                        }
                    else
                        M.sort(( (e, t) => t - e)),
                        M.forEach((e => {
                            n.slidesEl.prepend(l(f[e], e))
                        }
                        ));
                    _y(n.slidesEl, ".swiper-slide, swiper-slide").forEach((e => {
                        e.style[_] = S - Math.abs(n.cssOverflowAdjustment()) + "px"
                    }
                    )),
                    w()
                }
                i("beforeInit", ( () => {
                    if (!n.params.virtual.enabled)
                        return;
                    let e;
                    if (void 0 === n.passedParams.virtual.slides) {
                        const t = [...n.slidesEl.children].filter((e => e.matches(`.${n.params.slideClass}, swiper-slide`)));
                        t && t.length && (n.virtual.slides = [...t],
                        e = !0,
                        t.forEach(( (e, t) => {
                            e.setAttribute("data-swiper-slide-index", t),
                            n.virtual.cache[t] = e,
                            e.remove()
                        }
                        )))
                    }
                    e || (n.virtual.slides = n.params.virtual.slides),
                    n.classNames.push(`${n.params.containerModifierClass}virtual`),
                    n.params.watchSlidesProgress = !0,
                    n.originalParams.watchSlidesProgress = !0,
                    c(!1, !0)
                }
                )),
                i("setTranslate", ( () => {
                    n.params.virtual.enabled && (n.params.cssMode && !n._immediateVirtual ? (clearTimeout(t),
                    t = setTimeout(( () => {
                        c()
                    }
                    ), 100)) : c())
                }
                )),
                i("init update resize", ( () => {
                    n.params.virtual.enabled && n.params.cssMode && my(n.wrapperEl, "--swiper-virtual-size", `${n.virtualSize}px`)
                }
                )),
                Object.assign(n.virtual, {
                    appendSlide: function(e) {
                        if ("object" == typeof e && "length"in e)
                            for (let t = 0; t < e.length; t += 1)
                                e[t] && n.virtual.slides.push(e[t]);
                        else
                            n.virtual.slides.push(e);
                        c(!0)
                    },
                    prependSlide: function(e) {
                        const t = n.activeIndex;
                        let r = t + 1
                          , i = 1;
                        if (Array.isArray(e)) {
                            for (let t = 0; t < e.length; t += 1)
                                e[t] && n.virtual.slides.unshift(e[t]);
                            r = t + e.length,
                            i = e.length
                        } else
                            n.virtual.slides.unshift(e);
                        if (n.params.virtual.cache) {
                            const e = n.virtual.cache
                              , t = {};
                            Object.keys(e).forEach((n => {
                                const r = e[n]
                                  , a = r.getAttribute("data-swiper-slide-index");
                                a && r.setAttribute("data-swiper-slide-index", parseInt(a, 10) + i),
                                t[parseInt(n, 10) + i] = r
                            }
                            )),
                            n.virtual.cache = t
                        }
                        c(!0),
                        n.slideTo(r, 0)
                    },
                    removeSlide: function(e) {
                        if (null == e)
                            return;
                        let t = n.activeIndex;
                        if (Array.isArray(e))
                            for (let r = e.length - 1; r >= 0; r -= 1)
                                n.params.virtual.cache && (delete n.virtual.cache[e[r]],
                                Object.keys(n.virtual.cache).forEach((t => {
                                    t > e && (n.virtual.cache[t - 1] = n.virtual.cache[t],
                                    n.virtual.cache[t - 1].setAttribute("data-swiper-slide-index", t - 1),
                                    delete n.virtual.cache[t])
                                }
                                ))),
                                n.virtual.slides.splice(e[r], 1),
                                e[r] < t && (t -= 1),
                                t = Math.max(t, 0);
                        else
                            n.params.virtual.cache && (delete n.virtual.cache[e],
                            Object.keys(n.virtual.cache).forEach((t => {
                                t > e && (n.virtual.cache[t - 1] = n.virtual.cache[t],
                                n.virtual.cache[t - 1].setAttribute("data-swiper-slide-index", t - 1),
                                delete n.virtual.cache[t])
                            }
                            ))),
                            n.virtual.slides.splice(e, 1),
                            e < t && (t -= 1),
                            t = Math.max(t, 0);
                        c(!0),
                        n.slideTo(t, 0)
                    },
                    removeAllSlides: function() {
                        n.virtual.slides = [],
                        n.params.virtual.cache && (n.virtual.cache = {}),
                        c(!0),
                        n.slideTo(0, 0)
                    },
                    update: c
                })
            }
            , function(e) {
                let {swiper: t, extendParams: n, on: r, emit: i} = e;
                const a = sy()
                  , s = ly();
                function o(e) {
                    if (!t.enabled)
                        return;
                    const {rtlTranslate: n} = t;
                    let r = e;
                    r.originalEvent && (r = r.originalEvent);
                    const o = r.keyCode || r.charCode
                      , l = t.params.keyboard.pageUpDown
                      , c = l && 33 === o
                      , u = l && 34 === o
                      , d = 37 === o
                      , h = 39 === o
                      , p = 38 === o
                      , f = 40 === o;
                    if (!t.allowSlideNext && (t.isHorizontal() && h || t.isVertical() && f || u))
                        return !1;
                    if (!t.allowSlidePrev && (t.isHorizontal() && d || t.isVertical() && p || c))
                        return !1;
                    if (!(r.shiftKey || r.altKey || r.ctrlKey || r.metaKey || a.activeElement && a.activeElement.nodeName && ("input" === a.activeElement.nodeName.toLowerCase() || "textarea" === a.activeElement.nodeName.toLowerCase()))) {
                        if (t.params.keyboard.onlyInViewport && (c || u || d || h || p || f)) {
                            let e = !1;
                            if (wy(t.el, `.${t.params.slideClass}, swiper-slide`).length > 0 && 0 === wy(t.el, `.${t.params.slideActiveClass}`).length)
                                return;
                            const r = t.el
                              , i = r.clientWidth
                              , a = r.clientHeight
                              , o = s.innerWidth
                              , l = s.innerHeight
                              , c = by(r);
                            n && (c.left -= r.scrollLeft);
                            const u = [[c.left, c.top], [c.left + i, c.top], [c.left, c.top + a], [c.left + i, c.top + a]];
                            for (let t = 0; t < u.length; t += 1) {
                                const n = u[t];
                                if (n[0] >= 0 && n[0] <= o && n[1] >= 0 && n[1] <= l) {
                                    if (0 === n[0] && 0 === n[1])
                                        continue;
                                    e = !0
                                }
                            }
                            if (!e)
                                return
                        }
                        t.isHorizontal() ? ((c || u || d || h) && (r.preventDefault ? r.preventDefault() : r.returnValue = !1),
                        ((u || h) && !n || (c || d) && n) && t.slideNext(),
                        ((c || d) && !n || (u || h) && n) && t.slidePrev()) : ((c || u || p || f) && (r.preventDefault ? r.preventDefault() : r.returnValue = !1),
                        (u || f) && t.slideNext(),
                        (c || p) && t.slidePrev()),
                        i("keyPress", o)
                    }
                }
                function l() {
                    t.keyboard.enabled || (a.addEventListener("keydown", o),
                    t.keyboard.enabled = !0)
                }
                function c() {
                    t.keyboard.enabled && (a.removeEventListener("keydown", o),
                    t.keyboard.enabled = !1)
                }
                t.keyboard = {
                    enabled: !1
                },
                n({
                    keyboard: {
                        enabled: !1,
                        onlyInViewport: !0,
                        pageUpDown: !0
                    }
                }),
                r("init", ( () => {
                    t.params.keyboard.enabled && l()
                }
                )),
                r("destroy", ( () => {
                    t.keyboard.enabled && c()
                }
                )),
                Object.assign(t.keyboard, {
                    enable: l,
                    disable: c
                })
            }
            , function(e) {
                let {swiper: t, extendParams: n, on: r, emit: i} = e;
                const a = ly();
                let s;
                n({
                    mousewheel: {
                        enabled: !1,
                        releaseOnEdges: !1,
                        invert: !1,
                        forceToAxis: !1,
                        sensitivity: 1,
                        eventsTarget: "container",
                        thresholdDelta: null,
                        thresholdTime: null,
                        noMousewheelClass: "swiper-no-mousewheel"
                    }
                }),
                t.mousewheel = {
                    enabled: !1
                };
                let o, l = dy();
                const c = [];
                function u() {
                    t.enabled && (t.mouseEntered = !0)
                }
                function d() {
                    t.enabled && (t.mouseEntered = !1)
                }
                function h(e) {
                    return !(t.params.mousewheel.thresholdDelta && e.delta < t.params.mousewheel.thresholdDelta) && (!(t.params.mousewheel.thresholdTime && dy() - l < t.params.mousewheel.thresholdTime) && (e.delta >= 6 && dy() - l < 60 || (e.direction < 0 ? t.isEnd && !t.params.loop || t.animating || (t.slideNext(),
                    i("scroll", e.raw)) : t.isBeginning && !t.params.loop || t.animating || (t.slidePrev(),
                    i("scroll", e.raw)),
                    l = (new a.Date).getTime(),
                    !1)))
                }
                function p(e) {
                    let n = e
                      , r = !0;
                    if (!t.enabled)
                        return;
                    if (e.target.closest(`.${t.params.mousewheel.noMousewheelClass}`))
                        return;
                    const a = t.params.mousewheel;
                    t.params.cssMode && n.preventDefault();
                    let l = t.el;
                    "container" !== t.params.mousewheel.eventsTarget && (l = document.querySelector(t.params.mousewheel.eventsTarget));
                    const u = l && l.contains(n.target);
                    if (!t.mouseEntered && !u && !a.releaseOnEdges)
                        return !0;
                    n.originalEvent && (n = n.originalEvent);
                    let d = 0;
                    const p = t.rtlTranslate ? -1 : 1
                      , f = function(e) {
                        let t = 0
                          , n = 0
                          , r = 0
                          , i = 0;
                        return "detail"in e && (n = e.detail),
                        "wheelDelta"in e && (n = -e.wheelDelta / 120),
                        "wheelDeltaY"in e && (n = -e.wheelDeltaY / 120),
                        "wheelDeltaX"in e && (t = -e.wheelDeltaX / 120),
                        "axis"in e && e.axis === e.HORIZONTAL_AXIS && (t = n,
                        n = 0),
                        r = 10 * t,
                        i = 10 * n,
                        "deltaY"in e && (i = e.deltaY),
                        "deltaX"in e && (r = e.deltaX),
                        e.shiftKey && !r && (r = i,
                        i = 0),
                        (r || i) && e.deltaMode && (1 === e.deltaMode ? (r *= 40,
                        i *= 40) : (r *= 800,
                        i *= 800)),
                        r && !t && (t = r < 1 ? -1 : 1),
                        i && !n && (n = i < 1 ? -1 : 1),
                        {
                            spinX: t,
                            spinY: n,
                            pixelX: r,
                            pixelY: i
                        }
                    }(n);
                    if (a.forceToAxis)
                        if (t.isHorizontal()) {
                            if (!(Math.abs(f.pixelX) > Math.abs(f.pixelY)))
                                return !0;
                            d = -f.pixelX * p
                        } else {
                            if (!(Math.abs(f.pixelY) > Math.abs(f.pixelX)))
                                return !0;
                            d = -f.pixelY
                        }
                    else
                        d = Math.abs(f.pixelX) > Math.abs(f.pixelY) ? -f.pixelX * p : -f.pixelY;
                    if (0 === d)
                        return !0;
                    a.invert && (d = -d);
                    let m = t.getTranslate() + d * a.sensitivity;
                    if (m >= t.minTranslate() && (m = t.minTranslate()),
                    m <= t.maxTranslate() && (m = t.maxTranslate()),
                    r = !!t.params.loop || !(m === t.minTranslate() || m === t.maxTranslate()),
                    r && t.params.nested && n.stopPropagation(),
                    t.params.freeMode && t.params.freeMode.enabled) {
                        const e = {
                            time: dy(),
                            delta: Math.abs(d),
                            direction: Math.sign(d)
                        }
                          , r = o && e.time < o.time + 500 && e.delta <= o.delta && e.direction === o.direction;
                        if (!r) {
                            o = void 0;
                            let l = t.getTranslate() + d * a.sensitivity;
                            const u = t.isBeginning
                              , h = t.isEnd;
                            if (l >= t.minTranslate() && (l = t.minTranslate()),
                            l <= t.maxTranslate() && (l = t.maxTranslate()),
                            t.setTransition(0),
                            t.setTranslate(l),
                            t.updateProgress(),
                            t.updateActiveIndex(),
                            t.updateSlidesClasses(),
                            (!u && t.isBeginning || !h && t.isEnd) && t.updateSlidesClasses(),
                            t.params.loop && t.loopFix({
                                direction: e.direction < 0 ? "next" : "prev",
                                byMousewheel: !0
                            }),
                            t.params.freeMode.sticky) {
                                clearTimeout(s),
                                s = void 0,
                                c.length >= 15 && c.shift();
                                const n = c.length ? c[c.length - 1] : void 0
                                  , r = c[0];
                                if (c.push(e),
                                n && (e.delta > n.delta || e.direction !== n.direction))
                                    c.splice(0);
                                else if (c.length >= 15 && e.time - r.time < 500 && r.delta - e.delta >= 1 && e.delta <= 6) {
                                    const n = d > 0 ? .8 : .2;
                                    o = e,
                                    c.splice(0),
                                    s = uy(( () => {
                                        !t.destroyed && t.params && t.slideToClosest(t.params.speed, !0, void 0, n)
                                    }
                                    ), 0)
                                }
                                s || (s = uy(( () => {
                                    if (t.destroyed || !t.params)
                                        return;
                                    o = e,
                                    c.splice(0),
                                    t.slideToClosest(t.params.speed, !0, void 0, .5)
                                }
                                ), 500))
                            }
                            if (r || i("scroll", n),
                            t.params.autoplay && t.params.autoplayDisableOnInteraction && t.autoplay.stop(),
                            a.releaseOnEdges && (l === t.minTranslate() || l === t.maxTranslate()))
                                return !0
                        }
                    } else {
                        const n = {
                            time: dy(),
                            delta: Math.abs(d),
                            direction: Math.sign(d),
                            raw: e
                        };
                        c.length >= 2 && c.shift();
                        const r = c.length ? c[c.length - 1] : void 0;
                        if (c.push(n),
                        r ? (n.direction !== r.direction || n.delta > r.delta || n.time > r.time + 150) && h(n) : h(n),
                        function(e) {
                            const n = t.params.mousewheel;
                            if (e.direction < 0) {
                                if (t.isEnd && !t.params.loop && n.releaseOnEdges)
                                    return !0
                            } else if (t.isBeginning && !t.params.loop && n.releaseOnEdges)
                                return !0;
                            return !1
                        }(n))
                            return !0
                    }
                    return n.preventDefault ? n.preventDefault() : n.returnValue = !1,
                    !1
                }
                function f(e) {
                    let n = t.el;
                    "container" !== t.params.mousewheel.eventsTarget && (n = document.querySelector(t.params.mousewheel.eventsTarget)),
                    n[e]("mouseenter", u),
                    n[e]("mouseleave", d),
                    n[e]("wheel", p)
                }
                function m() {
                    return t.params.cssMode ? (t.wrapperEl.removeEventListener("wheel", p),
                    !0) : !t.mousewheel.enabled && (f("addEventListener"),
                    t.mousewheel.enabled = !0,
                    !0)
                }
                function g() {
                    return t.params.cssMode ? (t.wrapperEl.addEventListener(event, p),
                    !0) : !!t.mousewheel.enabled && (f("removeEventListener"),
                    t.mousewheel.enabled = !1,
                    !0)
                }
                r("init", ( () => {
                    !t.params.mousewheel.enabled && t.params.cssMode && g(),
                    t.params.mousewheel.enabled && m()
                }
                )),
                r("destroy", ( () => {
                    t.params.cssMode && m(),
                    t.mousewheel.enabled && g()
                }
                )),
                Object.assign(t.mousewheel, {
                    enable: m,
                    disable: g
                })
            }
            , function(e) {
                let {swiper: t, extendParams: n, on: r, emit: i} = e;
                function a(e) {
                    let n;
                    return e && "string" == typeof e && t.isElement && (n = t.el.querySelector(e) || t.hostEl.querySelector(e),
                    n) ? n : (e && ("string" == typeof e && (n = [...document.querySelectorAll(e)]),
                    t.params.uniqueNavElements && "string" == typeof e && n && n.length > 1 && 1 === t.el.querySelectorAll(e).length ? n = t.el.querySelector(e) : n && 1 === n.length && (n = n[0])),
                    e && !n ? e : n)
                }
                function s(e, n) {
                    const r = t.params.navigation;
                    (e = Ay(e)).forEach((e => {
                        e && (e.classList[n ? "add" : "remove"](...r.disabledClass.split(" ")),
                        "BUTTON" === e.tagName && (e.disabled = n),
                        t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? "add" : "remove"](r.lockClass))
                    }
                    ))
                }
                function o() {
                    const {nextEl: e, prevEl: n} = t.navigation;
                    if (t.params.loop)
                        return s(n, !1),
                        void s(e, !1);
                    s(n, t.isBeginning && !t.params.rewind),
                    s(e, t.isEnd && !t.params.rewind)
                }
                function l(e) {
                    e.preventDefault(),
                    (!t.isBeginning || t.params.loop || t.params.rewind) && (t.slidePrev(),
                    i("navigationPrev"))
                }
                function c(e) {
                    e.preventDefault(),
                    (!t.isEnd || t.params.loop || t.params.rewind) && (t.slideNext(),
                    i("navigationNext"))
                }
                function u() {
                    const e = t.params.navigation;
                    if (t.params.navigation = lx(t, t.originalParams.navigation, t.params.navigation, {
                        nextEl: "swiper-button-next",
                        prevEl: "swiper-button-prev"
                    }),
                    !e.nextEl && !e.prevEl)
                        return;
                    let n = a(e.nextEl)
                      , r = a(e.prevEl);
                    Object.assign(t.navigation, {
                        nextEl: n,
                        prevEl: r
                    }),
                    n = Ay(n),
                    r = Ay(r);
                    const i = (n, r) => {
                        n && n.addEventListener("click", "next" === r ? c : l),
                        !t.enabled && n && n.classList.add(...e.lockClass.split(" "))
                    }
                    ;
                    n.forEach((e => i(e, "next"))),
                    r.forEach((e => i(e, "prev")))
                }
                function d() {
                    let {nextEl: e, prevEl: n} = t.navigation;
                    e = Ay(e),
                    n = Ay(n);
                    const r = (e, n) => {
                        e.removeEventListener("click", "next" === n ? c : l),
                        e.classList.remove(...t.params.navigation.disabledClass.split(" "))
                    }
                    ;
                    e.forEach((e => r(e, "next"))),
                    n.forEach((e => r(e, "prev")))
                }
                n({
                    navigation: {
                        nextEl: null,
                        prevEl: null,
                        hideOnClick: !1,
                        disabledClass: "swiper-button-disabled",
                        hiddenClass: "swiper-button-hidden",
                        lockClass: "swiper-button-lock",
                        navigationDisabledClass: "swiper-navigation-disabled"
                    }
                }),
                t.navigation = {
                    nextEl: null,
                    prevEl: null
                },
                r("init", ( () => {
                    !1 === t.params.navigation.enabled ? h() : (u(),
                    o())
                }
                )),
                r("toEdge fromEdge lock unlock", ( () => {
                    o()
                }
                )),
                r("destroy", ( () => {
                    d()
                }
                )),
                r("enable disable", ( () => {
                    let {nextEl: e, prevEl: n} = t.navigation;
                    e = Ay(e),
                    n = Ay(n),
                    t.enabled ? o() : [...e, ...n].filter((e => !!e)).forEach((e => e.classList.add(t.params.navigation.lockClass)))
                }
                )),
                r("click", ( (e, n) => {
                    let {nextEl: r, prevEl: a} = t.navigation;
                    r = Ay(r),
                    a = Ay(a);
                    const s = n.target;
                    let o = a.includes(s) || r.includes(s);
                    if (t.isElement && !o) {
                        const e = n.path || n.composedPath && n.composedPath();
                        e && (o = e.find((e => r.includes(e) || a.includes(e))))
                    }
                    if (t.params.navigation.hideOnClick && !o) {
                        if (t.pagination && t.params.pagination && t.params.pagination.clickable && (t.pagination.el === s || t.pagination.el.contains(s)))
                            return;
                        let e;
                        r.length ? e = r[0].classList.contains(t.params.navigation.hiddenClass) : a.length && (e = a[0].classList.contains(t.params.navigation.hiddenClass)),
                        i(!0 === e ? "navigationShow" : "navigationHide"),
                        [...r, ...a].filter((e => !!e)).forEach((e => e.classList.toggle(t.params.navigation.hiddenClass)))
                    }
                }
                ));
                const h = () => {
                    t.el.classList.add(...t.params.navigation.navigationDisabledClass.split(" ")),
                    d()
                }
                ;
                Object.assign(t.navigation, {
                    enable: () => {
                        t.el.classList.remove(...t.params.navigation.navigationDisabledClass.split(" ")),
                        u(),
                        o()
                    }
                    ,
                    disable: h,
                    update: o,
                    init: u,
                    destroy: d
                })
            }
            , function(e) {
                let {swiper: t, extendParams: n, on: r, emit: i} = e;
                const a = "swiper-pagination";
                let s;
                n({
                    pagination: {
                        el: null,
                        bulletElement: "span",
                        clickable: !1,
                        hideOnClick: !1,
                        renderBullet: null,
                        renderProgressbar: null,
                        renderFraction: null,
                        renderCustom: null,
                        progressbarOpposite: !1,
                        type: "bullets",
                        dynamicBullets: !1,
                        dynamicMainBullets: 1,
                        formatFractionCurrent: e => e,
                        formatFractionTotal: e => e,
                        bulletClass: `${a}-bullet`,
                        bulletActiveClass: `${a}-bullet-active`,
                        modifierClass: `${a}-`,
                        currentClass: `${a}-current`,
                        totalClass: `${a}-total`,
                        hiddenClass: `${a}-hidden`,
                        progressbarFillClass: `${a}-progressbar-fill`,
                        progressbarOppositeClass: `${a}-progressbar-opposite`,
                        clickableClass: `${a}-clickable`,
                        lockClass: `${a}-lock`,
                        horizontalClass: `${a}-horizontal`,
                        verticalClass: `${a}-vertical`,
                        paginationDisabledClass: `${a}-disabled`
                    }
                }),
                t.pagination = {
                    el: null,
                    bullets: []
                };
                let o = 0;
                function l() {
                    return !t.params.pagination.el || !t.pagination.el || Array.isArray(t.pagination.el) && 0 === t.pagination.el.length
                }
                function c(e, n) {
                    const {bulletActiveClass: r} = t.params.pagination;
                    e && (e = e[("prev" === n ? "previous" : "next") + "ElementSibling"]) && (e.classList.add(`${r}-${n}`),
                    (e = e[("prev" === n ? "previous" : "next") + "ElementSibling"]) && e.classList.add(`${r}-${n}-${n}`))
                }
                function u(e) {
                    const n = e.target.closest(cx(t.params.pagination.bulletClass));
                    if (!n)
                        return;
                    e.preventDefault();
                    const r = Sy(n) * t.params.slidesPerGroup;
                    if (t.params.loop) {
                        if (t.realIndex === r)
                            return;
                        const e = (i = t.realIndex,
                        a = r,
                        s = t.slides.length,
                        (a %= s) == 1 + (i %= s) ? "next" : a === i - 1 ? "previous" : void 0);
                        "next" === e ? t.slideNext() : "previous" === e ? t.slidePrev() : t.slideToLoop(r)
                    } else
                        t.slideTo(r);
                    var i, a, s
                }
                function d() {
                    const e = t.rtl
                      , n = t.params.pagination;
                    if (l())
                        return;
                    let r, a, u = t.pagination.el;
                    u = Ay(u);
                    const d = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length
                      , h = t.params.loop ? Math.ceil(d / t.params.slidesPerGroup) : t.snapGrid.length;
                    if (t.params.loop ? (a = t.previousRealIndex || 0,
                    r = t.params.slidesPerGroup > 1 ? Math.floor(t.realIndex / t.params.slidesPerGroup) : t.realIndex) : void 0 !== t.snapIndex ? (r = t.snapIndex,
                    a = t.previousSnapIndex) : (a = t.previousIndex || 0,
                    r = t.activeIndex || 0),
                    "bullets" === n.type && t.pagination.bullets && t.pagination.bullets.length > 0) {
                        const i = t.pagination.bullets;
                        let l, d, h;
                        if (n.dynamicBullets && (s = Ty(i[0], t.isHorizontal() ? "width" : "height", !0),
                        u.forEach((e => {
                            e.style[t.isHorizontal() ? "width" : "height"] = s * (n.dynamicMainBullets + 4) + "px"
                        }
                        )),
                        n.dynamicMainBullets > 1 && void 0 !== a && (o += r - (a || 0),
                        o > n.dynamicMainBullets - 1 ? o = n.dynamicMainBullets - 1 : o < 0 && (o = 0)),
                        l = Math.max(r - o, 0),
                        d = l + (Math.min(i.length, n.dynamicMainBullets) - 1),
                        h = (d + l) / 2),
                        i.forEach((e => {
                            const t = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((e => `${n.bulletActiveClass}${e}`))].map((e => "string" == typeof e && e.includes(" ") ? e.split(" ") : e)).flat();
                            e.classList.remove(...t)
                        }
                        )),
                        u.length > 1)
                            i.forEach((e => {
                                const i = Sy(e);
                                i === r ? e.classList.add(...n.bulletActiveClass.split(" ")) : t.isElement && e.setAttribute("part", "bullet"),
                                n.dynamicBullets && (i >= l && i <= d && e.classList.add(...`${n.bulletActiveClass}-main`.split(" ")),
                                i === l && c(e, "prev"),
                                i === d && c(e, "next"))
                            }
                            ));
                        else {
                            const e = i[r];
                            if (e && e.classList.add(...n.bulletActiveClass.split(" ")),
                            t.isElement && i.forEach(( (e, t) => {
                                e.setAttribute("part", t === r ? "bullet-active" : "bullet")
                            }
                            )),
                            n.dynamicBullets) {
                                const e = i[l]
                                  , t = i[d];
                                for (let e = l; e <= d; e += 1)
                                    i[e] && i[e].classList.add(...`${n.bulletActiveClass}-main`.split(" "));
                                c(e, "prev"),
                                c(t, "next")
                            }
                        }
                        if (n.dynamicBullets) {
                            const r = Math.min(i.length, n.dynamicMainBullets + 4)
                              , a = (s * r - s) / 2 - h * s
                              , o = e ? "right" : "left";
                            i.forEach((e => {
                                e.style[t.isHorizontal() ? o : "top"] = `${a}px`
                            }
                            ))
                        }
                    }
                    u.forEach(( (e, a) => {
                        if ("fraction" === n.type && (e.querySelectorAll(cx(n.currentClass)).forEach((e => {
                            e.textContent = n.formatFractionCurrent(r + 1)
                        }
                        )),
                        e.querySelectorAll(cx(n.totalClass)).forEach((e => {
                            e.textContent = n.formatFractionTotal(h)
                        }
                        ))),
                        "progressbar" === n.type) {
                            let i;
                            i = n.progressbarOpposite ? t.isHorizontal() ? "vertical" : "horizontal" : t.isHorizontal() ? "horizontal" : "vertical";
                            const a = (r + 1) / h;
                            let s = 1
                              , o = 1;
                            "horizontal" === i ? s = a : o = a,
                            e.querySelectorAll(cx(n.progressbarFillClass)).forEach((e => {
                                e.style.transform = `translate3d(0,0,0) scaleX(${s}) scaleY(${o})`,
                                e.style.transitionDuration = `${t.params.speed}ms`
                            }
                            ))
                        }
                        "custom" === n.type && n.renderCustom ? (e.innerHTML = n.renderCustom(t, r + 1, h),
                        0 === a && i("paginationRender", e)) : (0 === a && i("paginationRender", e),
                        i("paginationUpdate", e)),
                        t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? "add" : "remove"](n.lockClass)
                    }
                    ))
                }
                function h() {
                    const e = t.params.pagination;
                    if (l())
                        return;
                    const n = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.grid && t.params.grid.rows > 1 ? t.slides.length / Math.ceil(t.params.grid.rows) : t.slides.length;
                    let r = t.pagination.el;
                    r = Ay(r);
                    let a = "";
                    if ("bullets" === e.type) {
                        let r = t.params.loop ? Math.ceil(n / t.params.slidesPerGroup) : t.snapGrid.length;
                        t.params.freeMode && t.params.freeMode.enabled && r > n && (r = n);
                        for (let n = 0; n < r; n += 1)
                            e.renderBullet ? a += e.renderBullet.call(t, n, e.bulletClass) : a += `<${e.bulletElement} ${t.isElement ? 'part="bullet"' : ""} class="${e.bulletClass}"></${e.bulletElement}>`
                    }
                    "fraction" === e.type && (a = e.renderFraction ? e.renderFraction.call(t, e.currentClass, e.totalClass) : `<span class="${e.currentClass}"></span> / <span class="${e.totalClass}"></span>`),
                    "progressbar" === e.type && (a = e.renderProgressbar ? e.renderProgressbar.call(t, e.progressbarFillClass) : `<span class="${e.progressbarFillClass}"></span>`),
                    t.pagination.bullets = [],
                    r.forEach((n => {
                        "custom" !== e.type && (n.innerHTML = a || ""),
                        "bullets" === e.type && t.pagination.bullets.push(...n.querySelectorAll(cx(e.bulletClass)))
                    }
                    )),
                    "custom" !== e.type && i("paginationRender", r[0])
                }
                function p() {
                    t.params.pagination = lx(t, t.originalParams.pagination, t.params.pagination, {
                        el: "swiper-pagination"
                    });
                    const e = t.params.pagination;
                    if (!e.el)
                        return;
                    let n;
                    "string" == typeof e.el && t.isElement && (n = t.el.querySelector(e.el)),
                    n || "string" != typeof e.el || (n = [...document.querySelectorAll(e.el)]),
                    n || (n = e.el),
                    n && 0 !== n.length && (t.params.uniqueNavElements && "string" == typeof e.el && Array.isArray(n) && n.length > 1 && (n = [...t.el.querySelectorAll(e.el)],
                    n.length > 1 && (n = n.filter((e => wy(e, ".swiper")[0] === t.el))[0])),
                    Array.isArray(n) && 1 === n.length && (n = n[0]),
                    Object.assign(t.pagination, {
                        el: n
                    }),
                    n = Ay(n),
                    n.forEach((n => {
                        "bullets" === e.type && e.clickable && n.classList.add(...(e.clickableClass || "").split(" ")),
                        n.classList.add(e.modifierClass + e.type),
                        n.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass),
                        "bullets" === e.type && e.dynamicBullets && (n.classList.add(`${e.modifierClass}${e.type}-dynamic`),
                        o = 0,
                        e.dynamicMainBullets < 1 && (e.dynamicMainBullets = 1)),
                        "progressbar" === e.type && e.progressbarOpposite && n.classList.add(e.progressbarOppositeClass),
                        e.clickable && n.addEventListener("click", u),
                        t.enabled || n.classList.add(e.lockClass)
                    }
                    )))
                }
                function f() {
                    const e = t.params.pagination;
                    if (l())
                        return;
                    let n = t.pagination.el;
                    n && (n = Ay(n),
                    n.forEach((n => {
                        n.classList.remove(e.hiddenClass),
                        n.classList.remove(e.modifierClass + e.type),
                        n.classList.remove(t.isHorizontal() ? e.horizontalClass : e.verticalClass),
                        e.clickable && (n.classList.remove(...(e.clickableClass || "").split(" ")),
                        n.removeEventListener("click", u))
                    }
                    ))),
                    t.pagination.bullets && t.pagination.bullets.forEach((t => t.classList.remove(...e.bulletActiveClass.split(" "))))
                }
                r("changeDirection", ( () => {
                    if (!t.pagination || !t.pagination.el)
                        return;
                    const e = t.params.pagination;
                    let {el: n} = t.pagination;
                    n = Ay(n),
                    n.forEach((n => {
                        n.classList.remove(e.horizontalClass, e.verticalClass),
                        n.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass)
                    }
                    ))
                }
                )),
                r("init", ( () => {
                    !1 === t.params.pagination.enabled ? m() : (p(),
                    h(),
                    d())
                }
                )),
                r("activeIndexChange", ( () => {
                    void 0 === t.snapIndex && d()
                }
                )),
                r("snapIndexChange", ( () => {
                    d()
                }
                )),
                r("snapGridLengthChange", ( () => {
                    h(),
                    d()
                }
                )),
                r("destroy", ( () => {
                    f()
                }
                )),
                r("enable disable", ( () => {
                    let {el: e} = t.pagination;
                    e && (e = Ay(e),
                    e.forEach((e => e.classList[t.enabled ? "remove" : "add"](t.params.pagination.lockClass))))
                }
                )),
                r("lock unlock", ( () => {
                    d()
                }
                )),
                r("click", ( (e, n) => {
                    const r = n.target
                      , a = Ay(t.pagination.el);
                    if (t.params.pagination.el && t.params.pagination.hideOnClick && a && a.length > 0 && !r.classList.contains(t.params.pagination.bulletClass)) {
                        if (t.navigation && (t.navigation.nextEl && r === t.navigation.nextEl || t.navigation.prevEl && r === t.navigation.prevEl))
                            return;
                        const e = a[0].classList.contains(t.params.pagination.hiddenClass);
                        i(!0 === e ? "paginationShow" : "paginationHide"),
                        a.forEach((e => e.classList.toggle(t.params.pagination.hiddenClass)))
                    }
                }
                ));
                const m = () => {
                    t.el.classList.add(t.params.pagination.paginationDisabledClass);
                    let {el: e} = t.pagination;
                    e && (e = Ay(e),
                    e.forEach((e => e.classList.add(t.params.pagination.paginationDisabledClass)))),
                    f()
                }
                ;
                Object.assign(t.pagination, {
                    enable: () => {
                        t.el.classList.remove(t.params.pagination.paginationDisabledClass);
                        let {el: e} = t.pagination;
                        e && (e = Ay(e),
                        e.forEach((e => e.classList.remove(t.params.pagination.paginationDisabledClass)))),
                        p(),
                        h(),
                        d()
                    }
                    ,
                    disable: m,
                    render: h,
                    update: d,
                    init: p,
                    destroy: f
                })
            }
            , function(e) {
                let {swiper: t, extendParams: n, on: r, emit: i} = e;
                const a = sy();
                let s, o, l, c, u = !1, d = null, h = null;
                function p() {
                    if (!t.params.scrollbar.el || !t.scrollbar.el)
                        return;
                    const {scrollbar: e, rtlTranslate: n} = t
                      , {dragEl: r, el: i} = e
                      , a = t.params.scrollbar
                      , s = t.params.loop ? t.progressLoop : t.progress;
                    let c = o
                      , u = (l - o) * s;
                    n ? (u = -u,
                    u > 0 ? (c = o - u,
                    u = 0) : -u + o > l && (c = l + u)) : u < 0 ? (c = o + u,
                    u = 0) : u + o > l && (c = l - u),
                    t.isHorizontal() ? (r.style.transform = `translate3d(${u}px, 0, 0)`,
                    r.style.width = `${c}px`) : (r.style.transform = `translate3d(0px, ${u}px, 0)`,
                    r.style.height = `${c}px`),
                    a.hide && (clearTimeout(d),
                    i.style.opacity = 1,
                    d = setTimeout(( () => {
                        i.style.opacity = 0,
                        i.style.transitionDuration = "400ms"
                    }
                    ), 1e3))
                }
                function f() {
                    if (!t.params.scrollbar.el || !t.scrollbar.el)
                        return;
                    const {scrollbar: e} = t
                      , {dragEl: n, el: r} = e;
                    n.style.width = "",
                    n.style.height = "",
                    l = t.isHorizontal() ? r.offsetWidth : r.offsetHeight,
                    c = t.size / (t.virtualSize + t.params.slidesOffsetBefore - (t.params.centeredSlides ? t.snapGrid[0] : 0)),
                    o = "auto" === t.params.scrollbar.dragSize ? l * c : parseInt(t.params.scrollbar.dragSize, 10),
                    t.isHorizontal() ? n.style.width = `${o}px` : n.style.height = `${o}px`,
                    r.style.display = c >= 1 ? "none" : "",
                    t.params.scrollbar.hide && (r.style.opacity = 0),
                    t.params.watchOverflow && t.enabled && e.el.classList[t.isLocked ? "add" : "remove"](t.params.scrollbar.lockClass)
                }
                function m(e) {
                    return t.isHorizontal() ? e.clientX : e.clientY
                }
                function g(e) {
                    const {scrollbar: n, rtlTranslate: r} = t
                      , {el: i} = n;
                    let a;
                    a = (m(e) - by(i)[t.isHorizontal() ? "left" : "top"] - (null !== s ? s : o / 2)) / (l - o),
                    a = Math.max(Math.min(a, 1), 0),
                    r && (a = 1 - a);
                    const c = t.minTranslate() + (t.maxTranslate() - t.minTranslate()) * a;
                    t.updateProgress(c),
                    t.setTranslate(c),
                    t.updateActiveIndex(),
                    t.updateSlidesClasses()
                }
                function v(e) {
                    const n = t.params.scrollbar
                      , {scrollbar: r, wrapperEl: a} = t
                      , {el: o, dragEl: l} = r;
                    u = !0,
                    s = e.target === l ? m(e) - e.target.getBoundingClientRect()[t.isHorizontal() ? "left" : "top"] : null,
                    e.preventDefault(),
                    e.stopPropagation(),
                    a.style.transitionDuration = "100ms",
                    l.style.transitionDuration = "100ms",
                    g(e),
                    clearTimeout(h),
                    o.style.transitionDuration = "0ms",
                    n.hide && (o.style.opacity = 1),
                    t.params.cssMode && (t.wrapperEl.style["scroll-snap-type"] = "none"),
                    i("scrollbarDragStart", e)
                }
                function _(e) {
                    const {scrollbar: n, wrapperEl: r} = t
                      , {el: a, dragEl: s} = n;
                    u && (e.preventDefault && e.cancelable ? e.preventDefault() : e.returnValue = !1,
                    g(e),
                    r.style.transitionDuration = "0ms",
                    a.style.transitionDuration = "0ms",
                    s.style.transitionDuration = "0ms",
                    i("scrollbarDragMove", e))
                }
                function y(e) {
                    const n = t.params.scrollbar
                      , {scrollbar: r, wrapperEl: a} = t
                      , {el: s} = r;
                    u && (u = !1,
                    t.params.cssMode && (t.wrapperEl.style["scroll-snap-type"] = "",
                    a.style.transitionDuration = ""),
                    n.hide && (clearTimeout(h),
                    h = uy(( () => {
                        s.style.opacity = 0,
                        s.style.transitionDuration = "400ms"
                    }
                    ), 1e3)),
                    i("scrollbarDragEnd", e),
                    n.snapOnRelease && t.slideToClosest())
                }
                function x(e) {
                    const {scrollbar: n, params: r} = t
                      , i = n.el;
                    if (!i)
                        return;
                    const s = i
                      , o = !!r.passiveListeners && {
                        passive: !1,
                        capture: !1
                    }
                      , l = !!r.passiveListeners && {
                        passive: !0,
                        capture: !1
                    };
                    if (!s)
                        return;
                    const c = "on" === e ? "addEventListener" : "removeEventListener";
                    s[c]("pointerdown", v, o),
                    a[c]("pointermove", _, o),
                    a[c]("pointerup", y, l)
                }
                function b() {
                    const {scrollbar: e, el: n} = t;
                    t.params.scrollbar = lx(t, t.originalParams.scrollbar, t.params.scrollbar, {
                        el: "swiper-scrollbar"
                    });
                    const r = t.params.scrollbar;
                    if (!r.el)
                        return;
                    let i, s;
                    if ("string" == typeof r.el && t.isElement && (i = t.el.querySelector(r.el)),
                    i || "string" != typeof r.el)
                        i || (i = r.el);
                    else if (i = a.querySelectorAll(r.el),
                    !i.length)
                        return;
                    t.params.uniqueNavElements && "string" == typeof r.el && i.length > 1 && 1 === n.querySelectorAll(r.el).length && (i = n.querySelector(r.el)),
                    i.length > 0 && (i = i[0]),
                    i.classList.add(t.isHorizontal() ? r.horizontalClass : r.verticalClass),
                    i && (s = i.querySelector(cx(t.params.scrollbar.dragClass)),
                    s || (s = xy("div", t.params.scrollbar.dragClass),
                    i.append(s))),
                    Object.assign(e, {
                        el: i,
                        dragEl: s
                    }),
                    r.draggable && t.params.scrollbar.el && t.scrollbar.el && x("on"),
                    i && i.classList[t.enabled ? "remove" : "add"](...cy(t.params.scrollbar.lockClass))
                }
                function E() {
                    const e = t.params.scrollbar
                      , n = t.scrollbar.el;
                    n && n.classList.remove(...cy(t.isHorizontal() ? e.horizontalClass : e.verticalClass)),
                    t.params.scrollbar.el && t.scrollbar.el && x("off")
                }
                n({
                    scrollbar: {
                        el: null,
                        dragSize: "auto",
                        hide: !1,
                        draggable: !1,
                        snapOnRelease: !0,
                        lockClass: "swiper-scrollbar-lock",
                        dragClass: "swiper-scrollbar-drag",
                        scrollbarDisabledClass: "swiper-scrollbar-disabled",
                        horizontalClass: "swiper-scrollbar-horizontal",
                        verticalClass: "swiper-scrollbar-vertical"
                    }
                }),
                t.scrollbar = {
                    el: null,
                    dragEl: null
                },
                r("changeDirection", ( () => {
                    if (!t.scrollbar || !t.scrollbar.el)
                        return;
                    const e = t.params.scrollbar;
                    let {el: n} = t.scrollbar;
                    n = Ay(n),
                    n.forEach((n => {
                        n.classList.remove(e.horizontalClass, e.verticalClass),
                        n.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass)
                    }
                    ))
                }
                )),
                r("init", ( () => {
                    !1 === t.params.scrollbar.enabled ? S() : (b(),
                    f(),
                    p())
                }
                )),
                r("update resize observerUpdate lock unlock changeDirection", ( () => {
                    f()
                }
                )),
                r("setTranslate", ( () => {
                    p()
                }
                )),
                r("setTransition", ( (e, n) => {
                    !function(e) {
                        t.params.scrollbar.el && t.scrollbar.el && (t.scrollbar.dragEl.style.transitionDuration = `${e}ms`)
                    }(n)
                }
                )),
                r("enable disable", ( () => {
                    const {el: e} = t.scrollbar;
                    e && e.classList[t.enabled ? "remove" : "add"](...cy(t.params.scrollbar.lockClass))
                }
                )),
                r("destroy", ( () => {
                    E()
                }
                ));
                const S = () => {
                    t.el.classList.add(...cy(t.params.scrollbar.scrollbarDisabledClass)),
                    t.scrollbar.el && t.scrollbar.el.classList.add(...cy(t.params.scrollbar.scrollbarDisabledClass)),
                    E()
                }
                ;
                Object.assign(t.scrollbar, {
                    enable: () => {
                        t.el.classList.remove(...cy(t.params.scrollbar.scrollbarDisabledClass)),
                        t.scrollbar.el && t.scrollbar.el.classList.remove(...cy(t.params.scrollbar.scrollbarDisabledClass)),
                        b(),
                        f(),
                        p()
                    }
                    ,
                    disable: S,
                    updateSize: f,
                    setTranslate: p,
                    init: b,
                    destroy: E
                })
            }
            , function(e) {
                let {swiper: t, extendParams: n, on: r} = e;
                n({
                    parallax: {
                        enabled: !1
                    }
                });
                const i = "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]"
                  , a = (e, n) => {
                    const {rtl: r} = t
                      , i = r ? -1 : 1
                      , a = e.getAttribute("data-swiper-parallax") || "0";
                    let s = e.getAttribute("data-swiper-parallax-x")
                      , o = e.getAttribute("data-swiper-parallax-y");
                    const l = e.getAttribute("data-swiper-parallax-scale")
                      , c = e.getAttribute("data-swiper-parallax-opacity")
                      , u = e.getAttribute("data-swiper-parallax-rotate");
                    if (s || o ? (s = s || "0",
                    o = o || "0") : t.isHorizontal() ? (s = a,
                    o = "0") : (o = a,
                    s = "0"),
                    s = s.indexOf("%") >= 0 ? parseInt(s, 10) * n * i + "%" : s * n * i + "px",
                    o = o.indexOf("%") >= 0 ? parseInt(o, 10) * n + "%" : o * n + "px",
                    null != c) {
                        const t = c - (c - 1) * (1 - Math.abs(n));
                        e.style.opacity = t
                    }
                    let d = `translate3d(${s}, ${o}, 0px)`;
                    if (null != l) {
                        d += ` scale(${l - (l - 1) * (1 - Math.abs(n))})`
                    }
                    if (u && null != u) {
                        d += ` rotate(${u * n * -1}deg)`
                    }
                    e.style.transform = d
                }
                  , s = () => {
                    const {el: e, slides: n, progress: r, snapGrid: s, isElement: o} = t
                      , l = _y(e, i);
                    t.isElement && l.push(..._y(t.hostEl, i)),
                    l.forEach((e => {
                        a(e, r)
                    }
                    )),
                    n.forEach(( (e, n) => {
                        let o = e.progress;
                        t.params.slidesPerGroup > 1 && "auto" !== t.params.slidesPerView && (o += Math.ceil(n / 2) - r * (s.length - 1)),
                        o = Math.min(Math.max(o, -1), 1),
                        e.querySelectorAll(`${i}, [data-swiper-parallax-rotate]`).forEach((e => {
                            a(e, o)
                        }
                        ))
                    }
                    ))
                }
                ;
                r("beforeInit", ( () => {
                    t.params.parallax.enabled && (t.params.watchSlidesProgress = !0,
                    t.originalParams.watchSlidesProgress = !0)
                }
                )),
                r("init", ( () => {
                    t.params.parallax.enabled && s()
                }
                )),
                r("setTranslate", ( () => {
                    t.params.parallax.enabled && s()
                }
                )),
                r("setTransition", ( (e, n) => {
                    t.params.parallax.enabled && function(e) {
                        void 0 === e && (e = t.params.speed);
                        const {el: n, hostEl: r} = t
                          , a = [...n.querySelectorAll(i)];
                        t.isElement && a.push(...r.querySelectorAll(i)),
                        a.forEach((t => {
                            let n = parseInt(t.getAttribute("data-swiper-parallax-duration"), 10) || e;
                            0 === e && (n = 0),
                            t.style.transitionDuration = `${n}ms`
                        }
                        ))
                    }(n)
                }
                ))
            }
            , function(e) {
                let {swiper: t, extendParams: n, on: r, emit: i} = e;
                const a = ly();
                n({
                    zoom: {
                        enabled: !1,
                        limitToOriginalSize: !1,
                        maxRatio: 3,
                        minRatio: 1,
                        toggle: !0,
                        containerClass: "swiper-zoom-container",
                        zoomedSlideClass: "swiper-slide-zoomed"
                    }
                }),
                t.zoom = {
                    enabled: !1
                };
                let s, o, l = 1, c = !1;
                const u = []
                  , d = {
                    originX: 0,
                    originY: 0,
                    slideEl: void 0,
                    slideWidth: void 0,
                    slideHeight: void 0,
                    imageEl: void 0,
                    imageWrapEl: void 0,
                    maxRatio: 3
                }
                  , h = {
                    isTouched: void 0,
                    isMoved: void 0,
                    currentX: void 0,
                    currentY: void 0,
                    minX: void 0,
                    minY: void 0,
                    maxX: void 0,
                    maxY: void 0,
                    width: void 0,
                    height: void 0,
                    startX: void 0,
                    startY: void 0,
                    touchesStart: {},
                    touchesCurrent: {}
                }
                  , p = {
                    x: void 0,
                    y: void 0,
                    prevPositionX: void 0,
                    prevPositionY: void 0,
                    prevTime: void 0
                };
                let f, m = 1;
                function g() {
                    if (u.length < 2)
                        return 1;
                    const e = u[0].pageX
                      , t = u[0].pageY
                      , n = u[1].pageX
                      , r = u[1].pageY;
                    return Math.sqrt((n - e) ** 2 + (r - t) ** 2)
                }
                function v() {
                    const e = t.params.zoom
                      , n = d.imageWrapEl.getAttribute("data-swiper-zoom") || e.maxRatio;
                    if (e.limitToOriginalSize && d.imageEl && d.imageEl.naturalWidth) {
                        const e = d.imageEl.naturalWidth / d.imageEl.offsetWidth;
                        return Math.min(e, n)
                    }
                    return n
                }
                function _(e) {
                    const n = t.isElement ? "swiper-slide" : `.${t.params.slideClass}`;
                    return !!e.target.matches(n) || t.slides.filter((t => t.contains(e.target))).length > 0
                }
                function y(e) {
                    if ("mouse" === e.pointerType && u.splice(0, u.length),
                    !_(e))
                        return;
                    const n = t.params.zoom;
                    if (s = !1,
                    o = !1,
                    u.push(e),
                    !(u.length < 2)) {
                        if (s = !0,
                        d.scaleStart = g(),
                        !d.slideEl) {
                            d.slideEl = e.target.closest(`.${t.params.slideClass}, swiper-slide`),
                            d.slideEl || (d.slideEl = t.slides[t.activeIndex]);
                            let r = d.slideEl.querySelector(`.${n.containerClass}`);
                            if (r && (r = r.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]),
                            d.imageEl = r,
                            d.imageWrapEl = r ? wy(d.imageEl, `.${n.containerClass}`)[0] : void 0,
                            !d.imageWrapEl)
                                return void (d.imageEl = void 0);
                            d.maxRatio = v()
                        }
                        if (d.imageEl) {
                            const [e,t] = function() {
                                if (u.length < 2)
                                    return {
                                        x: null,
                                        y: null
                                    };
                                const e = d.imageEl.getBoundingClientRect();
                                return [(u[0].pageX + (u[1].pageX - u[0].pageX) / 2 - e.x - a.scrollX) / l, (u[0].pageY + (u[1].pageY - u[0].pageY) / 2 - e.y - a.scrollY) / l]
                            }();
                            d.originX = e,
                            d.originY = t,
                            d.imageEl.style.transitionDuration = "0ms"
                        }
                        c = !0
                    }
                }
                function x(e) {
                    if (!_(e))
                        return;
                    const n = t.params.zoom
                      , r = t.zoom
                      , i = u.findIndex((t => t.pointerId === e.pointerId));
                    i >= 0 && (u[i] = e),
                    u.length < 2 || (o = !0,
                    d.scaleMove = g(),
                    d.imageEl && (r.scale = d.scaleMove / d.scaleStart * l,
                    r.scale > d.maxRatio && (r.scale = d.maxRatio - 1 + (r.scale - d.maxRatio + 1) ** .5),
                    r.scale < n.minRatio && (r.scale = n.minRatio + 1 - (n.minRatio - r.scale + 1) ** .5),
                    d.imageEl.style.transform = `translate3d(0,0,0) scale(${r.scale})`))
                }
                function b(e) {
                    if (!_(e))
                        return;
                    if ("mouse" === e.pointerType && "pointerout" === e.type)
                        return;
                    const n = t.params.zoom
                      , r = t.zoom
                      , i = u.findIndex((t => t.pointerId === e.pointerId));
                    i >= 0 && u.splice(i, 1),
                    s && o && (s = !1,
                    o = !1,
                    d.imageEl && (r.scale = Math.max(Math.min(r.scale, d.maxRatio), n.minRatio),
                    d.imageEl.style.transitionDuration = `${t.params.speed}ms`,
                    d.imageEl.style.transform = `translate3d(0,0,0) scale(${r.scale})`,
                    l = r.scale,
                    c = !1,
                    r.scale > 1 && d.slideEl ? d.slideEl.classList.add(`${n.zoomedSlideClass}`) : r.scale <= 1 && d.slideEl && d.slideEl.classList.remove(`${n.zoomedSlideClass}`),
                    1 === r.scale && (d.originX = 0,
                    d.originY = 0,
                    d.slideEl = void 0)))
                }
                function E() {
                    t.touchEventsData.preventTouchMoveFromPointerMove = !1
                }
                function S(e) {
                    if (!_(e) || !function(e) {
                        const n = `.${t.params.zoom.containerClass}`;
                        return !!e.target.matches(n) || [...t.hostEl.querySelectorAll(n)].filter((t => t.contains(e.target))).length > 0
                    }(e))
                        return;
                    const n = t.zoom;
                    if (!d.imageEl)
                        return;
                    if (!h.isTouched || !d.slideEl)
                        return;
                    h.isMoved || (h.width = d.imageEl.offsetWidth || d.imageEl.clientWidth,
                    h.height = d.imageEl.offsetHeight || d.imageEl.clientHeight,
                    h.startX = hy(d.imageWrapEl, "x") || 0,
                    h.startY = hy(d.imageWrapEl, "y") || 0,
                    d.slideWidth = d.slideEl.offsetWidth,
                    d.slideHeight = d.slideEl.offsetHeight,
                    d.imageWrapEl.style.transitionDuration = "0ms");
                    const r = h.width * n.scale
                      , i = h.height * n.scale;
                    h.minX = Math.min(d.slideWidth / 2 - r / 2, 0),
                    h.maxX = -h.minX,
                    h.minY = Math.min(d.slideHeight / 2 - i / 2, 0),
                    h.maxY = -h.minY,
                    h.touchesCurrent.x = u.length > 0 ? u[0].pageX : e.pageX,
                    h.touchesCurrent.y = u.length > 0 ? u[0].pageY : e.pageY;
                    if (Math.max(Math.abs(h.touchesCurrent.x - h.touchesStart.x), Math.abs(h.touchesCurrent.y - h.touchesStart.y)) > 5 && (t.allowClick = !1),
                    !h.isMoved && !c) {
                        if (t.isHorizontal() && (Math.floor(h.minX) === Math.floor(h.startX) && h.touchesCurrent.x < h.touchesStart.x || Math.floor(h.maxX) === Math.floor(h.startX) && h.touchesCurrent.x > h.touchesStart.x))
                            return h.isTouched = !1,
                            void E();
                        if (!t.isHorizontal() && (Math.floor(h.minY) === Math.floor(h.startY) && h.touchesCurrent.y < h.touchesStart.y || Math.floor(h.maxY) === Math.floor(h.startY) && h.touchesCurrent.y > h.touchesStart.y))
                            return h.isTouched = !1,
                            void E()
                    }
                    e.cancelable && e.preventDefault(),
                    e.stopPropagation(),
                    clearTimeout(f),
                    t.touchEventsData.preventTouchMoveFromPointerMove = !0,
                    f = setTimeout(( () => {
                        t.destroyed || E()
                    }
                    )),
                    h.isMoved = !0;
                    const a = (n.scale - l) / (d.maxRatio - t.params.zoom.minRatio)
                      , {originX: s, originY: o} = d;
                    h.currentX = h.touchesCurrent.x - h.touchesStart.x + h.startX + a * (h.width - 2 * s),
                    h.currentY = h.touchesCurrent.y - h.touchesStart.y + h.startY + a * (h.height - 2 * o),
                    h.currentX < h.minX && (h.currentX = h.minX + 1 - (h.minX - h.currentX + 1) ** .8),
                    h.currentX > h.maxX && (h.currentX = h.maxX - 1 + (h.currentX - h.maxX + 1) ** .8),
                    h.currentY < h.minY && (h.currentY = h.minY + 1 - (h.minY - h.currentY + 1) ** .8),
                    h.currentY > h.maxY && (h.currentY = h.maxY - 1 + (h.currentY - h.maxY + 1) ** .8),
                    p.prevPositionX || (p.prevPositionX = h.touchesCurrent.x),
                    p.prevPositionY || (p.prevPositionY = h.touchesCurrent.y),
                    p.prevTime || (p.prevTime = Date.now()),
                    p.x = (h.touchesCurrent.x - p.prevPositionX) / (Date.now() - p.prevTime) / 2,
                    p.y = (h.touchesCurrent.y - p.prevPositionY) / (Date.now() - p.prevTime) / 2,
                    Math.abs(h.touchesCurrent.x - p.prevPositionX) < 2 && (p.x = 0),
                    Math.abs(h.touchesCurrent.y - p.prevPositionY) < 2 && (p.y = 0),
                    p.prevPositionX = h.touchesCurrent.x,
                    p.prevPositionY = h.touchesCurrent.y,
                    p.prevTime = Date.now(),
                    d.imageWrapEl.style.transform = `translate3d(${h.currentX}px, ${h.currentY}px,0)`
                }
                function w() {
                    const e = t.zoom;
                    d.slideEl && t.activeIndex !== t.slides.indexOf(d.slideEl) && (d.imageEl && (d.imageEl.style.transform = "translate3d(0,0,0) scale(1)"),
                    d.imageWrapEl && (d.imageWrapEl.style.transform = "translate3d(0,0,0)"),
                    d.slideEl.classList.remove(`${t.params.zoom.zoomedSlideClass}`),
                    e.scale = 1,
                    l = 1,
                    d.slideEl = void 0,
                    d.imageEl = void 0,
                    d.imageWrapEl = void 0,
                    d.originX = 0,
                    d.originY = 0)
                }
                function M(e) {
                    const n = t.zoom
                      , r = t.params.zoom;
                    if (!d.slideEl) {
                        e && e.target && (d.slideEl = e.target.closest(`.${t.params.slideClass}, swiper-slide`)),
                        d.slideEl || (t.params.virtual && t.params.virtual.enabled && t.virtual ? d.slideEl = _y(t.slidesEl, `.${t.params.slideActiveClass}`)[0] : d.slideEl = t.slides[t.activeIndex]);
                        let n = d.slideEl.querySelector(`.${r.containerClass}`);
                        n && (n = n.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]),
                        d.imageEl = n,
                        d.imageWrapEl = n ? wy(d.imageEl, `.${r.containerClass}`)[0] : void 0
                    }
                    if (!d.imageEl || !d.imageWrapEl)
                        return;
                    let i, s, o, c, u, p, f, m, g, _, y, x, b, E, S, w, M, T;
                    t.params.cssMode && (t.wrapperEl.style.overflow = "hidden",
                    t.wrapperEl.style.touchAction = "none"),
                    d.slideEl.classList.add(`${r.zoomedSlideClass}`),
                    void 0 === h.touchesStart.x && e ? (i = e.pageX,
                    s = e.pageY) : (i = h.touchesStart.x,
                    s = h.touchesStart.y);
                    const A = "number" == typeof e ? e : null;
                    1 === l && A && (i = void 0,
                    s = void 0,
                    h.touchesStart.x = void 0,
                    h.touchesStart.y = void 0);
                    const C = v();
                    n.scale = A || C,
                    l = A || C,
                    !e || 1 === l && A ? (f = 0,
                    m = 0) : (M = d.slideEl.offsetWidth,
                    T = d.slideEl.offsetHeight,
                    o = by(d.slideEl).left + a.scrollX,
                    c = by(d.slideEl).top + a.scrollY,
                    u = o + M / 2 - i,
                    p = c + T / 2 - s,
                    g = d.imageEl.offsetWidth || d.imageEl.clientWidth,
                    _ = d.imageEl.offsetHeight || d.imageEl.clientHeight,
                    y = g * n.scale,
                    x = _ * n.scale,
                    b = Math.min(M / 2 - y / 2, 0),
                    E = Math.min(T / 2 - x / 2, 0),
                    S = -b,
                    w = -E,
                    f = u * n.scale,
                    m = p * n.scale,
                    f < b && (f = b),
                    f > S && (f = S),
                    m < E && (m = E),
                    m > w && (m = w)),
                    A && 1 === n.scale && (d.originX = 0,
                    d.originY = 0),
                    d.imageWrapEl.style.transitionDuration = "300ms",
                    d.imageWrapEl.style.transform = `translate3d(${f}px, ${m}px,0)`,
                    d.imageEl.style.transitionDuration = "300ms",
                    d.imageEl.style.transform = `translate3d(0,0,0) scale(${n.scale})`
                }
                function T() {
                    const e = t.zoom
                      , n = t.params.zoom;
                    if (!d.slideEl) {
                        t.params.virtual && t.params.virtual.enabled && t.virtual ? d.slideEl = _y(t.slidesEl, `.${t.params.slideActiveClass}`)[0] : d.slideEl = t.slides[t.activeIndex];
                        let e = d.slideEl.querySelector(`.${n.containerClass}`);
                        e && (e = e.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]),
                        d.imageEl = e,
                        d.imageWrapEl = e ? wy(d.imageEl, `.${n.containerClass}`)[0] : void 0
                    }
                    d.imageEl && d.imageWrapEl && (t.params.cssMode && (t.wrapperEl.style.overflow = "",
                    t.wrapperEl.style.touchAction = ""),
                    e.scale = 1,
                    l = 1,
                    h.touchesStart.x = void 0,
                    h.touchesStart.y = void 0,
                    d.imageWrapEl.style.transitionDuration = "300ms",
                    d.imageWrapEl.style.transform = "translate3d(0,0,0)",
                    d.imageEl.style.transitionDuration = "300ms",
                    d.imageEl.style.transform = "translate3d(0,0,0) scale(1)",
                    d.slideEl.classList.remove(`${n.zoomedSlideClass}`),
                    d.slideEl = void 0,
                    d.originX = 0,
                    d.originY = 0)
                }
                function A(e) {
                    const n = t.zoom;
                    n.scale && 1 !== n.scale ? T() : M(e)
                }
                function C() {
                    return {
                        passiveListener: !!t.params.passiveListeners && {
                            passive: !0,
                            capture: !1
                        },
                        activeListenerWithCapture: !t.params.passiveListeners || {
                            passive: !1,
                            capture: !0
                        }
                    }
                }
                function P() {
                    const e = t.zoom;
                    if (e.enabled)
                        return;
                    e.enabled = !0;
                    const {passiveListener: n, activeListenerWithCapture: r} = C();
                    t.wrapperEl.addEventListener("pointerdown", y, n),
                    t.wrapperEl.addEventListener("pointermove", x, r),
                    ["pointerup", "pointercancel", "pointerout"].forEach((e => {
                        t.wrapperEl.addEventListener(e, b, n)
                    }
                    )),
                    t.wrapperEl.addEventListener("pointermove", S, r)
                }
                function R() {
                    const e = t.zoom;
                    if (!e.enabled)
                        return;
                    e.enabled = !1;
                    const {passiveListener: n, activeListenerWithCapture: r} = C();
                    t.wrapperEl.removeEventListener("pointerdown", y, n),
                    t.wrapperEl.removeEventListener("pointermove", x, r),
                    ["pointerup", "pointercancel", "pointerout"].forEach((e => {
                        t.wrapperEl.removeEventListener(e, b, n)
                    }
                    )),
                    t.wrapperEl.removeEventListener("pointermove", S, r)
                }
                Object.defineProperty(t.zoom, "scale", {
                    get() {
                        return m
                    },
                    set(e) {
                        if (m !== e) {
                            const t = d.imageEl
                              , n = d.slideEl;
                            i("zoomChange", e, t, n)
                        }
                        m = e
                    }
                }),
                r("init", ( () => {
                    t.params.zoom.enabled && P()
                }
                )),
                r("destroy", ( () => {
                    R()
                }
                )),
                r("touchStart", ( (e, n) => {
                    t.zoom.enabled && function(e) {
                        const n = t.device;
                        if (!d.imageEl)
                            return;
                        if (h.isTouched)
                            return;
                        n.android && e.cancelable && e.preventDefault(),
                        h.isTouched = !0;
                        const r = u.length > 0 ? u[0] : e;
                        h.touchesStart.x = r.pageX,
                        h.touchesStart.y = r.pageY
                    }(n)
                }
                )),
                r("touchEnd", ( (e, n) => {
                    t.zoom.enabled && function() {
                        const e = t.zoom;
                        if (!d.imageEl)
                            return;
                        if (!h.isTouched || !h.isMoved)
                            return h.isTouched = !1,
                            void (h.isMoved = !1);
                        h.isTouched = !1,
                        h.isMoved = !1;
                        let n = 300
                          , r = 300;
                        const i = p.x * n
                          , a = h.currentX + i
                          , s = p.y * r
                          , o = h.currentY + s;
                        0 !== p.x && (n = Math.abs((a - h.currentX) / p.x)),
                        0 !== p.y && (r = Math.abs((o - h.currentY) / p.y));
                        const l = Math.max(n, r);
                        h.currentX = a,
                        h.currentY = o;
                        const c = h.width * e.scale
                          , u = h.height * e.scale;
                        h.minX = Math.min(d.slideWidth / 2 - c / 2, 0),
                        h.maxX = -h.minX,
                        h.minY = Math.min(d.slideHeight / 2 - u / 2, 0),
                        h.maxY = -h.minY,
                        h.currentX = Math.max(Math.min(h.currentX, h.maxX), h.minX),
                        h.currentY = Math.max(Math.min(h.currentY, h.maxY), h.minY),
                        d.imageWrapEl.style.transitionDuration = `${l}ms`,
                        d.imageWrapEl.style.transform = `translate3d(${h.currentX}px, ${h.currentY}px,0)`
                    }()
                }
                )),
                r("doubleTap", ( (e, n) => {
                    !t.animating && t.params.zoom.enabled && t.zoom.enabled && t.params.zoom.toggle && A(n)
                }
                )),
                r("transitionEnd", ( () => {
                    t.zoom.enabled && t.params.zoom.enabled && w()
                }
                )),
                r("slideChange", ( () => {
                    t.zoom.enabled && t.params.zoom.enabled && t.params.cssMode && w()
                }
                )),
                Object.assign(t.zoom, {
                    enable: P,
                    disable: R,
                    in: M,
                    out: T,
                    toggle: A
                })
            }
            , function(e) {
                let {swiper: t, extendParams: n, on: r} = e;
                function i(e, t) {
                    const n = function() {
                        let e, t, n;
                        return (r, i) => {
                            for (t = -1,
                            e = r.length; e - t > 1; )
                                n = e + t >> 1,
                                r[n] <= i ? t = n : e = n;
                            return e
                        }
                    }();
                    let r, i;
                    return this.x = e,
                    this.y = t,
                    this.lastIndex = e.length - 1,
                    this.interpolate = function(e) {
                        return e ? (i = n(this.x, e),
                        r = i - 1,
                        (e - this.x[r]) * (this.y[i] - this.y[r]) / (this.x[i] - this.x[r]) + this.y[r]) : 0
                    }
                    ,
                    this
                }
                function a() {
                    t.controller.control && t.controller.spline && (t.controller.spline = void 0,
                    delete t.controller.spline)
                }
                n({
                    controller: {
                        control: void 0,
                        inverse: !1,
                        by: "slide"
                    }
                }),
                t.controller = {
                    control: void 0
                },
                r("beforeInit", ( () => {
                    if ("undefined" != typeof window && ("string" == typeof t.params.controller.control || t.params.controller.control instanceof HTMLElement)) {
                        ("string" == typeof t.params.controller.control ? [...document.querySelectorAll(t.params.controller.control)] : [t.params.controller.control]).forEach((e => {
                            if (t.controller.control || (t.controller.control = []),
                            e && e.swiper)
                                t.controller.control.push(e.swiper);
                            else if (e) {
                                const n = `${t.params.eventsPrefix}init`
                                  , r = i => {
                                    t.controller.control.push(i.detail[0]),
                                    t.update(),
                                    e.removeEventListener(n, r)
                                }
                                ;
                                e.addEventListener(n, r)
                            }
                        }
                        ))
                    } else
                        t.controller.control = t.params.controller.control
                }
                )),
                r("update", ( () => {
                    a()
                }
                )),
                r("resize", ( () => {
                    a()
                }
                )),
                r("observerUpdate", ( () => {
                    a()
                }
                )),
                r("setTranslate", ( (e, n, r) => {
                    t.controller.control && !t.controller.control.destroyed && t.controller.setTranslate(n, r)
                }
                )),
                r("setTransition", ( (e, n, r) => {
                    t.controller.control && !t.controller.control.destroyed && t.controller.setTransition(n, r)
                }
                )),
                Object.assign(t.controller, {
                    setTranslate: function(e, n) {
                        const r = t.controller.control;
                        let a, s;
                        const o = t.constructor;
                        function l(e) {
                            if (e.destroyed)
                                return;
                            const n = t.rtlTranslate ? -t.translate : t.translate;
                            "slide" === t.params.controller.by && (!function(e) {
                                t.controller.spline = t.params.loop ? new i(t.slidesGrid,e.slidesGrid) : new i(t.snapGrid,e.snapGrid)
                            }(e),
                            s = -t.controller.spline.interpolate(-n)),
                            s && "container" !== t.params.controller.by || (a = (e.maxTranslate() - e.minTranslate()) / (t.maxTranslate() - t.minTranslate()),
                            !Number.isNaN(a) && Number.isFinite(a) || (a = 1),
                            s = (n - t.minTranslate()) * a + e.minTranslate()),
                            t.params.controller.inverse && (s = e.maxTranslate() - s),
                            e.updateProgress(s),
                            e.setTranslate(s, t),
                            e.updateActiveIndex(),
                            e.updateSlidesClasses()
                        }
                        if (Array.isArray(r))
                            for (let e = 0; e < r.length; e += 1)
                                r[e] !== n && r[e]instanceof o && l(r[e]);
                        else
                            r instanceof o && n !== r && l(r)
                    },
                    setTransition: function(e, n) {
                        const r = t.constructor
                          , i = t.controller.control;
                        let a;
                        function s(n) {
                            n.destroyed || (n.setTransition(e, t),
                            0 !== e && (n.transitionStart(),
                            n.params.autoHeight && uy(( () => {
                                n.updateAutoHeight()
                            }
                            )),
                            My(n.wrapperEl, ( () => {
                                i && n.transitionEnd()
                            }
                            ))))
                        }
                        if (Array.isArray(i))
                            for (a = 0; a < i.length; a += 1)
                                i[a] !== n && i[a]instanceof r && s(i[a]);
                        else
                            i instanceof r && n !== i && s(i)
                    }
                })
            }
            , function(e) {
                let {swiper: t, extendParams: n, on: r} = e;
                n({
                    a11y: {
                        enabled: !0,
                        notificationClass: "swiper-notification",
                        prevSlideMessage: "Previous slide",
                        nextSlideMessage: "Next slide",
                        firstSlideMessage: "This is the first slide",
                        lastSlideMessage: "This is the last slide",
                        paginationBulletMessage: "Go to slide {{index}}",
                        slideLabelMessage: "{{index}} / {{slidesLength}}",
                        containerMessage: null,
                        containerRoleDescriptionMessage: null,
                        containerRole: null,
                        itemRoleDescriptionMessage: null,
                        slideRole: "group",
                        id: null,
                        scrollOnFocus: !0
                    }
                }),
                t.a11y = {
                    clicked: !1
                };
                let i, a, s = null, o = (new Date).getTime();
                function l(e) {
                    const t = s;
                    0 !== t.length && (t.innerHTML = "",
                    t.innerHTML = e)
                }
                function c(e) {
                    (e = Ay(e)).forEach((e => {
                        e.setAttribute("tabIndex", "0")
                    }
                    ))
                }
                function u(e) {
                    (e = Ay(e)).forEach((e => {
                        e.setAttribute("tabIndex", "-1")
                    }
                    ))
                }
                function d(e, t) {
                    (e = Ay(e)).forEach((e => {
                        e.setAttribute("role", t)
                    }
                    ))
                }
                function h(e, t) {
                    (e = Ay(e)).forEach((e => {
                        e.setAttribute("aria-roledescription", t)
                    }
                    ))
                }
                function p(e, t) {
                    (e = Ay(e)).forEach((e => {
                        e.setAttribute("aria-label", t)
                    }
                    ))
                }
                function f(e) {
                    (e = Ay(e)).forEach((e => {
                        e.setAttribute("aria-disabled", !0)
                    }
                    ))
                }
                function m(e) {
                    (e = Ay(e)).forEach((e => {
                        e.setAttribute("aria-disabled", !1)
                    }
                    ))
                }
                function g(e) {
                    if (13 !== e.keyCode && 32 !== e.keyCode)
                        return;
                    const n = t.params.a11y
                      , r = e.target;
                    if (!t.pagination || !t.pagination.el || r !== t.pagination.el && !t.pagination.el.contains(e.target) || e.target.matches(cx(t.params.pagination.bulletClass))) {
                        if (t.navigation && t.navigation.prevEl && t.navigation.nextEl) {
                            const e = Ay(t.navigation.prevEl);
                            Ay(t.navigation.nextEl).includes(r) && (t.isEnd && !t.params.loop || t.slideNext(),
                            t.isEnd ? l(n.lastSlideMessage) : l(n.nextSlideMessage)),
                            e.includes(r) && (t.isBeginning && !t.params.loop || t.slidePrev(),
                            t.isBeginning ? l(n.firstSlideMessage) : l(n.prevSlideMessage))
                        }
                        t.pagination && r.matches(cx(t.params.pagination.bulletClass)) && r.click()
                    }
                }
                function v() {
                    return t.pagination && t.pagination.bullets && t.pagination.bullets.length
                }
                function _() {
                    return v() && t.params.pagination.clickable
                }
                const y = (e, t, n) => {
                    c(e),
                    "BUTTON" !== e.tagName && (d(e, "button"),
                    e.addEventListener("keydown", g)),
                    p(e, n),
                    function(e, t) {
                        (e = Ay(e)).forEach((e => {
                            e.setAttribute("aria-controls", t)
                        }
                        ))
                    }(e, t)
                }
                  , x = e => {
                    a && a !== e.target && !a.contains(e.target) && (i = !0),
                    t.a11y.clicked = !0
                }
                  , b = () => {
                    i = !1,
                    requestAnimationFrame(( () => {
                        requestAnimationFrame(( () => {
                            t.destroyed || (t.a11y.clicked = !1)
                        }
                        ))
                    }
                    ))
                }
                  , E = e => {
                    o = (new Date).getTime()
                }
                  , S = e => {
                    if (t.a11y.clicked || !t.params.a11y.scrollOnFocus)
                        return;
                    if ((new Date).getTime() - o < 100)
                        return;
                    const n = e.target.closest(`.${t.params.slideClass}, swiper-slide`);
                    if (!n || !t.slides.includes(n))
                        return;
                    a = n;
                    const r = t.slides.indexOf(n) === t.activeIndex
                      , s = t.params.watchSlidesProgress && t.visibleSlides && t.visibleSlides.includes(n);
                    r || s || e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents || (t.isHorizontal() ? t.el.scrollLeft = 0 : t.el.scrollTop = 0,
                    requestAnimationFrame(( () => {
                        i || (t.params.loop ? t.slideToLoop(parseInt(n.getAttribute("data-swiper-slide-index")), 0) : t.slideTo(t.slides.indexOf(n), 0),
                        i = !1)
                    }
                    )))
                }
                  , w = () => {
                    const e = t.params.a11y;
                    e.itemRoleDescriptionMessage && h(t.slides, e.itemRoleDescriptionMessage),
                    e.slideRole && d(t.slides, e.slideRole);
                    const n = t.slides.length;
                    e.slideLabelMessage && t.slides.forEach(( (r, i) => {
                        const a = t.params.loop ? parseInt(r.getAttribute("data-swiper-slide-index"), 10) : i;
                        p(r, e.slideLabelMessage.replace(/\{\{index\}\}/, a + 1).replace(/\{\{slidesLength\}\}/, n))
                    }
                    ))
                }
                  , M = () => {
                    const e = t.params.a11y;
                    t.el.append(s);
                    const n = t.el;
                    e.containerRoleDescriptionMessage && h(n, e.containerRoleDescriptionMessage),
                    e.containerMessage && p(n, e.containerMessage),
                    e.containerRole && d(n, e.containerRole);
                    const r = t.wrapperEl
                      , i = e.id || r.getAttribute("id") || `swiper-wrapper-${a = 16,
                    void 0 === a && (a = 16),
                    "x".repeat(a).replace(/x/g, ( () => Math.round(16 * Math.random()).toString(16)))}`;
                    var a;
                    const o = t.params.autoplay && t.params.autoplay.enabled ? "off" : "polite";
                    !function(e, t) {
                        (e = Ay(e)).forEach((e => {
                            e.setAttribute("id", t)
                        }
                        ))
                    }(r, i),
                    function(e, t) {
                        (e = Ay(e)).forEach((e => {
                            e.setAttribute("aria-live", t)
                        }
                        ))
                    }(r, o),
                    w();
                    let {nextEl: l, prevEl: c} = t.navigation ? t.navigation : {};
                    if (l = Ay(l),
                    c = Ay(c),
                    l && l.forEach((t => y(t, i, e.nextSlideMessage))),
                    c && c.forEach((t => y(t, i, e.prevSlideMessage))),
                    _()) {
                        Ay(t.pagination.el).forEach((e => {
                            e.addEventListener("keydown", g)
                        }
                        ))
                    }
                    sy().addEventListener("visibilitychange", E),
                    t.el.addEventListener("focus", S, !0),
                    t.el.addEventListener("focus", S, !0),
                    t.el.addEventListener("pointerdown", x, !0),
                    t.el.addEventListener("pointerup", b, !0)
                }
                ;
                r("beforeInit", ( () => {
                    s = xy("span", t.params.a11y.notificationClass),
                    s.setAttribute("aria-live", "assertive"),
                    s.setAttribute("aria-atomic", "true")
                }
                )),
                r("afterInit", ( () => {
                    t.params.a11y.enabled && M()
                }
                )),
                r("slidesLengthChange snapGridLengthChange slidesGridLengthChange", ( () => {
                    t.params.a11y.enabled && w()
                }
                )),
                r("fromEdge toEdge afterInit lock unlock", ( () => {
                    t.params.a11y.enabled && function() {
                        if (t.params.loop || t.params.rewind || !t.navigation)
                            return;
                        const {nextEl: e, prevEl: n} = t.navigation;
                        n && (t.isBeginning ? (f(n),
                        u(n)) : (m(n),
                        c(n))),
                        e && (t.isEnd ? (f(e),
                        u(e)) : (m(e),
                        c(e)))
                    }()
                }
                )),
                r("paginationUpdate", ( () => {
                    t.params.a11y.enabled && function() {
                        const e = t.params.a11y;
                        v() && t.pagination.bullets.forEach((n => {
                            t.params.pagination.clickable && (c(n),
                            t.params.pagination.renderBullet || (d(n, "button"),
                            p(n, e.paginationBulletMessage.replace(/\{\{index\}\}/, Sy(n) + 1)))),
                            n.matches(cx(t.params.pagination.bulletActiveClass)) ? n.setAttribute("aria-current", "true") : n.removeAttribute("aria-current")
                        }
                        ))
                    }()
                }
                )),
                r("destroy", ( () => {
                    t.params.a11y.enabled && function() {
                        s && s.remove();
                        let {nextEl: e, prevEl: n} = t.navigation ? t.navigation : {};
                        e = Ay(e),
                        n = Ay(n),
                        e && e.forEach((e => e.removeEventListener("keydown", g))),
                        n && n.forEach((e => e.removeEventListener("keydown", g))),
                        _() && Ay(t.pagination.el).forEach((e => {
                            e.removeEventListener("keydown", g)
                        }
                        ));
                        sy().removeEventListener("visibilitychange", E),
                        t.el && "string" != typeof t.el && (t.el.removeEventListener("focus", S, !0),
                        t.el.removeEventListener("pointerdown", x, !0),
                        t.el.removeEventListener("pointerup", b, !0))
                    }()
                }
                ))
            }
            , function(e) {
                let {swiper: t, extendParams: n, on: r} = e;
                n({
                    history: {
                        enabled: !1,
                        root: "",
                        replaceState: !1,
                        key: "slides",
                        keepQuery: !1
                    }
                });
                let i = !1
                  , a = {};
                const s = e => e.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, "")
                  , o = e => {
                    const t = ly();
                    let n;
                    n = e ? new URL(e) : t.location;
                    const r = n.pathname.slice(1).split("/").filter((e => "" !== e))
                      , i = r.length;
                    return {
                        key: r[i - 2],
                        value: r[i - 1]
                    }
                }
                  , l = (e, n) => {
                    const r = ly();
                    if (!i || !t.params.history.enabled)
                        return;
                    let a;
                    a = t.params.url ? new URL(t.params.url) : r.location;
                    const o = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector(`[data-swiper-slide-index="${n}"]`) : t.slides[n];
                    let l = s(o.getAttribute("data-history"));
                    if (t.params.history.root.length > 0) {
                        let n = t.params.history.root;
                        "/" === n[n.length - 1] && (n = n.slice(0, n.length - 1)),
                        l = `${n}/${e ? `${e}/` : ""}${l}`
                    } else
                        a.pathname.includes(e) || (l = `${e ? `${e}/` : ""}${l}`);
                    t.params.history.keepQuery && (l += a.search);
                    const c = r.history.state;
                    c && c.value === l || (t.params.history.replaceState ? r.history.replaceState({
                        value: l
                    }, null, l) : r.history.pushState({
                        value: l
                    }, null, l))
                }
                  , c = (e, n, r) => {
                    if (n)
                        for (let i = 0, a = t.slides.length; i < a; i += 1) {
                            const a = t.slides[i];
                            if (s(a.getAttribute("data-history")) === n) {
                                const n = t.getSlideIndex(a);
                                t.slideTo(n, e, r)
                            }
                        }
                    else
                        t.slideTo(0, e, r)
                }
                  , u = () => {
                    a = o(t.params.url),
                    c(t.params.speed, a.value, !1)
                }
                ;
                r("init", ( () => {
                    t.params.history.enabled && ( () => {
                        const e = ly();
                        if (t.params.history) {
                            if (!e.history || !e.history.pushState)
                                return t.params.history.enabled = !1,
                                void (t.params.hashNavigation.enabled = !0);
                            i = !0,
                            a = o(t.params.url),
                            a.key || a.value ? (c(0, a.value, t.params.runCallbacksOnInit),
                            t.params.history.replaceState || e.addEventListener("popstate", u)) : t.params.history.replaceState || e.addEventListener("popstate", u)
                        }
                    }
                    )()
                }
                )),
                r("destroy", ( () => {
                    t.params.history.enabled && ( () => {
                        const e = ly();
                        t.params.history.replaceState || e.removeEventListener("popstate", u)
                    }
                    )()
                }
                )),
                r("transitionEnd _freeModeNoMomentumRelease", ( () => {
                    i && l(t.params.history.key, t.activeIndex)
                }
                )),
                r("slideChange", ( () => {
                    i && t.params.cssMode && l(t.params.history.key, t.activeIndex)
                }
                ))
            }
            , function(e) {
                let {swiper: t, extendParams: n, emit: r, on: i} = e
                  , a = !1;
                const s = sy()
                  , o = ly();
                n({
                    hashNavigation: {
                        enabled: !1,
                        replaceState: !1,
                        watchState: !1,
                        getSlideIndex(e, n) {
                            if (t.virtual && t.params.virtual.enabled) {
                                const e = t.slides.filter((e => e.getAttribute("data-hash") === n))[0];
                                if (!e)
                                    return 0;
                                return parseInt(e.getAttribute("data-swiper-slide-index"), 10)
                            }
                            return t.getSlideIndex(_y(t.slidesEl, `.${t.params.slideClass}[data-hash="${n}"], swiper-slide[data-hash="${n}"]`)[0])
                        }
                    }
                });
                const l = () => {
                    r("hashChange");
                    const e = s.location.hash.replace("#", "")
                      , n = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector(`[data-swiper-slide-index="${t.activeIndex}"]`) : t.slides[t.activeIndex];
                    if (e !== (n ? n.getAttribute("data-hash") : "")) {
                        const n = t.params.hashNavigation.getSlideIndex(t, e);
                        if (void 0 === n || Number.isNaN(n))
                            return;
                        t.slideTo(n)
                    }
                }
                  , c = () => {
                    if (!a || !t.params.hashNavigation.enabled)
                        return;
                    const e = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector(`[data-swiper-slide-index="${t.activeIndex}"]`) : t.slides[t.activeIndex]
                      , n = e ? e.getAttribute("data-hash") || e.getAttribute("data-history") : "";
                    t.params.hashNavigation.replaceState && o.history && o.history.replaceState ? (o.history.replaceState(null, null, `#${n}` || ""),
                    r("hashSet")) : (s.location.hash = n || "",
                    r("hashSet"))
                }
                ;
                i("init", ( () => {
                    t.params.hashNavigation.enabled && ( () => {
                        if (!t.params.hashNavigation.enabled || t.params.history && t.params.history.enabled)
                            return;
                        a = !0;
                        const e = s.location.hash.replace("#", "");
                        if (e) {
                            const n = 0
                              , r = t.params.hashNavigation.getSlideIndex(t, e);
                            t.slideTo(r || 0, n, t.params.runCallbacksOnInit, !0)
                        }
                        t.params.hashNavigation.watchState && o.addEventListener("hashchange", l)
                    }
                    )()
                }
                )),
                i("destroy", ( () => {
                    t.params.hashNavigation.enabled && t.params.hashNavigation.watchState && o.removeEventListener("hashchange", l)
                }
                )),
                i("transitionEnd _freeModeNoMomentumRelease", ( () => {
                    a && c()
                }
                )),
                i("slideChange", ( () => {
                    a && t.params.cssMode && c()
                }
                ))
            }
            , function(e) {
                let t, n, {swiper: r, extendParams: i, on: a, emit: s, params: o} = e;
                r.autoplay = {
                    running: !1,
                    paused: !1,
                    timeLeft: 0
                },
                i({
                    autoplay: {
                        enabled: !1,
                        delay: 3e3,
                        waitForTransition: !0,
                        disableOnInteraction: !1,
                        stopOnLastSlide: !1,
                        reverseDirection: !1,
                        pauseOnMouseEnter: !1
                    }
                });
                let l, c, u, d, h, p, f, m, g = o && o.autoplay ? o.autoplay.delay : 3e3, v = o && o.autoplay ? o.autoplay.delay : 3e3, _ = (new Date).getTime();
                function y(e) {
                    r && !r.destroyed && r.wrapperEl && e.target === r.wrapperEl && (r.wrapperEl.removeEventListener("transitionend", y),
                    m || e.detail && e.detail.bySwiperTouchMove || M())
                }
                const x = () => {
                    if (r.destroyed || !r.autoplay.running)
                        return;
                    r.autoplay.paused ? c = !0 : c && (v = l,
                    c = !1);
                    const e = r.autoplay.paused ? l : _ + v - (new Date).getTime();
                    r.autoplay.timeLeft = e,
                    s("autoplayTimeLeft", e, e / g),
                    n = requestAnimationFrame(( () => {
                        x()
                    }
                    ))
                }
                  , b = e => {
                    if (r.destroyed || !r.autoplay.running)
                        return;
                    cancelAnimationFrame(n),
                    x();
                    let i = void 0 === e ? r.params.autoplay.delay : e;
                    g = r.params.autoplay.delay,
                    v = r.params.autoplay.delay;
                    const a = ( () => {
                        let e;
                        if (e = r.virtual && r.params.virtual.enabled ? r.slides.filter((e => e.classList.contains("swiper-slide-active")))[0] : r.slides[r.activeIndex],
                        !e)
                            return;
                        return parseInt(e.getAttribute("data-swiper-autoplay"), 10)
                    }
                    )();
                    !Number.isNaN(a) && a > 0 && void 0 === e && (i = a,
                    g = a,
                    v = a),
                    l = i;
                    const o = r.params.speed
                      , c = () => {
                        r && !r.destroyed && (r.params.autoplay.reverseDirection ? !r.isBeginning || r.params.loop || r.params.rewind ? (r.slidePrev(o, !0, !0),
                        s("autoplay")) : r.params.autoplay.stopOnLastSlide || (r.slideTo(r.slides.length - 1, o, !0, !0),
                        s("autoplay")) : !r.isEnd || r.params.loop || r.params.rewind ? (r.slideNext(o, !0, !0),
                        s("autoplay")) : r.params.autoplay.stopOnLastSlide || (r.slideTo(0, o, !0, !0),
                        s("autoplay")),
                        r.params.cssMode && (_ = (new Date).getTime(),
                        requestAnimationFrame(( () => {
                            b()
                        }
                        ))))
                    }
                    ;
                    return i > 0 ? (clearTimeout(t),
                    t = setTimeout(( () => {
                        c()
                    }
                    ), i)) : requestAnimationFrame(( () => {
                        c()
                    }
                    )),
                    i
                }
                  , E = () => {
                    _ = (new Date).getTime(),
                    r.autoplay.running = !0,
                    b(),
                    s("autoplayStart")
                }
                  , S = () => {
                    r.autoplay.running = !1,
                    clearTimeout(t),
                    cancelAnimationFrame(n),
                    s("autoplayStop")
                }
                  , w = (e, n) => {
                    if (r.destroyed || !r.autoplay.running)
                        return;
                    clearTimeout(t),
                    e || (f = !0);
                    const i = () => {
                        s("autoplayPause"),
                        r.params.autoplay.waitForTransition ? r.wrapperEl.addEventListener("transitionend", y) : M()
                    }
                    ;
                    if (r.autoplay.paused = !0,
                    n)
                        return p && (l = r.params.autoplay.delay),
                        p = !1,
                        void i();
                    const a = l || r.params.autoplay.delay;
                    l = a - ((new Date).getTime() - _),
                    r.isEnd && l < 0 && !r.params.loop || (l < 0 && (l = 0),
                    i())
                }
                  , M = () => {
                    r.isEnd && l < 0 && !r.params.loop || r.destroyed || !r.autoplay.running || (_ = (new Date).getTime(),
                    f ? (f = !1,
                    b(l)) : b(),
                    r.autoplay.paused = !1,
                    s("autoplayResume"))
                }
                  , T = () => {
                    if (r.destroyed || !r.autoplay.running)
                        return;
                    const e = sy();
                    "hidden" === e.visibilityState && (f = !0,
                    w(!0)),
                    "visible" === e.visibilityState && M()
                }
                  , A = e => {
                    "mouse" === e.pointerType && (f = !0,
                    m = !0,
                    r.animating || r.autoplay.paused || w(!0))
                }
                  , C = e => {
                    "mouse" === e.pointerType && (m = !1,
                    r.autoplay.paused && M())
                }
                ;
                a("init", ( () => {
                    r.params.autoplay.enabled && (r.params.autoplay.pauseOnMouseEnter && (r.el.addEventListener("pointerenter", A),
                    r.el.addEventListener("pointerleave", C)),
                    sy().addEventListener("visibilitychange", T),
                    E())
                }
                )),
                a("destroy", ( () => {
                    r.el && "string" != typeof r.el && (r.el.removeEventListener("pointerenter", A),
                    r.el.removeEventListener("pointerleave", C)),
                    sy().removeEventListener("visibilitychange", T),
                    r.autoplay.running && S()
                }
                )),
                a("_freeModeStaticRelease", ( () => {
                    (d || f) && M()
                }
                )),
                a("_freeModeNoMomentumRelease", ( () => {
                    r.params.autoplay.disableOnInteraction ? S() : w(!0, !0)
                }
                )),
                a("beforeTransitionStart", ( (e, t, n) => {
                    !r.destroyed && r.autoplay.running && (n || !r.params.autoplay.disableOnInteraction ? w(!0, !0) : S())
                }
                )),
                a("sliderFirstMove", ( () => {
                    !r.destroyed && r.autoplay.running && (r.params.autoplay.disableOnInteraction ? S() : (u = !0,
                    d = !1,
                    f = !1,
                    h = setTimeout(( () => {
                        f = !0,
                        d = !0,
                        w(!0)
                    }
                    ), 200)))
                }
                )),
                a("touchEnd", ( () => {
                    if (!r.destroyed && r.autoplay.running && u) {
                        if (clearTimeout(h),
                        clearTimeout(t),
                        r.params.autoplay.disableOnInteraction)
                            return d = !1,
                            void (u = !1);
                        d && r.params.cssMode && M(),
                        d = !1,
                        u = !1
                    }
                }
                )),
                a("slideChange", ( () => {
                    !r.destroyed && r.autoplay.running && (p = !0)
                }
                )),
                Object.assign(r.autoplay, {
                    start: E,
                    stop: S,
                    pause: w,
                    resume: M
                })
            }
            , function(e) {
                let {swiper: t, extendParams: n, on: r} = e;
                n({
                    thumbs: {
                        swiper: null,
                        multipleActiveThumbs: !0,
                        autoScrollOffset: 0,
                        slideThumbActiveClass: "swiper-slide-thumb-active",
                        thumbsContainerClass: "swiper-thumbs"
                    }
                });
                let i = !1
                  , a = !1;
                function s() {
                    const e = t.thumbs.swiper;
                    if (!e || e.destroyed)
                        return;
                    const n = e.clickedIndex
                      , r = e.clickedSlide;
                    if (r && r.classList.contains(t.params.thumbs.slideThumbActiveClass))
                        return;
                    if (null == n)
                        return;
                    let i;
                    i = e.params.loop ? parseInt(e.clickedSlide.getAttribute("data-swiper-slide-index"), 10) : n,
                    t.params.loop ? t.slideToLoop(i) : t.slideTo(i)
                }
                function o() {
                    const {thumbs: e} = t.params;
                    if (i)
                        return !1;
                    i = !0;
                    const n = t.constructor;
                    if (e.swiper instanceof n)
                        t.thumbs.swiper = e.swiper,
                        Object.assign(t.thumbs.swiper.originalParams, {
                            watchSlidesProgress: !0,
                            slideToClickedSlide: !1
                        }),
                        Object.assign(t.thumbs.swiper.params, {
                            watchSlidesProgress: !0,
                            slideToClickedSlide: !1
                        }),
                        t.thumbs.swiper.update();
                    else if (py(e.swiper)) {
                        const r = Object.assign({}, e.swiper);
                        Object.assign(r, {
                            watchSlidesProgress: !0,
                            slideToClickedSlide: !1
                        }),
                        t.thumbs.swiper = new n(r),
                        a = !0
                    }
                    return t.thumbs.swiper.el.classList.add(t.params.thumbs.thumbsContainerClass),
                    t.thumbs.swiper.on("tap", s),
                    !0
                }
                function l(e) {
                    const n = t.thumbs.swiper;
                    if (!n || n.destroyed)
                        return;
                    const r = "auto" === n.params.slidesPerView ? n.slidesPerViewDynamic() : n.params.slidesPerView;
                    let i = 1;
                    const a = t.params.thumbs.slideThumbActiveClass;
                    if (t.params.slidesPerView > 1 && !t.params.centeredSlides && (i = t.params.slidesPerView),
                    t.params.thumbs.multipleActiveThumbs || (i = 1),
                    i = Math.floor(i),
                    n.slides.forEach((e => e.classList.remove(a))),
                    n.params.loop || n.params.virtual && n.params.virtual.enabled)
                        for (let e = 0; e < i; e += 1)
                            _y(n.slidesEl, `[data-swiper-slide-index="${t.realIndex + e}"]`).forEach((e => {
                                e.classList.add(a)
                            }
                            ));
                    else
                        for (let e = 0; e < i; e += 1)
                            n.slides[t.realIndex + e] && n.slides[t.realIndex + e].classList.add(a);
                    const s = t.params.thumbs.autoScrollOffset
                      , o = s && !n.params.loop;
                    if (t.realIndex !== n.realIndex || o) {
                        const i = n.activeIndex;
                        let a, l;
                        if (n.params.loop) {
                            const e = n.slides.filter((e => e.getAttribute("data-swiper-slide-index") === `${t.realIndex}`))[0];
                            a = n.slides.indexOf(e),
                            l = t.activeIndex > t.previousIndex ? "next" : "prev"
                        } else
                            a = t.realIndex,
                            l = a > t.previousIndex ? "next" : "prev";
                        o && (a += "next" === l ? s : -1 * s),
                        n.visibleSlidesIndexes && n.visibleSlidesIndexes.indexOf(a) < 0 && (n.params.centeredSlides ? a = a > i ? a - Math.floor(r / 2) + 1 : a + Math.floor(r / 2) - 1 : a > i && n.params.slidesPerGroup,
                        n.slideTo(a, e ? 0 : void 0))
                    }
                }
                t.thumbs = {
                    swiper: null
                },
                r("beforeInit", ( () => {
                    const {thumbs: e} = t.params;
                    if (e && e.swiper)
                        if ("string" == typeof e.swiper || e.swiper instanceof HTMLElement) {
                            const n = sy()
                              , r = () => {
                                const r = "string" == typeof e.swiper ? n.querySelector(e.swiper) : e.swiper;
                                if (r && r.swiper)
                                    e.swiper = r.swiper,
                                    o(),
                                    l(!0);
                                else if (r) {
                                    const n = `${t.params.eventsPrefix}init`
                                      , i = a => {
                                        e.swiper = a.detail[0],
                                        r.removeEventListener(n, i),
                                        o(),
                                        l(!0),
                                        e.swiper.update(),
                                        t.update()
                                    }
                                    ;
                                    r.addEventListener(n, i)
                                }
                                return r
                            }
                              , i = () => {
                                if (t.destroyed)
                                    return;
                                r() || requestAnimationFrame(i)
                            }
                            ;
                            requestAnimationFrame(i)
                        } else
                            o(),
                            l(!0)
                }
                )),
                r("slideChange update resize observerUpdate", ( () => {
                    l()
                }
                )),
                r("setTransition", ( (e, n) => {
                    const r = t.thumbs.swiper;
                    r && !r.destroyed && r.setTransition(n)
                }
                )),
                r("beforeDestroy", ( () => {
                    const e = t.thumbs.swiper;
                    e && !e.destroyed && a && e.destroy()
                }
                )),
                Object.assign(t.thumbs, {
                    init: o,
                    update: l
                })
            }
            , function(e) {
                let {swiper: t, extendParams: n, emit: r, once: i} = e;
                n({
                    freeMode: {
                        enabled: !1,
                        momentum: !0,
                        momentumRatio: 1,
                        momentumBounce: !0,
                        momentumBounceRatio: 1,
                        momentumVelocityRatio: 1,
                        sticky: !1,
                        minimumVelocity: .02
                    }
                }),
                Object.assign(t, {
                    freeMode: {
                        onTouchStart: function() {
                            if (t.params.cssMode)
                                return;
                            const e = t.getTranslate();
                            t.setTranslate(e),
                            t.setTransition(0),
                            t.touchEventsData.velocities.length = 0,
                            t.freeMode.onTouchEnd({
                                currentPos: t.rtl ? t.translate : -t.translate
                            })
                        },
                        onTouchMove: function() {
                            if (t.params.cssMode)
                                return;
                            const {touchEventsData: e, touches: n} = t;
                            0 === e.velocities.length && e.velocities.push({
                                position: n[t.isHorizontal() ? "startX" : "startY"],
                                time: e.touchStartTime
                            }),
                            e.velocities.push({
                                position: n[t.isHorizontal() ? "currentX" : "currentY"],
                                time: dy()
                            })
                        },
                        onTouchEnd: function(e) {
                            let {currentPos: n} = e;
                            if (t.params.cssMode)
                                return;
                            const {params: a, wrapperEl: s, rtlTranslate: o, snapGrid: l, touchEventsData: c} = t
                              , u = dy() - c.touchStartTime;
                            if (n < -t.minTranslate())
                                t.slideTo(t.activeIndex);
                            else if (n > -t.maxTranslate())
                                t.slides.length < l.length ? t.slideTo(l.length - 1) : t.slideTo(t.slides.length - 1);
                            else {
                                if (a.freeMode.momentum) {
                                    if (c.velocities.length > 1) {
                                        const e = c.velocities.pop()
                                          , n = c.velocities.pop()
                                          , r = e.position - n.position
                                          , i = e.time - n.time;
                                        t.velocity = r / i,
                                        t.velocity /= 2,
                                        Math.abs(t.velocity) < a.freeMode.minimumVelocity && (t.velocity = 0),
                                        (i > 150 || dy() - e.time > 300) && (t.velocity = 0)
                                    } else
                                        t.velocity = 0;
                                    t.velocity *= a.freeMode.momentumVelocityRatio,
                                    c.velocities.length = 0;
                                    let e = 1e3 * a.freeMode.momentumRatio;
                                    const n = t.velocity * e;
                                    let u = t.translate + n;
                                    o && (u = -u);
                                    let d, h = !1;
                                    const p = 20 * Math.abs(t.velocity) * a.freeMode.momentumBounceRatio;
                                    let f;
                                    if (u < t.maxTranslate())
                                        a.freeMode.momentumBounce ? (u + t.maxTranslate() < -p && (u = t.maxTranslate() - p),
                                        d = t.maxTranslate(),
                                        h = !0,
                                        c.allowMomentumBounce = !0) : u = t.maxTranslate(),
                                        a.loop && a.centeredSlides && (f = !0);
                                    else if (u > t.minTranslate())
                                        a.freeMode.momentumBounce ? (u - t.minTranslate() > p && (u = t.minTranslate() + p),
                                        d = t.minTranslate(),
                                        h = !0,
                                        c.allowMomentumBounce = !0) : u = t.minTranslate(),
                                        a.loop && a.centeredSlides && (f = !0);
                                    else if (a.freeMode.sticky) {
                                        let e;
                                        for (let t = 0; t < l.length; t += 1)
                                            if (l[t] > -u) {
                                                e = t;
                                                break
                                            }
                                        u = Math.abs(l[e] - u) < Math.abs(l[e - 1] - u) || "next" === t.swipeDirection ? l[e] : l[e - 1],
                                        u = -u
                                    }
                                    if (f && i("transitionEnd", ( () => {
                                        t.loopFix()
                                    }
                                    )),
                                    0 !== t.velocity) {
                                        if (e = o ? Math.abs((-u - t.translate) / t.velocity) : Math.abs((u - t.translate) / t.velocity),
                                        a.freeMode.sticky) {
                                            const n = Math.abs((o ? -u : u) - t.translate)
                                              , r = t.slidesSizesGrid[t.activeIndex];
                                            e = n < r ? a.speed : n < 2 * r ? 1.5 * a.speed : 2.5 * a.speed
                                        }
                                    } else if (a.freeMode.sticky)
                                        return void t.slideToClosest();
                                    a.freeMode.momentumBounce && h ? (t.updateProgress(d),
                                    t.setTransition(e),
                                    t.setTranslate(u),
                                    t.transitionStart(!0, t.swipeDirection),
                                    t.animating = !0,
                                    My(s, ( () => {
                                        t && !t.destroyed && c.allowMomentumBounce && (r("momentumBounce"),
                                        t.setTransition(a.speed),
                                        setTimeout(( () => {
                                            t.setTranslate(d),
                                            My(s, ( () => {
                                                t && !t.destroyed && t.transitionEnd()
                                            }
                                            ))
                                        }
                                        ), 0))
                                    }
                                    ))) : t.velocity ? (r("_freeModeNoMomentumRelease"),
                                    t.updateProgress(u),
                                    t.setTransition(e),
                                    t.setTranslate(u),
                                    t.transitionStart(!0, t.swipeDirection),
                                    t.animating || (t.animating = !0,
                                    My(s, ( () => {
                                        t && !t.destroyed && t.transitionEnd()
                                    }
                                    )))) : t.updateProgress(u),
                                    t.updateActiveIndex(),
                                    t.updateSlidesClasses()
                                } else {
                                    if (a.freeMode.sticky)
                                        return void t.slideToClosest();
                                    a.freeMode && r("_freeModeNoMomentumRelease")
                                }
                                (!a.freeMode.momentum || u >= a.longSwipesMs) && (r("_freeModeStaticRelease"),
                                t.updateProgress(),
                                t.updateActiveIndex(),
                                t.updateSlidesClasses())
                            }
                        }
                    }
                })
            }
            , function(e) {
                let t, n, r, i, {swiper: a, extendParams: s, on: o} = e;
                s({
                    grid: {
                        rows: 1,
                        fill: "column"
                    }
                });
                const l = () => {
                    let e = a.params.spaceBetween;
                    return "string" == typeof e && e.indexOf("%") >= 0 ? e = parseFloat(e.replace("%", "")) / 100 * a.size : "string" == typeof e && (e = parseFloat(e)),
                    e
                }
                ;
                o("init", ( () => {
                    i = a.params.grid && a.params.grid.rows > 1
                }
                )),
                o("update", ( () => {
                    const {params: e, el: t} = a
                      , n = e.grid && e.grid.rows > 1;
                    i && !n ? (t.classList.remove(`${e.containerModifierClass}grid`, `${e.containerModifierClass}grid-column`),
                    r = 1,
                    a.emitContainerClasses()) : !i && n && (t.classList.add(`${e.containerModifierClass}grid`),
                    "column" === e.grid.fill && t.classList.add(`${e.containerModifierClass}grid-column`),
                    a.emitContainerClasses()),
                    i = n
                }
                )),
                a.grid = {
                    initSlides: e => {
                        const {slidesPerView: i} = a.params
                          , {rows: s, fill: o} = a.params.grid
                          , l = a.virtual && a.params.virtual.enabled ? a.virtual.slides.length : e.length;
                        r = Math.floor(l / s),
                        t = Math.floor(l / s) === l / s ? l : Math.ceil(l / s) * s,
                        "auto" !== i && "row" === o && (t = Math.max(t, i * s)),
                        n = t / s
                    }
                    ,
                    unsetSlides: () => {
                        a.slides && a.slides.forEach((e => {
                            e.swiperSlideGridSet && (e.style.height = "",
                            e.style[a.getDirectionLabel("margin-top")] = "")
                        }
                        ))
                    }
                    ,
                    updateSlide: (e, i, s) => {
                        const {slidesPerGroup: o} = a.params
                          , c = l()
                          , {rows: u, fill: d} = a.params.grid
                          , h = a.virtual && a.params.virtual.enabled ? a.virtual.slides.length : s.length;
                        let p, f, m;
                        if ("row" === d && o > 1) {
                            const n = Math.floor(e / (o * u))
                              , r = e - u * o * n
                              , a = 0 === n ? o : Math.min(Math.ceil((h - n * u * o) / u), o);
                            m = Math.floor(r / a),
                            f = r - m * a + n * o,
                            p = f + m * t / u,
                            i.style.order = p
                        } else
                            "column" === d ? (f = Math.floor(e / u),
                            m = e - f * u,
                            (f > r || f === r && m === u - 1) && (m += 1,
                            m >= u && (m = 0,
                            f += 1))) : (m = Math.floor(e / n),
                            f = e - m * n);
                        i.row = m,
                        i.column = f,
                        i.style.height = `calc((100% - ${(u - 1) * c}px) / ${u})`,
                        i.style[a.getDirectionLabel("margin-top")] = 0 !== m ? c && `${c}px` : "",
                        i.swiperSlideGridSet = !0
                    }
                    ,
                    updateWrapperSize: (e, n) => {
                        const {centeredSlides: r, roundLengths: i} = a.params
                          , s = l()
                          , {rows: o} = a.params.grid;
                        if (a.virtualSize = (e + s) * t,
                        a.virtualSize = Math.ceil(a.virtualSize / o) - s,
                        a.params.cssMode || (a.wrapperEl.style[a.getDirectionLabel("width")] = `${a.virtualSize + s}px`),
                        r) {
                            const e = [];
                            for (let t = 0; t < n.length; t += 1) {
                                let r = n[t];
                                i && (r = Math.floor(r)),
                                n[t] < a.virtualSize + n[0] && e.push(r)
                            }
                            n.splice(0, n.length),
                            n.push(...e)
                        }
                    }
                }
            }
            , function(e) {
                let {swiper: t} = e;
                Object.assign(t, {
                    appendSlide: ux.bind(t),
                    prependSlide: dx.bind(t),
                    addSlide: hx.bind(t),
                    removeSlide: px.bind(t),
                    removeAllSlides: fx.bind(t)
                })
            }
            , function(e) {
                let {swiper: t, extendParams: n, on: r} = e;
                n({
                    fadeEffect: {
                        crossFade: !1
                    }
                }),
                mx({
                    effect: "fade",
                    swiper: t,
                    on: r,
                    setTranslate: () => {
                        const {slides: e} = t;
                        t.params.fadeEffect;
                        for (let n = 0; n < e.length; n += 1) {
                            const e = t.slides[n];
                            let r = -e.swiperSlideOffset;
                            t.params.virtualTranslate || (r -= t.translate);
                            let i = 0;
                            t.isHorizontal() || (i = r,
                            r = 0);
                            const a = t.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(e.progress), 0) : 1 + Math.min(Math.max(e.progress, -1), 0)
                              , s = gx(0, e);
                            s.style.opacity = a,
                            s.style.transform = `translate3d(${r}px, ${i}px, 0px)`
                        }
                    }
                    ,
                    setTransition: e => {
                        const n = t.slides.map((e => vy(e)));
                        n.forEach((t => {
                            t.style.transitionDuration = `${e}ms`
                        }
                        )),
                        vx({
                            swiper: t,
                            duration: e,
                            transformElements: n,
                            allSlides: !0
                        })
                    }
                    ,
                    overwriteParams: () => ({
                        slidesPerView: 1,
                        slidesPerGroup: 1,
                        watchSlidesProgress: !0,
                        spaceBetween: 0,
                        virtualTranslate: !t.params.cssMode
                    })
                })
            }
            , function(e) {
                let {swiper: t, extendParams: n, on: r} = e;
                n({
                    cubeEffect: {
                        slideShadows: !0,
                        shadow: !0,
                        shadowOffset: 20,
                        shadowScale: .94
                    }
                });
                const i = (e, t, n) => {
                    let r = n ? e.querySelector(".swiper-slide-shadow-left") : e.querySelector(".swiper-slide-shadow-top")
                      , i = n ? e.querySelector(".swiper-slide-shadow-right") : e.querySelector(".swiper-slide-shadow-bottom");
                    r || (r = xy("div", ("swiper-slide-shadow-cube swiper-slide-shadow-" + (n ? "left" : "top")).split(" ")),
                    e.append(r)),
                    i || (i = xy("div", ("swiper-slide-shadow-cube swiper-slide-shadow-" + (n ? "right" : "bottom")).split(" ")),
                    e.append(i)),
                    r && (r.style.opacity = Math.max(-t, 0)),
                    i && (i.style.opacity = Math.max(t, 0))
                }
                ;
                mx({
                    effect: "cube",
                    swiper: t,
                    on: r,
                    setTranslate: () => {
                        const {el: e, wrapperEl: n, slides: r, width: a, height: s, rtlTranslate: o, size: l, browser: c} = t
                          , u = Cy(t)
                          , d = t.params.cubeEffect
                          , h = t.isHorizontal()
                          , p = t.virtual && t.params.virtual.enabled;
                        let f, m = 0;
                        d.shadow && (h ? (f = t.wrapperEl.querySelector(".swiper-cube-shadow"),
                        f || (f = xy("div", "swiper-cube-shadow"),
                        t.wrapperEl.append(f)),
                        f.style.height = `${a}px`) : (f = e.querySelector(".swiper-cube-shadow"),
                        f || (f = xy("div", "swiper-cube-shadow"),
                        e.append(f))));
                        for (let e = 0; e < r.length; e += 1) {
                            const t = r[e];
                            let n = e;
                            p && (n = parseInt(t.getAttribute("data-swiper-slide-index"), 10));
                            let a = 90 * n
                              , s = Math.floor(a / 360);
                            o && (a = -a,
                            s = Math.floor(-a / 360));
                            const c = Math.max(Math.min(t.progress, 1), -1);
                            let f = 0
                              , g = 0
                              , v = 0;
                            n % 4 == 0 ? (f = 4 * -s * l,
                            v = 0) : (n - 1) % 4 == 0 ? (f = 0,
                            v = 4 * -s * l) : (n - 2) % 4 == 0 ? (f = l + 4 * s * l,
                            v = l) : (n - 3) % 4 == 0 && (f = -l,
                            v = 3 * l + 4 * l * s),
                            o && (f = -f),
                            h || (g = f,
                            f = 0);
                            const _ = `rotateX(${u(h ? 0 : -a)}deg) rotateY(${u(h ? a : 0)}deg) translate3d(${f}px, ${g}px, ${v}px)`;
                            c <= 1 && c > -1 && (m = 90 * n + 90 * c,
                            o && (m = 90 * -n - 90 * c)),
                            t.style.transform = _,
                            d.slideShadows && i(t, c, h)
                        }
                        if (n.style.transformOrigin = `50% 50% -${l / 2}px`,
                        n.style["-webkit-transform-origin"] = `50% 50% -${l / 2}px`,
                        d.shadow)
                            if (h)
                                f.style.transform = `translate3d(0px, ${a / 2 + d.shadowOffset}px, ${-a / 2}px) rotateX(89.99deg) rotateZ(0deg) scale(${d.shadowScale})`;
                            else {
                                const e = Math.abs(m) - 90 * Math.floor(Math.abs(m) / 90)
                                  , t = 1.5 - (Math.sin(2 * e * Math.PI / 360) / 2 + Math.cos(2 * e * Math.PI / 360) / 2)
                                  , n = d.shadowScale
                                  , r = d.shadowScale / t
                                  , i = d.shadowOffset;
                                f.style.transform = `scale3d(${n}, 1, ${r}) translate3d(0px, ${s / 2 + i}px, ${-s / 2 / r}px) rotateX(-89.99deg)`
                            }
                        const g = (c.isSafari || c.isWebView) && c.needPerspectiveFix ? -l / 2 : 0;
                        n.style.transform = `translate3d(0px,0,${g}px) rotateX(${u(t.isHorizontal() ? 0 : m)}deg) rotateY(${u(t.isHorizontal() ? -m : 0)}deg)`,
                        n.style.setProperty("--swiper-cube-translate-z", `${g}px`)
                    }
                    ,
                    setTransition: e => {
                        const {el: n, slides: r} = t;
                        if (r.forEach((t => {
                            t.style.transitionDuration = `${e}ms`,
                            t.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((t => {
                                t.style.transitionDuration = `${e}ms`
                            }
                            ))
                        }
                        )),
                        t.params.cubeEffect.shadow && !t.isHorizontal()) {
                            const t = n.querySelector(".swiper-cube-shadow");
                            t && (t.style.transitionDuration = `${e}ms`)
                        }
                    }
                    ,
                    recreateShadows: () => {
                        const e = t.isHorizontal();
                        t.slides.forEach((t => {
                            const n = Math.max(Math.min(t.progress, 1), -1);
                            i(t, n, e)
                        }
                        ))
                    }
                    ,
                    getEffectParams: () => t.params.cubeEffect,
                    perspective: () => !0,
                    overwriteParams: () => ({
                        slidesPerView: 1,
                        slidesPerGroup: 1,
                        watchSlidesProgress: !0,
                        resistanceRatio: 0,
                        spaceBetween: 0,
                        centeredSlides: !1,
                        virtualTranslate: !0
                    })
                })
            }
            , function(e) {
                let {swiper: t, extendParams: n, on: r} = e;
                n({
                    flipEffect: {
                        slideShadows: !0,
                        limitRotation: !0
                    }
                });
                const i = (e, n) => {
                    let r = t.isHorizontal() ? e.querySelector(".swiper-slide-shadow-left") : e.querySelector(".swiper-slide-shadow-top")
                      , i = t.isHorizontal() ? e.querySelector(".swiper-slide-shadow-right") : e.querySelector(".swiper-slide-shadow-bottom");
                    r || (r = _x("flip", e, t.isHorizontal() ? "left" : "top")),
                    i || (i = _x("flip", e, t.isHorizontal() ? "right" : "bottom")),
                    r && (r.style.opacity = Math.max(-n, 0)),
                    i && (i.style.opacity = Math.max(n, 0))
                }
                ;
                mx({
                    effect: "flip",
                    swiper: t,
                    on: r,
                    setTranslate: () => {
                        const {slides: e, rtlTranslate: n} = t
                          , r = t.params.flipEffect
                          , a = Cy(t);
                        for (let s = 0; s < e.length; s += 1) {
                            const o = e[s];
                            let l = o.progress;
                            t.params.flipEffect.limitRotation && (l = Math.max(Math.min(o.progress, 1), -1));
                            const c = o.swiperSlideOffset;
                            let u = -180 * l
                              , d = 0
                              , h = t.params.cssMode ? -c - t.translate : -c
                              , p = 0;
                            t.isHorizontal() ? n && (u = -u) : (p = h,
                            h = 0,
                            d = -u,
                            u = 0),
                            o.style.zIndex = -Math.abs(Math.round(l)) + e.length,
                            r.slideShadows && i(o, l);
                            const f = `translate3d(${h}px, ${p}px, 0px) rotateX(${a(d)}deg) rotateY(${a(u)}deg)`;
                            gx(0, o).style.transform = f
                        }
                    }
                    ,
                    setTransition: e => {
                        const n = t.slides.map((e => vy(e)));
                        n.forEach((t => {
                            t.style.transitionDuration = `${e}ms`,
                            t.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((t => {
                                t.style.transitionDuration = `${e}ms`
                            }
                            ))
                        }
                        )),
                        vx({
                            swiper: t,
                            duration: e,
                            transformElements: n
                        })
                    }
                    ,
                    recreateShadows: () => {
                        t.params.flipEffect,
                        t.slides.forEach((e => {
                            let n = e.progress;
                            t.params.flipEffect.limitRotation && (n = Math.max(Math.min(e.progress, 1), -1)),
                            i(e, n)
                        }
                        ))
                    }
                    ,
                    getEffectParams: () => t.params.flipEffect,
                    perspective: () => !0,
                    overwriteParams: () => ({
                        slidesPerView: 1,
                        slidesPerGroup: 1,
                        watchSlidesProgress: !0,
                        spaceBetween: 0,
                        virtualTranslate: !t.params.cssMode
                    })
                })
            }
            , function(e) {
                let {swiper: t, extendParams: n, on: r} = e;
                n({
                    coverflowEffect: {
                        rotate: 50,
                        stretch: 0,
                        depth: 100,
                        scale: 1,
                        modifier: 1,
                        slideShadows: !0
                    }
                }),
                mx({
                    effect: "coverflow",
                    swiper: t,
                    on: r,
                    setTranslate: () => {
                        const {width: e, height: n, slides: r, slidesSizesGrid: i} = t
                          , a = t.params.coverflowEffect
                          , s = t.isHorizontal()
                          , o = t.translate
                          , l = s ? e / 2 - o : n / 2 - o
                          , c = s ? a.rotate : -a.rotate
                          , u = a.depth
                          , d = Cy(t);
                        for (let e = 0, t = r.length; e < t; e += 1) {
                            const t = r[e]
                              , n = i[e]
                              , o = (l - t.swiperSlideOffset - n / 2) / n
                              , h = "function" == typeof a.modifier ? a.modifier(o) : o * a.modifier;
                            let p = s ? c * h : 0
                              , f = s ? 0 : c * h
                              , m = -u * Math.abs(h)
                              , g = a.stretch;
                            "string" == typeof g && -1 !== g.indexOf("%") && (g = parseFloat(a.stretch) / 100 * n);
                            let v = s ? 0 : g * h
                              , _ = s ? g * h : 0
                              , y = 1 - (1 - a.scale) * Math.abs(h);
                            Math.abs(_) < .001 && (_ = 0),
                            Math.abs(v) < .001 && (v = 0),
                            Math.abs(m) < .001 && (m = 0),
                            Math.abs(p) < .001 && (p = 0),
                            Math.abs(f) < .001 && (f = 0),
                            Math.abs(y) < .001 && (y = 0);
                            const x = `translate3d(${_}px,${v}px,${m}px)  rotateX(${d(f)}deg) rotateY(${d(p)}deg) scale(${y})`;
                            if (gx(0, t).style.transform = x,
                            t.style.zIndex = 1 - Math.abs(Math.round(h)),
                            a.slideShadows) {
                                let e = s ? t.querySelector(".swiper-slide-shadow-left") : t.querySelector(".swiper-slide-shadow-top")
                                  , n = s ? t.querySelector(".swiper-slide-shadow-right") : t.querySelector(".swiper-slide-shadow-bottom");
                                e || (e = _x("coverflow", t, s ? "left" : "top")),
                                n || (n = _x("coverflow", t, s ? "right" : "bottom")),
                                e && (e.style.opacity = h > 0 ? h : 0),
                                n && (n.style.opacity = -h > 0 ? -h : 0)
                            }
                        }
                    }
                    ,
                    setTransition: e => {
                        t.slides.map((e => vy(e))).forEach((t => {
                            t.style.transitionDuration = `${e}ms`,
                            t.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((t => {
                                t.style.transitionDuration = `${e}ms`
                            }
                            ))
                        }
                        ))
                    }
                    ,
                    perspective: () => !0,
                    overwriteParams: () => ({
                        watchSlidesProgress: !0
                    })
                })
            }
            , function(e) {
                let {swiper: t, extendParams: n, on: r} = e;
                n({
                    creativeEffect: {
                        limitProgress: 1,
                        shadowPerProgress: !1,
                        progressMultiplier: 1,
                        perspective: !0,
                        prev: {
                            translate: [0, 0, 0],
                            rotate: [0, 0, 0],
                            opacity: 1,
                            scale: 1
                        },
                        next: {
                            translate: [0, 0, 0],
                            rotate: [0, 0, 0],
                            opacity: 1,
                            scale: 1
                        }
                    }
                });
                const i = e => "string" == typeof e ? e : `${e}px`;
                mx({
                    effect: "creative",
                    swiper: t,
                    on: r,
                    setTranslate: () => {
                        const {slides: e, wrapperEl: n, slidesSizesGrid: r} = t
                          , a = t.params.creativeEffect
                          , {progressMultiplier: s} = a
                          , o = t.params.centeredSlides
                          , l = Cy(t);
                        if (o) {
                            const e = r[0] / 2 - t.params.slidesOffsetBefore || 0;
                            n.style.transform = `translateX(calc(50% - ${e}px))`
                        }
                        for (let n = 0; n < e.length; n += 1) {
                            const r = e[n]
                              , c = r.progress
                              , u = Math.min(Math.max(r.progress, -a.limitProgress), a.limitProgress);
                            let d = u;
                            o || (d = Math.min(Math.max(r.originalProgress, -a.limitProgress), a.limitProgress));
                            const h = r.swiperSlideOffset
                              , p = [t.params.cssMode ? -h - t.translate : -h, 0, 0]
                              , f = [0, 0, 0];
                            let m = !1;
                            t.isHorizontal() || (p[1] = p[0],
                            p[0] = 0);
                            let g = {
                                translate: [0, 0, 0],
                                rotate: [0, 0, 0],
                                scale: 1,
                                opacity: 1
                            };
                            u < 0 ? (g = a.next,
                            m = !0) : u > 0 && (g = a.prev,
                            m = !0),
                            p.forEach(( (e, t) => {
                                p[t] = `calc(${e}px + (${i(g.translate[t])} * ${Math.abs(u * s)}))`
                            }
                            )),
                            f.forEach(( (e, t) => {
                                let n = g.rotate[t] * Math.abs(u * s);
                                f[t] = n
                            }
                            )),
                            r.style.zIndex = -Math.abs(Math.round(c)) + e.length;
                            const v = p.join(", ")
                              , _ = `rotateX(${l(f[0])}deg) rotateY(${l(f[1])}deg) rotateZ(${l(f[2])}deg)`
                              , y = d < 0 ? `scale(${1 + (1 - g.scale) * d * s})` : `scale(${1 - (1 - g.scale) * d * s})`
                              , x = d < 0 ? 1 + (1 - g.opacity) * d * s : 1 - (1 - g.opacity) * d * s
                              , b = `translate3d(${v}) ${_} ${y}`;
                            if (m && g.shadow || !m) {
                                let e = r.querySelector(".swiper-slide-shadow");
                                if (!e && g.shadow && (e = _x("creative", r)),
                                e) {
                                    const t = a.shadowPerProgress ? u * (1 / a.limitProgress) : u;
                                    e.style.opacity = Math.min(Math.max(Math.abs(t), 0), 1)
                                }
                            }
                            const E = gx(0, r);
                            E.style.transform = b,
                            E.style.opacity = x,
                            g.origin && (E.style.transformOrigin = g.origin)
                        }
                    }
                    ,
                    setTransition: e => {
                        const n = t.slides.map((e => vy(e)));
                        n.forEach((t => {
                            t.style.transitionDuration = `${e}ms`,
                            t.querySelectorAll(".swiper-slide-shadow").forEach((t => {
                                t.style.transitionDuration = `${e}ms`
                            }
                            ))
                        }
                        )),
                        vx({
                            swiper: t,
                            duration: e,
                            transformElements: n,
                            allSlides: !0
                        })
                    }
                    ,
                    perspective: () => t.params.creativeEffect.perspective,
                    overwriteParams: () => ({
                        watchSlidesProgress: !0,
                        virtualTranslate: !t.params.cssMode
                    })
                })
            }
            , function(e) {
                let {swiper: t, extendParams: n, on: r} = e;
                n({
                    cardsEffect: {
                        slideShadows: !0,
                        rotate: !0,
                        perSlideRotate: 2,
                        perSlideOffset: 8
                    }
                }),
                mx({
                    effect: "cards",
                    swiper: t,
                    on: r,
                    setTranslate: () => {
                        const {slides: e, activeIndex: n, rtlTranslate: r} = t
                          , i = t.params.cardsEffect
                          , {startTranslate: a, isTouched: s} = t.touchEventsData
                          , o = r ? -t.translate : t.translate;
                        for (let l = 0; l < e.length; l += 1) {
                            const c = e[l]
                              , u = c.progress
                              , d = Math.min(Math.max(u, -4), 4);
                            let h = c.swiperSlideOffset;
                            t.params.centeredSlides && !t.params.cssMode && (t.wrapperEl.style.transform = `translateX(${t.minTranslate()}px)`),
                            t.params.centeredSlides && t.params.cssMode && (h -= e[0].swiperSlideOffset);
                            let p = t.params.cssMode ? -h - t.translate : -h
                              , f = 0;
                            const m = -100 * Math.abs(d);
                            let g = 1
                              , v = -i.perSlideRotate * d
                              , _ = i.perSlideOffset - .75 * Math.abs(d);
                            const y = t.virtual && t.params.virtual.enabled ? t.virtual.from + l : l
                              , x = (y === n || y === n - 1) && d > 0 && d < 1 && (s || t.params.cssMode) && o < a
                              , b = (y === n || y === n + 1) && d < 0 && d > -1 && (s || t.params.cssMode) && o > a;
                            if (x || b) {
                                const e = (1 - Math.abs((Math.abs(d) - .5) / .5)) ** .5;
                                v += -28 * d * e,
                                g += -.5 * e,
                                _ += 96 * e,
                                f = -25 * e * Math.abs(d) + "%"
                            }
                            if (p = d < 0 ? `calc(${p}px ${r ? "-" : "+"} (${_ * Math.abs(d)}%))` : d > 0 ? `calc(${p}px ${r ? "-" : "+"} (-${_ * Math.abs(d)}%))` : `${p}px`,
                            !t.isHorizontal()) {
                                const e = f;
                                f = p,
                                p = e
                            }
                            const E = d < 0 ? "" + (1 + (1 - g) * d) : "" + (1 - (1 - g) * d)
                              , S = `\n        translate3d(${p}, ${f}, ${m}px)\n        rotateZ(${i.rotate ? r ? -v : v : 0}deg)\n        scale(${E})\n      `;
                            if (i.slideShadows) {
                                let e = c.querySelector(".swiper-slide-shadow");
                                e || (e = _x("cards", c)),
                                e && (e.style.opacity = Math.min(Math.max((Math.abs(d) - .5) / .5, 0), 1))
                            }
                            c.style.zIndex = -Math.abs(Math.round(u)) + e.length;
                            gx(0, c).style.transform = S
                        }
                    }
                    ,
                    setTransition: e => {
                        const n = t.slides.map((e => vy(e)));
                        n.forEach((t => {
                            t.style.transitionDuration = `${e}ms`,
                            t.querySelectorAll(".swiper-slide-shadow").forEach((t => {
                                t.style.transitionDuration = `${e}ms`
                            }
                            ))
                        }
                        )),
                        vx({
                            swiper: t,
                            duration: e,
                            transformElements: n
                        })
                    }
                    ,
                    perspective: () => !0,
                    overwriteParams: () => ({
                        watchSlidesProgress: !0,
                        virtualTranslate: !t.params.cssMode
                    })
                })
            }
            ];
            function xx(e) {
                return xx = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                }
                : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }
                ,
                xx(e)
            }
            function bx(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1,
                    r.configurable = !0,
                    "value"in r && (r.writable = !0),
                    Object.defineProperty(e, Ex(r.key), r)
                }
            }
            function Ex(e) {
                var t = function(e, t) {
                    if ("object" != xx(e) || !e)
                        return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var r = n.call(e, t || "default");
                        if ("object" != xx(r))
                            return r;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return ("string" === t ? String : Number)(e)
                }(e, "string");
                return "symbol" == xx(t) ? t : String(t)
            }
            function Sx(e, t, n) {
                return t = Mx(t),
                function(e, t) {
                    if (t && ("object" === xx(t) || "function" == typeof t))
                        return t;
                    if (void 0 !== t)
                        throw new TypeError("Derived constructors may only return object or undefined");
                    return function(e) {
                        if (void 0 === e)
                            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return e
                    }(e)
                }(e, wx() ? Reflect.construct(t, n || [], Mx(e).constructor) : t.apply(e, n))
            }
            function wx() {
                try {
                    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
                    )))
                } catch (e) {}
                return (wx = function() {
                    return !!e
                }
                )()
            }
            function Mx(e) {
                return Mx = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                }
                ,
                Mx(e)
            }
            function Tx(e, t) {
                return Tx = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
                    return e.__proto__ = t,
                    e
                }
                ,
                Tx(e, t)
            }
            ox.use(yx);
            var Ax = function(e) {
                function t(e) {
                    var n;
                    return function(e, t) {
                        if (!(e instanceof t))
                            throw new TypeError("Cannot call a class as a function")
                    }(this, t),
                    (n = Sx(this, t, [e])).slider = null,
                    n
                }
                var n, r, i;
                return function(e, t) {
                    if ("function" != typeof t && null !== t)
                        throw new TypeError("Super expression must either be null or a function");
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            writable: !0,
                            configurable: !0
                        }
                    }),
                    Object.defineProperty(e, "prototype", {
                        writable: !1
                    }),
                    t && Tx(e, t)
                }(t, e),
                n = t,
                (r = [{
                    key: "init",
                    value: function() {
                        var e = this;
                        this.slider = this.el.querySelector("[data-module-slideshow-container]"),
                        this.swiper = new ox(this.slider,{
                            slidesPerView: "auto",
                            centeredSlides: !0,
                            observer: !0,
                            observeParents: !0,
                            touchEventsTarget: "wrapper",
                            wrapperClass: "c-slideshow__wrapper",
                            slideClass: "c-slideshow__slide",
                            slideDuplicateClass: "c-slideshow__slide-duplicate",
                            slideActiveClass: "is-active",
                            slideDuplicateActiveClass: "c-slideshow__slide-duplicate-active",
                            slideNextClass: "c-slideshow__slide-next",
                            slideDuplicateNextClass: "c-slideshow__slide-duplicate-next",
                            slidePrevClass: "c-slideshow__slide-prev",
                            slideDuplicatePrevClass: "c-slideshow__slide-duplicate-prev",
                            slideToClickedSlide: !0,
                            navigation: {
                                nextEl: "[data-module-slideshow-next]",
                                prevEl: "[data-module-slideshow-prev]"
                            }
                        }),
                        this.swiper.on("touchStart", (function() {
                            e.el.classList.add("is-touching")
                        }
                        )),
                        this.swiper.on("touchEnd", (function() {
                            e.el.classList.remove("is-touching")
                        }
                        )),
                        y.IS_DEV && console.log("Slideshow: Initiated"),
                        this.swiper.update()
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        this.swiper.destroy(),
                        y.IS_DEV && console.log("Slideshow: Destroyed")
                    }
                }]) && bx(n.prototype, r),
                i && bx(n, i),
                Object.defineProperty(n, "prototype", {
                    writable: !1
                }),
                t
            }(p)
              , Cx = new m({
                modules: r
            })
              , Px = !1
              , Rx = !1;
            Si.set('[data-load="container"]', {
                x: "0vw",
                opacity: 0,
                duration: 0
            });
            var Lx = function() {
                var e = document.documentElement.style
                  , t = .01 * window.innerWidth;
                e.setProperty("--vw", "".concat(t, "px"));
                var n = .01 * window.innerHeight;
                if (e.setProperty("--vh", "".concat(n, "px")),
                !y.SUPPORTS_VH) {
                    var r = window.innerHeight
                      , i = .01 * document.documentElement.clientHeight;
                    e.setProperty("--svh", "".concat(i, "px"));
                    var a = .01 * r;
                    if (e.setProperty("--dvh", "".concat(a, "px")),
                    document.body) {
                        var s = document.createElement("div");
                        s.style.width = "1px",
                        s.style.height = "100vh",
                        s.style.position = "fixed",
                        s.style.left = "0",
                        s.style.top = "0",
                        s.style.bottom = "0",
                        s.style.visibility = "hidden",
                        document.body.appendChild(s);
                        var o = s.clientHeight;
                        s.remove();
                        var l = .01 * o;
                        e.setProperty("--lvh", "".concat(l, "px"))
                    }
                }
            }
              , Ox = function() {
                window.innerWidth >= 1440 && g.classList.contains(x.NAVIGATION_OPEN) && g.classList.remove(x.NAVIGATION_OPEN)
            };
            function Dx() {
                Lx(),
                Ox(),
                Cx.init(Cx),
                Si.to('[data-load="container"]', {
                    x: "0vw",
                    opacity: 1,
                    duration: 0,
                    delay: 1
                }),
                g.classList.add(x.LOADED),
                g.classList.add(x.READY),
                g.classList.remove(x.LOADING),
                g.classList.remove(x.INITIALIZING),
                g.classList.remove(x.NAVIGATION_OPEN);
                var e = new CustomEvent(b.RESIZE_END);
                window.addEventListener("resize", (function() {
                    Lx(),
                    Ox(),
                    function(e, t) {
                        var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
                          , r = null
                    }((function() {
                        window.dispatchEvent(e)
                    }
                    ), 200, !1)
                }
                )),
                window.addEventListener("orientationchange", (function() {
                    Lx(),
                    Ox()
                }
                )),
                y.IS_DEV && console.log("App: Initiated")
            }
            window.addEventListener("load", (function() {
                var e = document.getElementById("main-css")
                  , t = document.querySelector(".o-container");
                e ? e.isLoaded ? (Px = !0,
                Rx && Dx()) : e.addEventListener("load", (function() {
                    Px = !0,
                    Rx && Dx()
                }
                )) : console.warn('The "main-css" stylesheet not found'),
                Ni()(t, (function() {
                    Rx = !0,
                    Px && Dx()
                }
                ))
            }
            ))
        },
        137: function(e) {
            var t, n;
            t = "undefined" != typeof window ? window : this,
            n = function() {
                function e() {}
                let t = e.prototype;
                return t.on = function(e, t) {
                    if (!e || !t)
                        return this;
                    let n = this._events = this._events || {}
                      , r = n[e] = n[e] || [];
                    return r.includes(t) || r.push(t),
                    this
                }
                ,
                t.once = function(e, t) {
                    if (!e || !t)
                        return this;
                    this.on(e, t);
                    let n = this._onceEvents = this._onceEvents || {};
                    return (n[e] = n[e] || {})[t] = !0,
                    this
                }
                ,
                t.off = function(e, t) {
                    let n = this._events && this._events[e];
                    if (!n || !n.length)
                        return this;
                    let r = n.indexOf(t);
                    return -1 != r && n.splice(r, 1),
                    this
                }
                ,
                t.emitEvent = function(e, t) {
                    let n = this._events && this._events[e];
                    if (!n || !n.length)
                        return this;
                    n = n.slice(0),
                    t = t || [];
                    let r = this._onceEvents && this._onceEvents[e];
                    for (let i of n)
                        r && r[i] && (this.off(e, i),
                        delete r[i]),
                        i.apply(this, t);
                    return this
                }
                ,
                t.allOff = function() {
                    return delete this._events,
                    delete this._onceEvents,
                    this
                }
                ,
                e
            }
            ,
            e.exports ? e.exports = n() : t.EvEmitter = n()
        },
        7: function(e) {
            "use strict";
            var t, n = "object" == typeof Reflect ? Reflect : null, r = n && "function" == typeof n.apply ? n.apply : function(e, t, n) {
                return Function.prototype.apply.call(e, t, n)
            }
            ;
            t = n && "function" == typeof n.ownKeys ? n.ownKeys : Object.getOwnPropertySymbols ? function(e) {
                return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
            }
            : function(e) {
                return Object.getOwnPropertyNames(e)
            }
            ;
            var i = Number.isNaN || function(e) {
                return e != e
            }
            ;
            function a() {
                a.init.call(this)
            }
            e.exports = a,
            e.exports.once = function(e, t) {
                return new Promise((function(n, r) {
                    function i(n) {
                        e.removeListener(t, a),
                        r(n)
                    }
                    function a() {
                        "function" == typeof e.removeListener && e.removeListener("error", i),
                        n([].slice.call(arguments))
                    }
                    m(e, t, a, {
                        once: !0
                    }),
                    "error" !== t && function(e, t, n) {
                        "function" == typeof e.on && m(e, "error", t, n)
                    }(e, i, {
                        once: !0
                    })
                }
                ))
            }
            ,
            a.EventEmitter = a,
            a.prototype._events = void 0,
            a.prototype._eventsCount = 0,
            a.prototype._maxListeners = void 0;
            var s = 10;
            function o(e) {
                if ("function" != typeof e)
                    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e)
            }
            function l(e) {
                return void 0 === e._maxListeners ? a.defaultMaxListeners : e._maxListeners
            }
            function c(e, t, n, r) {
                var i, a, s, c;
                if (o(n),
                void 0 === (a = e._events) ? (a = e._events = Object.create(null),
                e._eventsCount = 0) : (void 0 !== a.newListener && (e.emit("newListener", t, n.listener ? n.listener : n),
                a = e._events),
                s = a[t]),
                void 0 === s)
                    s = a[t] = n,
                    ++e._eventsCount;
                else if ("function" == typeof s ? s = a[t] = r ? [n, s] : [s, n] : r ? s.unshift(n) : s.push(n),
                (i = l(e)) > 0 && s.length > i && !s.warned) {
                    s.warned = !0;
                    var u = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                    u.name = "MaxListenersExceededWarning",
                    u.emitter = e,
                    u.type = t,
                    u.count = s.length,
                    c = u,
                    console && console.warn && console.warn(c)
                }
                return e
            }
            function u() {
                if (!this.fired)
                    return this.target.removeListener(this.type, this.wrapFn),
                    this.fired = !0,
                    0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
            }
            function d(e, t, n) {
                var r = {
                    fired: !1,
                    wrapFn: void 0,
                    target: e,
                    type: t,
                    listener: n
                }
                  , i = u.bind(r);
                return i.listener = n,
                r.wrapFn = i,
                i
            }
            function h(e, t, n) {
                var r = e._events;
                if (void 0 === r)
                    return [];
                var i = r[t];
                return void 0 === i ? [] : "function" == typeof i ? n ? [i.listener || i] : [i] : n ? function(e) {
                    for (var t = new Array(e.length), n = 0; n < t.length; ++n)
                        t[n] = e[n].listener || e[n];
                    return t
                }(i) : f(i, i.length)
            }
            function p(e) {
                var t = this._events;
                if (void 0 !== t) {
                    var n = t[e];
                    if ("function" == typeof n)
                        return 1;
                    if (void 0 !== n)
                        return n.length
                }
                return 0
            }
            function f(e, t) {
                for (var n = new Array(t), r = 0; r < t; ++r)
                    n[r] = e[r];
                return n
            }
            function m(e, t, n, r) {
                if ("function" == typeof e.on)
                    r.once ? e.once(t, n) : e.on(t, n);
                else {
                    if ("function" != typeof e.addEventListener)
                        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
                    e.addEventListener(t, (function i(a) {
                        r.once && e.removeEventListener(t, i),
                        n(a)
                    }
                    ))
                }
            }
            Object.defineProperty(a, "defaultMaxListeners", {
                enumerable: !0,
                get: function() {
                    return s
                },
                set: function(e) {
                    if ("number" != typeof e || e < 0 || i(e))
                        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
                    s = e
                }
            }),
            a.init = function() {
                void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null),
                this._eventsCount = 0),
                this._maxListeners = this._maxListeners || void 0
            }
            ,
            a.prototype.setMaxListeners = function(e) {
                if ("number" != typeof e || e < 0 || i(e))
                    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
                return this._maxListeners = e,
                this
            }
            ,
            a.prototype.getMaxListeners = function() {
                return l(this)
            }
            ,
            a.prototype.emit = function(e) {
                for (var t = [], n = 1; n < arguments.length; n++)
                    t.push(arguments[n]);
                var i = "error" === e
                  , a = this._events;
                if (void 0 !== a)
                    i = i && void 0 === a.error;
                else if (!i)
                    return !1;
                if (i) {
                    var s;
                    if (t.length > 0 && (s = t[0]),
                    s instanceof Error)
                        throw s;
                    var o = new Error("Unhandled error." + (s ? " (" + s.message + ")" : ""));
                    throw o.context = s,
                    o
                }
                var l = a[e];
                if (void 0 === l)
                    return !1;
                if ("function" == typeof l)
                    r(l, this, t);
                else {
                    var c = l.length
                      , u = f(l, c);
                    for (n = 0; n < c; ++n)
                        r(u[n], this, t)
                }
                return !0
            }
            ,
            a.prototype.addListener = function(e, t) {
                return c(this, e, t, !1)
            }
            ,
            a.prototype.on = a.prototype.addListener,
            a.prototype.prependListener = function(e, t) {
                return c(this, e, t, !0)
            }
            ,
            a.prototype.once = function(e, t) {
                return o(t),
                this.on(e, d(this, e, t)),
                this
            }
            ,
            a.prototype.prependOnceListener = function(e, t) {
                return o(t),
                this.prependListener(e, d(this, e, t)),
                this
            }
            ,
            a.prototype.removeListener = function(e, t) {
                var n, r, i, a, s;
                if (o(t),
                void 0 === (r = this._events))
                    return this;
                if (void 0 === (n = r[e]))
                    return this;
                if (n === t || n.listener === t)
                    0 == --this._eventsCount ? this._events = Object.create(null) : (delete r[e],
                    r.removeListener && this.emit("removeListener", e, n.listener || t));
                else if ("function" != typeof n) {
                    for (i = -1,
                    a = n.length - 1; a >= 0; a--)
                        if (n[a] === t || n[a].listener === t) {
                            s = n[a].listener,
                            i = a;
                            break
                        }
                    if (i < 0)
                        return this;
                    0 === i ? n.shift() : function(e, t) {
                        for (; t + 1 < e.length; t++)
                            e[t] = e[t + 1];
                        e.pop()
                    }(n, i),
                    1 === n.length && (r[e] = n[0]),
                    void 0 !== r.removeListener && this.emit("removeListener", e, s || t)
                }
                return this
            }
            ,
            a.prototype.off = a.prototype.removeListener,
            a.prototype.removeAllListeners = function(e) {
                var t, n, r;
                if (void 0 === (n = this._events))
                    return this;
                if (void 0 === n.removeListener)
                    return 0 === arguments.length ? (this._events = Object.create(null),
                    this._eventsCount = 0) : void 0 !== n[e] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete n[e]),
                    this;
                if (0 === arguments.length) {
                    var i, a = Object.keys(n);
                    for (r = 0; r < a.length; ++r)
                        "removeListener" !== (i = a[r]) && this.removeAllListeners(i);
                    return this.removeAllListeners("removeListener"),
                    this._events = Object.create(null),
                    this._eventsCount = 0,
                    this
                }
                if ("function" == typeof (t = n[e]))
                    this.removeListener(e, t);
                else if (void 0 !== t)
                    for (r = t.length - 1; r >= 0; r--)
                        this.removeListener(e, t[r]);
                return this
            }
            ,
            a.prototype.listeners = function(e) {
                return h(this, e, !0)
            }
            ,
            a.prototype.rawListeners = function(e) {
                return h(this, e, !1)
            }
            ,
            a.listenerCount = function(e, t) {
                return "function" == typeof e.listenerCount ? e.listenerCount(t) : p.call(e, t)
            }
            ,
            a.prototype.listenerCount = p,
            a.prototype.eventNames = function() {
                return this._eventsCount > 0 ? t(this._events) : []
            }
        },
        802: function(e) {
            e.exports = "// @author brunoimbrizi / http://brunoimbrizi.com\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D uTexture;\n\nvarying vec2 vPUv;\nvarying vec2 vUv;\n\nvoid main() {\n\tvec4 color = vec4(0.0);\n\tvec2 uv = vUv;\n\tvec2 puv = vPUv;\n\n\t// pixel color\n\tvec4 colA = texture2D(uTexture, puv);\n\n\t// greyscale\n\tfloat grey = colA.r * 0.21 + colA.g * 0.71 + colA.b * 0.07;\n\tvec4 colB = vec4(grey, grey, grey, 1.0);\n\n\t// circle\n\tfloat border = 0.3;\n\tfloat radius = 0.5;\n\tfloat dist = radius - distance(uv, vec2(0.5));\n\tfloat t = smoothstep(0.0, border, dist);\n\n\t// final color\n\tcolor = colB;\n\tcolor.a = t;\n\n\tgl_FragColor = color;\n}"
        },
        451: function(e) {
            e.exports = "// @author brunoimbrizi / http://brunoimbrizi.com\n\nprecision highp float;\n#define GLSLIFY 1\n\nattribute float pindex;\nattribute vec3 position;\nattribute vec3 offset;\nattribute vec2 uv;\nattribute float angle;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nuniform float uTime;\nuniform float uRandom;\nuniform float uDepth;\nuniform float uSize;\nuniform vec2 uTextureSize;\nuniform sampler2D uTexture;\nuniform sampler2D uTouch;\n\nvarying vec2 vPUv;\nvarying vec2 vUv;\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat random(float n) {\n\treturn fract(sin(n) * 43758.5453123);\n}\n\nvoid main() {\n\tvUv = uv;\n\n\t// particle uv\n\tvec2 puv = offset.xy / uTextureSize;\n\tvPUv = puv;\n\n\t// pixel color\n\tvec4 colA = texture2D(uTexture, puv);\n\tfloat grey = colA.r * 0.21 + colA.g * 0.71 + colA.b * 0.07;\n\n\t// displacement\n\tvec3 displaced = offset;\n\t// randomise\n\tdisplaced.xy += vec2(random(pindex) - 0.5, random(offset.x + pindex) - 0.5) * uRandom;\n\tfloat rndz = (random(pindex) + snoise(vec2(pindex * 0.1, uTime * 0.1)));\n\tdisplaced.z += rndz * (random(pindex) * 2.0 * uDepth);\n\t// center\n\tdisplaced.xy -= uTextureSize * 0.5;\n\n\t// touch\n\tfloat t = texture2D(uTouch, puv).r;\n\tdisplaced.z += t * 20.0 * rndz;\n\tdisplaced.x += cos(angle) * t * 20.0 * rndz;\n\tdisplaced.y += sin(angle) * t * 20.0 * rndz;\n\n\t// particle size\n\tfloat psize = (snoise(vec2(uTime, pindex) * 0.5) + 2.0);\n\tpsize *= max(grey, 0.2);\n\tpsize *= uSize;\n\n\t// final position\n\tvec4 mvPosition = modelViewMatrix * vec4(displaced, 1.0);\n\tmvPosition.xyz += position * psize;\n\tvec4 finalPosition = projectionMatrix * mvPosition;\n\n\tgl_Position = finalPosition;\n}\n"
        },
        209: function(e) {
            e.exports = function(e) {
                "string" == typeof e && (e = [e]);
                for (var t = [].slice.call(arguments, 1), n = [], r = 0; r < e.length - 1; r++)
                    n.push(e[r], t[r] || "");
                return n.push(e[r]),
                n.join("")
            }
        },
        943: function(e, t, n) {
            !function(t, r) {
                e.exports ? e.exports = r(t, n(137)) : t.imagesLoaded = r(t, t.EvEmitter)
            }("undefined" != typeof window ? window : this, (function(e, t) {
                let n = e.jQuery
                  , r = e.console;
                function i(e, t, a) {
                    if (!(this instanceof i))
                        return new i(e,t,a);
                    let s = e;
                    var o;
                    ("string" == typeof e && (s = document.querySelectorAll(e)),
                    s) ? (this.elements = (o = s,
                    Array.isArray(o) ? o : "object" == typeof o && "number" == typeof o.length ? [...o] : [o]),
                    this.options = {},
                    "function" == typeof t ? a = t : Object.assign(this.options, t),
                    a && this.on("always", a),
                    this.getImages(),
                    n && (this.jqDeferred = new n.Deferred),
                    setTimeout(this.check.bind(this))) : r.error(`Bad element for imagesLoaded ${s || e}`)
                }
                i.prototype = Object.create(t.prototype),
                i.prototype.getImages = function() {
                    this.images = [],
                    this.elements.forEach(this.addElementImages, this)
                }
                ;
                const a = [1, 9, 11];
                i.prototype.addElementImages = function(e) {
                    "IMG" === e.nodeName && this.addImage(e),
                    !0 === this.options.background && this.addElementBackgroundImages(e);
                    let {nodeType: t} = e;
                    if (!t || !a.includes(t))
                        return;
                    let n = e.querySelectorAll("img");
                    for (let e of n)
                        this.addImage(e);
                    if ("string" == typeof this.options.background) {
                        let t = e.querySelectorAll(this.options.background);
                        for (let e of t)
                            this.addElementBackgroundImages(e)
                    }
                }
                ;
                const s = /url\((['"])?(.*?)\1\)/gi;
                function o(e) {
                    this.img = e
                }
                function l(e, t) {
                    this.url = e,
                    this.element = t,
                    this.img = new Image
                }
                return i.prototype.addElementBackgroundImages = function(e) {
                    let t = getComputedStyle(e);
                    if (!t)
                        return;
                    let n = s.exec(t.backgroundImage);
                    for (; null !== n; ) {
                        let r = n && n[2];
                        r && this.addBackground(r, e),
                        n = s.exec(t.backgroundImage)
                    }
                }
                ,
                i.prototype.addImage = function(e) {
                    let t = new o(e);
                    this.images.push(t)
                }
                ,
                i.prototype.addBackground = function(e, t) {
                    let n = new l(e,t);
                    this.images.push(n)
                }
                ,
                i.prototype.check = function() {
                    if (this.progressedCount = 0,
                    this.hasAnyBroken = !1,
                    !this.images.length)
                        return void this.complete();
                    let e = (e, t, n) => {
                        setTimeout(( () => {
                            this.progress(e, t, n)
                        }
                        ))
                    }
                    ;
                    this.images.forEach((function(t) {
                        t.once("progress", e),
                        t.check()
                    }
                    ))
                }
                ,
                i.prototype.progress = function(e, t, n) {
                    this.progressedCount++,
                    this.hasAnyBroken = this.hasAnyBroken || !e.isLoaded,
                    this.emitEvent("progress", [this, e, t]),
                    this.jqDeferred && this.jqDeferred.notify && this.jqDeferred.notify(this, e),
                    this.progressedCount === this.images.length && this.complete(),
                    this.options.debug && r && r.log(`progress: ${n}`, e, t)
                }
                ,
                i.prototype.complete = function() {
                    let e = this.hasAnyBroken ? "fail" : "done";
                    if (this.isComplete = !0,
                    this.emitEvent(e, [this]),
                    this.emitEvent("always", [this]),
                    this.jqDeferred) {
                        let e = this.hasAnyBroken ? "reject" : "resolve";
                        this.jqDeferred[e](this)
                    }
                }
                ,
                o.prototype = Object.create(t.prototype),
                o.prototype.check = function() {
                    this.getIsImageComplete() ? this.confirm(0 !== this.img.naturalWidth, "naturalWidth") : (this.proxyImage = new Image,
                    this.img.crossOrigin && (this.proxyImage.crossOrigin = this.img.crossOrigin),
                    this.proxyImage.addEventListener("load", this),
                    this.proxyImage.addEventListener("error", this),
                    this.img.addEventListener("load", this),
                    this.img.addEventListener("error", this),
                    this.proxyImage.src = this.img.currentSrc || this.img.src)
                }
                ,
                o.prototype.getIsImageComplete = function() {
                    return this.img.complete && this.img.naturalWidth
                }
                ,
                o.prototype.confirm = function(e, t) {
                    this.isLoaded = e;
                    let {parentNode: n} = this.img
                      , r = "PICTURE" === n.nodeName ? n : this.img;
                    this.emitEvent("progress", [this, r, t])
                }
                ,
                o.prototype.handleEvent = function(e) {
                    let t = "on" + e.type;
                    this[t] && this[t](e)
                }
                ,
                o.prototype.onload = function() {
                    this.confirm(!0, "onload"),
                    this.unbindEvents()
                }
                ,
                o.prototype.onerror = function() {
                    this.confirm(!1, "onerror"),
                    this.unbindEvents()
                }
                ,
                o.prototype.unbindEvents = function() {
                    this.proxyImage.removeEventListener("load", this),
                    this.proxyImage.removeEventListener("error", this),
                    this.img.removeEventListener("load", this),
                    this.img.removeEventListener("error", this)
                }
                ,
                l.prototype = Object.create(o.prototype),
                l.prototype.check = function() {
                    this.img.addEventListener("load", this),
                    this.img.addEventListener("error", this),
                    this.img.src = this.url,
                    this.getIsImageComplete() && (this.confirm(0 !== this.img.naturalWidth, "naturalWidth"),
                    this.unbindEvents())
                }
                ,
                l.prototype.unbindEvents = function() {
                    this.img.removeEventListener("load", this),
                    this.img.removeEventListener("error", this)
                }
                ,
                l.prototype.confirm = function(e, t) {
                    this.isLoaded = e,
                    this.emitEvent("progress", [this, this.element, t])
                }
                ,
                i.makeJQueryPlugin = function(t) {
                    (t = t || e.jQuery) && (n = t,
                    n.fn.imagesLoaded = function(e, t) {
                        return new i(this,e,t).jqDeferred.promise(n(this))
                    }
                    )
                }
                ,
                i.makeJQueryPlugin(),
                i
            }
            ))
        },
        497: function() {},
        945: function() {},
        606: function(e) {
            var t, n, r = e.exports = {};
            function i() {
                throw new Error("setTimeout has not been defined")
            }
            function a() {
                throw new Error("clearTimeout has not been defined")
            }
            function s(e) {
                if (t === setTimeout)
                    return setTimeout(e, 0);
                if ((t === i || !t) && setTimeout)
                    return t = setTimeout,
                    setTimeout(e, 0);
                try {
                    return t(e, 0)
                } catch (n) {
                    try {
                        return t.call(null, e, 0)
                    } catch (n) {
                        return t.call(this, e, 0)
                    }
                }
            }
            !function() {
                try {
                    t = "function" == typeof setTimeout ? setTimeout : i
                } catch (e) {
                    t = i
                }
                try {
                    n = "function" == typeof clearTimeout ? clearTimeout : a
                } catch (e) {
                    n = a
                }
            }();
            var o, l = [], c = !1, u = -1;
            function d() {
                c && o && (c = !1,
                o.length ? l = o.concat(l) : u = -1,
                l.length && h())
            }
            function h() {
                if (!c) {
                    var e = s(d);
                    c = !0;
                    for (var t = l.length; t; ) {
                        for (o = l,
                        l = []; ++u < t; )
                            o && o[u].run();
                        u = -1,
                        t = l.length
                    }
                    o = null,
                    c = !1,
                    function(e) {
                        if (n === clearTimeout)
                            return clearTimeout(e);
                        if ((n === a || !n) && clearTimeout)
                            return n = clearTimeout,
                            clearTimeout(e);
                        try {
                            return n(e)
                        } catch (t) {
                            try {
                                return n.call(null, e)
                            } catch (t) {
                                return n.call(this, e)
                            }
                        }
                    }(e)
                }
            }
            function p(e, t) {
                this.fun = e,
                this.array = t
            }
            function f() {}
            r.nextTick = function(e) {
                var t = new Array(arguments.length - 1);
                if (arguments.length > 1)
                    for (var n = 1; n < arguments.length; n++)
                        t[n - 1] = arguments[n];
                l.push(new p(e,t)),
                1 !== l.length || c || s(h)
            }
            ,
            p.prototype.run = function() {
                this.fun.apply(null, this.array)
            }
            ,
            r.title = "browser",
            r.browser = !0,
            r.env = {},
            r.argv = [],
            r.version = "",
            r.versions = {},
            r.on = f,
            r.addListener = f,
            r.once = f,
            r.off = f,
            r.removeListener = f,
            r.removeAllListeners = f,
            r.emit = f,
            r.prependListener = f,
            r.prependOnceListener = f,
            r.listeners = function(e) {
                return []
            }
            ,
            r.binding = function(e) {
                throw new Error("process.binding is not supported")
            }
            ,
            r.cwd = function() {
                return "/"
            }
            ,
            r.chdir = function(e) {
                throw new Error("process.chdir is not supported")
            }
            ,
            r.umask = function() {
                return 0
            }
        }
    }, n = {};
    function r(e) {
        var i = n[e];
        if (void 0 !== i)
            return i.exports;
        var a = n[e] = {
            exports: {}
        };
        return t[e].call(a.exports, a, a.exports, r),
        a.exports
    }
    r.m = t,
    e = [],
    r.O = function(t, n, i, a) {
        if (!n) {
            var s = 1 / 0;
            for (u = 0; u < e.length; u++) {
                n = e[u][0],
                i = e[u][1],
                a = e[u][2];
                for (var o = !0, l = 0; l < n.length; l++)
                    (!1 & a || s >= a) && Object.keys(r.O).every((function(e) {
                        return r.O[e](n[l])
                    }
                    )) ? n.splice(l--, 1) : (o = !1,
                    a < s && (s = a));
                if (o) {
                    e.splice(u--, 1);
                    var c = i();
                    void 0 !== c && (t = c)
                }
            }
            return t
        }
        a = a || 0;
        for (var u = e.length; u > 0 && e[u - 1][2] > a; u--)
            e[u] = e[u - 1];
        e[u] = [n, i, a]
    }
    ,
    r.n = function(e) {
        var t = e && e.__esModule ? function() {
            return e.default
        }
        : function() {
            return e
        }
        ;
        return r.d(t, {
            a: t
        }),
        t
    }
    ,
    r.d = function(e, t) {
        for (var n in t)
            r.o(t, n) && !r.o(e, n) && Object.defineProperty(e, n, {
                enumerable: !0,
                get: t[n]
            })
    }
    ,
    r.o = function(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }
    ,
    r.r = function(e) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
        }),
        Object.defineProperty(e, "__esModule", {
            value: !0
        })
    }
    ,
    function() {
        var e = {
            318: 0,
            897: 0,
            696: 0
        };
        r.O.j = function(t) {
            return 0 === e[t]
        }
        ;
        var t = function(t, n) {
            var i, a, s = n[0], o = n[1], l = n[2], c = 0;
            if (s.some((function(t) {
                return 0 !== e[t]
            }
            ))) {
                for (i in o)
                    r.o(o, i) && (r.m[i] = o[i]);
                if (l)
                    var u = l(r)
            }
            for (t && t(n); c < s.length; c++)
                a = s[c],
                r.o(e, a) && e[a] && e[a][0](),
                e[a] = 0;
            return r.O(u)
        }
          , n = self.webpackChunkevan_bartlett_website = self.webpackChunkevan_bartlett_website || [];
        n.forEach(t.bind(null, 0)),
        n.push = t.bind(null, n.push.bind(n))
    }(),
    r.O(void 0, [897, 696], (function() {
        return r(897)
    }
    )),
    r.O(void 0, [897, 696], (function() {
        return r(497)
    }
    ));
    var i = r.O(void 0, [897, 696], (function() {
        return r(945)
    }
    ));
    i = r.O(i)
}();
